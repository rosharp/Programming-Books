<?xml version="1.0" encoding="utf-8"?><FictionBook xmlns="http://www.gribuser.ru/xml/fictionbook/2.0" xmlns:l="http://www.w3.org/1999/xlink"><description><title-info><genre>foreign_comp</genre><genre>comp_programming</genre> <author><first-name>Кент</first-name><last-name>Бек</last-name><id>7e9b6596-5b3f-102b-94c2-fc330996d25d</id></author><book-title>Экстремальное программирование. Разработка через тестирование</book-title><annotation><p>Возвращение знаменитого бестселлера. Изящный, гибкий и понятный код, который легко модифицировать, который корректно работает и который не подкидывает своим создателям неприятных сюрпризов. Неужели подобное возможно? Чтобы достичь цели, попробуйте тестировать программу еще до того, как она написана. Именно такая парадоксальная идея положена в основу методики TDD (Test-Driven-Development – разработка, основанная на тестировании). Бессмыслица? Не спешите делать скороспелые выводы. Рассматривая применение TDD на примере разработки реального программного кода, автор демонстрирует простоту и мощь этой методики. В книге приведены два программных проекта, целиком и полностью реализованных с использованием TDD. За рассмотрением примеров следует обширный каталог приемов работы в стиле TDD, а также паттернов и рефакторингов, имеющих отношение к TDD. Книга будет полезна для любого программиста, желающего повысить производительность своей работы и получить удовольствие от программирования.</p>
</annotation> <keywords>тестирование,искусство программирования,разработка программного обеспечения</keywords><date value="2003-01-01">2003</date> <coverpage><image l:href="#cover.jpg"></image></coverpage><lang>ru</lang><src-lang>en</src-lang> <translator><first-name>П.</first-name><last-name>Анджан</last-name><id>551abace-120e-11e4-824d-0025905a06ea</id></translator><sequence name="Библиотека программиста (Питер)"></sequence></title-info><document-info><author><first-name>Олег</first-name> <last-name>Власов</last-name> <nickname>prussol</nickname> </author> <program-used>FictionBook Editor Release 2.6.7</program-used> <date value="2017-06-28">28.06.2017</date> <src-url>http://www.litres.ru/pages/biblio_book/?art=164068</src-url><src-ocr>Текст предоставлен правообладателем</src-ocr> <id>86e07f7f-5b3f-102b-94c2-fc330996d25d</id> <version>1.0</version> <history><p>V 1.0 by prussol</p>
</history> <publisher><first-name>Издательство</first-name><last-name>Питер</last-name><id>046ebc0b-b024-102a-94d5-07de47c81719</id></publisher></document-info> <publish-info><book-name>Экстремальное программирование: разработка через тестирование. / К. Бек</book-name> <publisher>Питер</publisher> <city>Санкт-Петербург</city> <year>2017</year> <isbn>978-5-496-02570-6</isbn> </publish-info> <custom-info info-type="">Все права защищены. Никакая часть данной книги не может быть воспроизведена в какой бы то ни было форме без письменного разрешения владельцев авторских прав. © 2003 by Pearson Education, Inc. © Перевод на русский язык ООО Издательство «Питер», 2017 © Издание на русском языке, оформление ООО Издательство «Питер», 2017 © Серия «Библиотека программиста», 2017</custom-info> </description><body><title><p>Кент Бек</p>
<p>Экстремальное программирование: разработка через тестирование</p>
</title><epigraph><p>Посвящается Синди: крыльям моей души</p>
</epigraph><section><p>Права на издание получены по соглашению с Addison-Wesley Longman. Все права защищены. Никакая часть данной книги не может быть воспроизведена в какой бы то ни было форме без письменного разрешения владельцев авторских прав.</p>
<empty-line></empty-line><p>Информация, содержащаяся в данной книге, получена из источников, рассматриваемых издательством как надежные. Тем не менее, имея в виду возможные человеческие или технические ошибки, издательство не может гарантировать абсолютную точность и полноту приводимых сведений и не несет ответственности за возможные ошибки, связанные с использованием книги.</p>
<empty-line></empty-line><p>ISBN 978-0321146533 англ.</p>
<p>ISBN 978-5-496-02570-6</p>
<empty-line></empty-line><p>© 2003 by Pearson Education, Inc.</p>
<p>© Перевод на русский язык ООО Издательство «Питер», 2017</p>
<p>© Издание на русском языке, оформление ООО Издательство «Питер», 2017</p>
<p>© Серия «Библиотека программиста», 2017</p>
</section><section><title><p>Предисловие</p>
</title><p><emphasis>Чистый код, который работает</emphasis> (clean code that works), – в этой короткой, но содержательной фразе, придуманной Роном Джеффризом (Ron Jeffries), кроется весь смысл методики разработки через тестирование (Test-Driven Development, TDD). Чистый код, который работает, – это цель, к которой стоит стремиться потому, что</p>
<p>• это предсказуемый способ разработки программ. Вы знаете, когда работу можно считать законченной и не беспокоиться о длинной череде ошибок;</p>
<p>• дает шанс усвоить уроки, которые преподносит код. Если вы воспользуетесь первой же идеей, которая пришла в голову, у вас не будет шанса реализовать вторую, лучшую идею;</p>
<p>• улучшает жизнь пользователей ваших программ;</p>
<p>• позволяет вашим коллегам рассчитывать на вас, а вам – рассчитывать на них;</p>
<p>• писать такой код приятнее.</p>
<p>Но как получить чистый код, который работает? Многие силы мешают нам получить чистый код, а иногда не удается даже получить код, который просто работает. Чтобы избавиться от множества проблем, мы будем разрабатывать код, опираясь на автоматизированное тестирование. Такой стиль программирования называется разработкой через тестирование. Согласно этой методике</p>
<p>• новый код пишется только после того, как будет написан автоматический тест, завершающийся неудачей;</p>
<p>• любое дублирование устраняется.</p>
<p>Два простых правила, не правда ли? Однако они генерируют сложное индивидуальное и групповое поведение со множеством технических последствий:</p>
<p>• в процессе проектирования мы постоянно запускаем код и получаем представление о его работе, это помогает принимать правильные решения;</p>
<p>• мы сами пишем тесты, так как не можем ждать, что кто-то другой напишет тесты для нас;</p>
<p>• наша среда разработки должна быстро реагировать на небольшие модификации кода;</p>
<p>• дизайн программы должен базироваться на использовании множества автономных, слабо связанных компонентов, чтобы упростить тестирование кода.</p>
<p>Два упомянутых правила TDD определяют порядок этапов программирования.</p>
<p>1. Красный – напишите небольшой тест, который не работает, а возможно, даже не компилируется.</p>
<p>2. Зеленый – заставьте тест работать как можно быстрее, при этом не думайте о правильности дизайна и чистоте кода. Напишите ровно столько кода, чтобы тест сработал.</p>
<p>3. Рефакторинг – устраните из написанного кода любое дублирование.</p>
<p>Красный – зеленый – рефакторинг – это мантра TDD.</p>
<p>Если допустить, что такой стиль программирования возможен, можно предположить, что благодаря его использованию код будет содержать существенно меньше дефектов, кроме того, цель работы будет ясна всем, кто принимает в ней участие. Если так, тогда разработка только кода, необходимого для прохождения тестов, приводит также к социальным последствиям:</p>
<p>• при достаточно низкой плотности дефектов команда контроля качества (Quality Assurance, QA) сможет перейти от реагирования на ошибки к их предупреждению;</p>
<p>• с уменьшением количества неприятных сюрпризов менеджеры проекта смогут точнее оценить трудозатраты и вовлечь заказчиков в процесс разработки;</p>
<p>• если темы технических дискуссий будут четко определены, программисты смогут взаимодействовать друг с другом постоянно, а не раз в день или раз в неделю;</p>
<p>• и снова при достаточно низкой плотности дефектов мы сможем каждый день получать интегрированный рабочий продукт с добавленной в него новой функциональностью, благодаря чему мы сможем вступить с нашими заказчиками в деловые отношения совершенно нового типа.</p>
<p>Итак, идея проста, но в чем наш интерес? Почему программист должен взять на себя дополнительную обязанность писать автоматизированные тесты? Зачем программисту двигаться вперед малюсенькими шажками, когда его мозг в состоянии продумать гораздо более сложную структуру дизайна? Храбрость.</p>
<subtitle><emphasis><strong>Храбрость</strong></emphasis></subtitle><p>TDD – это способ управления страхом в процессе программирования. Я не имею в виду страх падения со стула или страх перед начальником. Я имею в виду страх перед задачей, «настолько сложной, что я пока понятия не имею, как ее решить». Боль – это когда природа говорит нам: «Стоп!», а страх – это когда природа говорит нам: «Будь осторожен!» Осторожность – это совсем не плохо, однако помимо пользы страх оказывает на нас некоторое негативное влияние:</p>
<p>• страх заставляет нас заблаговременно и тщательно обдумывать, к чему может привести то или иное действие;</p>
<p>• страх заставляет нас меньше общаться;</p>
<p>• страх заставляет нас пугаться отзывов о нашей работе;</p>
<p>• страх делает нас раздражительными.</p>
<p>Ничего из этого нельзя назвать полезным для процесса программирования, особенно если вы работаете над сложной задачей. Итак, перед нами встает вопрос, как выйти из сложной ситуации и</p>
<p>• не пытаться предсказать будущее, а немедленно приступить к практическому изучению проблемы;</p>
<p>• не отгораживаться от остального мира, а повысить уровень коммуникации;</p>
<p>• не избегать откликов, а, напротив, установить надежную обратную связь и с ее помощью тщательно контролировать результаты своих действий;</p>
<p>• (с раздражением вы должны справиться самостоятельно).</p>
<p>Сравним программирование с подъемом ведра из колодца. Ведро наполнено водой, вы вращаете рычаг, наматывая цепь на ворот и поднимая ведро наверх. Если ведро небольшое, вполне подойдет обычный, свободно вращающийся ворот. Но если ведро большое и тяжелое, вы устанете прежде, чем поднимете его. Чтобы получить возможность отдыхать между поворотами рычага, необходим храповой механизм, позволяющий фиксировать рычаг. Чем тяжелее ведро, тем чаще должны следовать зубья на шестеренке храповика.</p>
<p>Тесты в TDD – это зубья на шестеренке храповика. Заставив тест работать, мы знаем, что теперь тест работает, отныне и навеки. Мы стали на шаг ближе к завершению работы, чем были до того, как тест заработал. После этого мы заставляем работать второй тест, затем третий, четвертый и т. д. Чем сложнее проблема, стоящая перед программистом, тем меньше функциональных возможностей должен охватывать каждый тест.</p>
<p>Читатели книги <emphasis>Extreme Programming Explaine<a type="note" l:href="#n_1">[1]</a></emphasis>, должно быть, обратили внимание на разницу в тоне между экстремальным программированием (Extreme Programming, XP) и разработкой через тестирование (Test-Driven Development, TDD). В отличие от XP методика TDD не является абсолютной. XP говорит: «чтобы двигаться дальше, вы обязаны освоить это и это». TDD – менее конкретная методика. TDD предполагает наличие интервала между принятием решения и получением результатов, и предлагает инструменты управления продолжительностью этого интервала. «Что, если в течение недели я буду проектировать алгоритм на бумаге, а затем напишу код, использовав подход “сначала тесты”? Будет ли это соответствовать TDD?» Конечно, будет. Вы знаете величину интервала между принятием решения и оценкой результатов и осознанно контролируете этот интервал.</p>
<p>Большинство людей, освоивших TDD, утверждают, что их практика программирования изменилась к лучшему. <emphasis>Инфицированные тестами</emphasis> (test infected) – такое определение придумал Эрих Гамма (Erich Gamma), чтобы описать данное изменение. Освоив TDD, вы обнаруживаете, что пишете значительно больше тестов, чем раньше, и двигаетесь вперед малюсенькими шагами, которые раньше показались бы вам бессмысленными. С другой стороны, некоторые программисты, познакомившись с TDD, решают вернуться к использованию прежних практик, зарезервировав TDD для особых случаев, когда обычное программирование не приводит к желаемому прогрессу.</p>
<p>Определенно, существуют задачи, которые невозможно (по крайней мере, на текущий момент) решить только при помощи тестов. В частности, TDD не позволяет механически продемонстрировать адекватность разработанного кода с точки зрения безопасности данных и надежности выполнения параллельных операций. Безусловно, безопасность основана на коде, в котором не должно быть дефектов, однако она основана также на участии человека в процедурах защиты данных. Тонкие проблемы параллельного выполнения операций невозможно с уверенностью воспроизвести, просто запустив некоторый код.</p>
<p>Прочитав эту книгу, вы сможете:</p>
<p>• начать применять TDD;</p>
<p>• писать автоматические тесты;</p>
<p>• выполнять рефакторинг, воплощая решения по одному за раз.</p>
<p>Книга разделена на три части.</p>
<empty-line></empty-line><p><strong>Часть I. На примере денег.</strong> Пример разработки типичного прикладного кода с использованием TDD. Этот пример позаимствован мною у Уорда Каннингэма (Ward Cunningham) много лет назад, и с тех пор я неоднократно использовал его для демонстрации TDD. В нем рассматривается мультивалютная арифметика: выполнение математических операций над денежными величинами, выраженными в различных валютах. Этот пример научит вас писать тесты до тестируемого ими кода и органически развивать проект.</p>
<p><strong>Часть II. На примере xUnit.</strong> Пример тестирования более сложной логики, использующей механизм рефлексии и исключения. В примере рассматривается разработка инфраструктуры автоматического тестирования. Этот пример познакомит вас также с архитектурой xUnit, которая лежит в основе множества инструментов тестирования. Во втором примере вы научитесь двигаться вперед еще меньшими шажками, а также разрабатывать систему с использованием механизмов самой этой системы.</p>
<p><strong>Часть III. Шаблоны разработки через тестирование.</strong> Здесь рассматриваются шаблоны, которые помогут найти ответы на множество вопросов, в частности: какие тесты писать и как их писать с использованием xUnit. Кроме того, здесь вы найдете описание некоторых избранных шаблонов проектирования и рефакторинга, использовавшихся при создании примеров для данной книги.</p>
<empty-line></empty-line><p>Я написал примеры так, будто мы с вами принимаем участие в сеансе парного программирования. Если перед прогулкой вы предпочитаете прежде посмотреть на карту, можете сначала ознакомиться с шаблонами в третьей части книги, а затем рассматривать примеры как их иллюстрацию. Если вы предпочитаете сначала погулять, а потом посмотреть на карте, где побывали, тогда сначала прочитайте первые две части с примерами и обращайтесь к третьей части за справками по мере необходимости. Некоторые из рецензентов данной книги, отмечали, что примеры усваиваются лучше, если во время чтения запустить среду разработки, набирать код и запускать тесты.</p>
<p>Касательно примеров хочу отметить следующее. Оба примера, мультивалютные вычисления и инфраструктура тестирования, могут показаться чрезвычайно простыми. Существуют более сложные, дефектные и уродливые решения этих же самых задач (мне лично неоднократно приходилось сталкиваться с подобными решениями). Чтобы сделать книгу более похожей на реальность, я мог бы продемонстрировать одно из таких решений. Однако моя и, я надеюсь, ваша цель – написать чистый код, который работает. Прежде чем пенять на излишнюю простоту примеров, на несколько секунд представьте себе мир программирования, в котором весь код выглядит также чисто и понятно, в котором нет слишком сложных решений, только проблемы, которые кажутся слишком сложными лишь с первого взгляда. Сложные проблемы нуждаются в тщательном обдумывании. TDD поможет добиться этого.</p>
</section><section><title><p>Благодарности</p>
</title><section><p>Спасибо всем, кто с необычайным усердием и самоотверженностью просматривал рукопись данной книги. Я беру на себя всю ответственность за представленный в книге материал, однако без посторонней помощи данная книга была бы куда менее читабельной и менее полезной. Перечислю всех, кто помогал мне, в произвольном порядке: Стив Фриман (Steve Freeman), Франк Вестфал (Frank Westphall), Рон Джеффриз (Ron Jeffries), Дирк Кёниг (Dirk Koning), Эдвард Хейят (Edward Heiatt), Таммо Фриис (Tammo Freese), Джим Ньюкирк (Jim Newkirk), Йоханнес Линк (Johannes Link), Манфред Ланж (Manfred Lange), Стив Хайес (Steve Hayes), Алан Френсис (Alan Francis), Джонатан Расмуссон (Jonathan Rasmusson), Шейн Клаусон (Shane Clauson), Саймон Крэйз (Simon Crase), Кай Пентекост (Kay Pantecost), Мюррей Бишоп (Murrey Bishop), Райан Кинг (Ryan King), Билл Уэйк (Bill Wake), Эдмунд Швепп (Edmund Schweppe), Кевин Лауренс (Kevin Lawrence), Джон Картер (John Carter), Флип (Phlip), Петер Хансен (Peter Hansen), Бен Шрёдер (Ben Schroeder), Алекс Чаффи (Alex Chaffee), Петер ван Руйен (Peter van Rooijen), Рик Кавала (Rick Kawala), Марк ван Хамерсвельд (Mark van Hamersveld), Дуг Шварц (Doug Swartz), Лорен Боссави (Laurent Bossavit), Илья Преуз (Ilia Preuz), Дэниэл Ле Берре (Daniel Le Berre), Франк Карвер (Frank Carver), Майк Кларк (Mike Clark), Кристиан Пекелер (Christian Pekeler), Карл Скотланд (Karl Scotland), Карл Манастер (Carl Manaster), Дж. Б. Рэйнсбергер (J.B. Rainsberger), Петер Линдберг (Peter Lindberg), Дарач Эннис (Darach Ennis), Кайл Кордес (Kyle Cordes), Джастин Сампсон (Justin Sampson), Патрик Логан (Patrik Logan), Даррен Хоббс (Darren Hobbs), Аарон Сансоне (Aaron Sansone), Сайвер Энстад (Syver Enstad), Шинобу Каваи (Shinobu Kawai), Эрик Мид (Erik Meade), Патрик Логан (Patrik Logan), Дан Росторн (Dan Rawsthorne), Билл Рутисер (Bill Rutiser), Эрик Хэрман (Eric Herman), Пол Чишолм (Paul Chisholm), Аэзим Джалис (Asim Jalis), Айвэн Мур (Ivan Moor), Леви Первис (Levi Purvis), Рик Магридж (Rick Mugridge), Энтони Адаши (Antony Adachi), Найджел Торн (Nigel Thorne), Джон Блей (John Bley), Кари Хойджарви (Kari Hoijarvi), Мануэль Амаго (Manuel Amago), Каору Хосокава (Kaouru Hosokawa), Пэт Эйлер (Pat Eyler), Росс Шоу (Ross Shaw), Сэм Джэнтл (Sam Gentle), Джин Райотт (Jean Rajotte), Филип Антрас (Phillipe Antras) и Джейме Нино (Jaime Nino).</p>
<empty-line></empty-line><p>Я хотел бы выразить свою признательность всем программистам, с которыми разрабатывал код в стиле «сначала тесты». Спасибо вам за терпение и внимание к идее, которая звучала полным сумасшествием, в особенности в самом начале развития TDD. Благодаря вам я научился значительно большему, чем если бы действовал самостоятельно. Мое обучение было наиболее успешным, когда я сотрудничал с Массимо Арнольди (Massimo Arnoldi), Ральфом Битти (Ralph Beatti), Роном Джеффрисом (Ron Jeffries), Мартином Фаулером (Martin Fowler) и (безусловно, не в последнюю очередь) Эрихом Гаммой (Erich Gamma), однако я хотел бы отметить, что помимо этих людей были и другие, благодаря которым я тоже научился очень многому.</p>
<p>Я хотел бы поблагодарить Мартина Фаулера (Martin Fowler) за помощь с FrameMaker. Этот человек должен быть самым высокооплачиваемым на планете специалистом в области подготовки текста к печати (к счастью, он не против, чтобы гонорар за эту книгу целиком достался мне).</p>
<p>Моя карьера настоящего программиста нчалась благодаря наставничеству Уорда Каннингэма и постоянному сотрудничеству с ним. Иногда я рассматриваю разработку через тестирование как попытку дать каждому программисту, работающему в произвольной среде, ощущение комфорта и душевности, которое было у нас с Уордом, когда мы вместе разрабатывали программы на Smalltalk. Не существует способа определить первоначальный источник идей, если два человека обладают одним общим мозгом. Если вы предположите, что все хорошие идеи на самом деле придумал Уорд, вы будете не далеки от истины.</p>
<p>В последнее время сформировалось клише: выражать глубочайшую признательность за те жертвы и лишения, которые вынуждена терпеть семья, один из членов которой заболел идеей написать книгу. Дело в том, что семейные жертвы и лишения так же необходимы для написания книги, как и бумага. Я выражаю свою самую глубочайшую благодарность моим детям, которые не могли приступить к завтраку, пока я не закончу очередную главу, а также моей жене, которая в течение двух месяцев была вынуждена повторять каждую свою фразу три раза.</p>
<p>Спасибо Майку Хэндерсону (Mike Henderson) за воодушевление, а также Марси Барнс (Marcy Barns) за то, что она пришла на помощь в трудную минуту.</p>
<p>Наконец, спасибо неизвестному автору книги, которую я прочитал в 12-летнем возрасте. В той книге было предложено сравнивать две ленты: с реальными результатами и ожидаемыми, и дорабатывать программу, пока реальные результаты не совпадут с ожидаемыми. Спасибо, спасибо, спасибо.</p>
<subtitle><emphasis><strong>От издательства</strong></emphasis></subtitle><p>Ваши замечания, предложения, вопросы отправляйте по адресу электронной почты <emphasis>comp@piter.com</emphasis> (издательство «Питер», компьютерная редакция).</p>
<p>Мы будем рады узнать ваше мнение!</p>
<p>На веб-сайте издательства <emphasis>http://www.piter.com</emphasis> вы найдете подробную информацию о наших книгах.</p>
</section></section><section><title><p>Введение</p>
</title><p>Однажды рано утром в пятницу к Уорду Каннингэму зашел босс и представил его Питеру, перспективному заказчику системы WyCash. Эта система предназначалась для управления портфелем облигаций, ее разработкой и продажей занималась компания Уорда. «Возможности вашей системы впечатляют, – сказал Питер. – Но вот в чем проблема: я собираюсь открыть новый фонд облигаций. Как я понял, ваша система поддерживает облигации, номинированные только в долларах США. Мне же понадобится система, поддерживающая разные валюты». Босс повернулся к Уорду и спросил: «Мы сможем это сделать?»</p>
<p>Вот он, кошмарный сценарий для любого разработчика. Все шло хорошо, пока события развивались по намеченному плану, и вдруг все меняется. Надо сказать, это было кошмаром не только для Уорда – босс, съевший собаку на управлении программными проектами, тоже не знал, что ответить.</p>
<p>Система WyCash была разработана небольшой командой программистов за пару лет. Она позволяла работать с большинством ценных бумаг с фиксированным доходом, имеющих хождение на американском рынке. Более того, она поддерживала некоторые редкие инструменты рынка ценных бумаг, например гарантированные инвестиционные контракты (Guaranteed Investment Contracts), и этим выгодно отличалась от конкурентов.</p>
<p>В основу разработки WyCash легли объектно-ориентированные технологии, также была использована объектная база данных. Базовой абстракцией системы был класс Dollar, класс, который отвечал за вычисления и форматирование результатов. В самом начале работы над системой его разработку поручили отдельной группе хороших программистов.</p>
<p>В течение последних шести месяцев Уорд и остальные члены команды постепенно уменьшали количество обязанностей класса Dollar. Оказалось, что числовые классы языка Smalltalk вполне подошли для реализации вычислений, а для округления до трех десятичных знаков был написан специальный код. Результаты вычислений становились все точнее и точнее, и в конце концов сложные алгоритмы тестирования, выполнявшие сравнение величин с учетом погрешности, были заменены простым сравнением реального и ожидаемого результатов.</p>
<p>За форматирование результатов в действительности отвечали классы пользовательского интерфейса, а не класс Dollar. Так как соответствующие тесты были написаны на уровне этих классов, в частности для подсистемы отчетов<a type="note" l:href="#n_2">[2]</a>, поэтому предполагаемые изменения не должны были их коснуться. В результате, спустя шесть месяцев, у объекта Dollar осталось не так уж много обязанностей…</p>
<p>Один из наиболее сложных алгоритмов, вычисление средневзвешенных величин, также постепенно менялся. Вначале существовало много различных реализаций этого алгоритма, разбросанных по всему коду. Однако позже, с появлением подсистемы отчетов, стало очевидно, что существует только одно место, где этот алгоритм должен быть реализован, – класс AveragedColumn. Именно этим классом и занялся Уорд.</p>
<p>Если бы удалось внедрить в этот алгоритм поддержку работы с несколькими валютами, система в целом смогла бы стать «мультивалютной». Центральная часть алгоритма отвечала бы за хранение количества денег «в столбце». При этом алгоритм должен быть достаточно абстрактным для вычисления средневзвешенных величин любых объектов, которые поддерживали арифметические операции. К примеру, с его помощью можно было бы вычислять средневзвешенное календарных дат.</p>
<p>Выходные прошли как обычно – за отдыхом, а в понедельник утром босс поинтересовался: «Ну как, мы сможем это сделать?» – «Дайте мне еще день, и я скажу точно», – ответил Уорд.</p>
<p>В вычислении средневзвешенной величины объект Dollar как бы являлся переменной. В случае наличия нескольких валют потребовалось бы по одной переменной на каждый тип валюты, нечто вроде многочлена. Только вместо 3x2 и 4y3 – 15 USD и 20 °CHF<a type="note" l:href="#n_3">[3]</a>.</p>
<p>Быстрый эксперимент показал, что при вычислениях можно работать не с объектом Dollar (доллар), а с более общим объектом – Currency (валюта). При этом, если выполнялась операция над двумя различными валютами, значение следовало возвращать в виде объекта PolyCurrency (мультивалютный). Сложность заключалась в том, чтобы добавить новую функциональность, не сломав при этом то, что уже работает. А что, если просто прогнать тесты?</p>
<p>После добавления к классу Currency нескольких (пока нереализованных) операций большинство тестов все еще успешно выполнялось; к концу дня проходили все тесты. Уорд интегрировал новый код в текущую версию и пошел к боссу. «Мы сможем это сделать», – уверенно сказал он.</p>
<p>Давайте задумаемся над этой историей. Через пару дней потенциальный рынок для системы WyCash увеличился в несколько раз, соответственно подскочила ее ценность. Важно, что возможность создать значительную бизнес-ценность за такое короткое время не была случайной. Свою роль сыграли следующие факторы:</p>
<p>• Метод – Уорду и команде разработки WyCash потребовался опыт в пошаговом наращивании проектных возможностей системы, с хорошо отработанным механизмом внесения изменений.</p>
<p>• Мотив – Уорду и его команде было необходимо четкое представление о значимости поддержки мультивалютности в WyCash, а также потребовалась смелость взяться за такую на первый взгляд безнадежную задачу.</p>
<p>• Возможность – сочетание всеохватывающей, продуманной системы тестов и хорошо структурированной программы; язык программирования, обеспечивающий локализацию проектных решений и тем самым упрощающий идентификацию ошибок.</p>
<p>Мотив – это то, чем вы не можете управлять; сложно сказать, когда он у вас появится и заставит заняться техническим творчеством для решения бизнес-задач. Метод и возможность, с другой стороны, находятся под вашим полным контролем. Уорд и его команда создали метод и возможность благодаря таланту, опыту и дисциплине. Значит ли это, что, если вы не входите в десятку лучших разработчиков планеты и у вас нет приличного счета в банке (настолько приличного, чтобы попросить босса погулять, пока вы занимаетесь делом), такие подвиги не для вас?</p>
<p>Нет, вовсе нет. Всегда можно развернуть проект так, чтобы работа над ним стала творческой и интересной, даже если вы обычный разработчик и прогибаетесь под обстоятельства, когда приходится туго. Разработка через тестирование (Test-Driven Development, TDD) – это набор способов, ведущих к простым программным решениям, которые может применять любой разработчик, а также тестов, придающих уверенность в работе. Если вы гений, эти способы вам не нужны. Если вы тугодум – они вам не помогут. Для всех остальных, кто находится между этими крайностями, следование двум простым правилам поможет работать намного эффективнее:</p>
<p>• перед тем как писать любой фрагмент кода, создайте автоматизированный тест, который поначалу будет терпеть неудачу;</p>
<p>• устраните дублирование.</p>
<p>Как конкретно следовать этим правилам, какие существуют в данной области нюансы и какова область применимости этих способов – все это составляет тему книги, которую вы сейчас читаете. Вначале мы рассмотрим объект, созданный Уордом в момент вдохновения, – мультивалютные деньги (multi-currency money).</p>
</section><section><title><p>Часть I</p>
<p>На примере денег</p>
</title><section><p>Мы займемся реализацией примера, разрабатывая код полностью на основе тестирования (кроме случаев, когда в учебных целях будут допускаться преднамеренные ошибки). Моя цель – дать вам почувствовать ритм разработки через тестирование (TDD). Кратко можно сказать, что TDD заключается в следующем:</p>
<p>• Быстро создать новый тест.</p>
<p>• Запустить все тесты и убедиться, что новый тест терпит неудачу.</p>
<p>• Внести небольшие изменения.</p>
<p>• Снова запустить все тесты и убедиться, что на этот раз все тесты выполнились успешно.</p>
<p>• Провести рефакторинг для устранения дублирования.</p>
<p>Кроме того, придется найти ответы на следующие вопросы:</p>
<p>• Как добиться того, чтобы каждый тест охватывал небольшое приращение функциональности?</p>
<p>• Как и за счет каких небольших и, наверное, неуклюжих изменений обеспечить успешное прохождение новых тестов?</p>
<p>• Как часто следует запускать тесты?</p>
<p>• Из какого количества микроскопических шагов должен состоять рефакторинг?</p>
</section><section><title><p>1. Мультивалютные деньги</p>
</title><p>Вначале мы рассмотрим объект, созданный Уордом для системы WyCash, – мультивалютные деньги (см. «Введение»). Допустим, у нас есть отчет вроде этого.</p>
<empty-line></empty-line><image l:href="#i_001.png"></image><empty-line></empty-line><p>Добавив различные валюты, получим мультивалютный отчет.</p>
<empty-line></empty-line><image l:href="#i_002.png"></image><empty-line></empty-line><p>Также необходимо указать курсы обмена.</p>
<empty-line></empty-line><image l:href="#i_003.png"></image><empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strong>$5 * 2 = $10</strong></p>
<empty-line></empty-line><p>Что нам понадобится, чтобы сгенерировать такой отчет? Или, другими словами, какой набор успешно выполняющихся тестов сможет гарантировать, что созданный код правильно генерирует отчет? Нам понадобится:</p>
<p>• выполнять сложение величин в двух различных валютах и конвертировать результат с учетом указанного курса обмена;</p>
<p>• выполнять умножение величин в валюте (стоимость одной акции) на количество акций, результатом этой операции должна быть величина в валюте.</p>
<p>Составим список задач, который будет напоминать нам о планах, не даст запутаться и покажет, когда все будет готово. В начале работы над задачей выделим ее жирным шрифтом, <strong>вот так</strong>. Закончив работу над ней – вычеркнем, вот так. Когда придет мысль написать новый тест, добавим новую задачу в наш список.</p>
<p>Как видно из нашего списка задач, сначала мы займемся умножением. Итак, какой объект понадобится нам в первую очередь? Вопрос с подвохом. Мы начнем не с объектов, а с тестов. (Мне приходится постоянно напоминать себе об этом, поэтому я просто притворюсь, что вы так же забывчивы, как и я.)</p>
<p>Попробуем снова. Итак, какой тест нужен нам в первую очередь? Если исходить из списка задач, первый тест представляется довольно сложным. Попробуем начать с малого – умножение, – сложно ли его реализовать? Займемся им для начала.</p>
<p>Когда мы пишем тест, мы воображаем, что у нашей операции идеальный интерфейс. Попробуем представить, как будет выглядеть операция снаружи. Конечно, наши представления не всегда будут находить воплощение, но в любом случае стоит начать с наилучшего возможного программного интерфейса (API) и при необходимости вернуться назад, чем сразу делать вещи сложными, уродливыми и «реалистичными».</p>
<p>Простой пример умножения<a type="note" l:href="#n_4">[4]</a>:</p>
<empty-line></empty-line><p>public void testMultiplication() {</p>
<p>Dollar five = new Dollar(5);</p>
<p>five.times(2);</p>
<p>assertEquals(10, five.amount);</p>
<p>}</p>
<empty-line></empty-line><p>(Знаю, знаю: публичные поля, побочные эффекты, целые числа для денежных величин и все такое. Маленькие шаги – помните? Мы отметим, что где-то есть душок<a type="note" l:href="#n_5">[5]</a>, и продолжим дальше. У нас есть тест, который не выполняется, и мы хотим как можно скорее увидеть зеленую полоску<a type="note" l:href="#n_6">[6]</a>.)</p>
<empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strong>$5 * 2 = $10</strong></p>
<p>Сделать переменную amount закрытым членом класса</p>
<p>Побочные эффекты в классе Dollar?</p>
<p>Округление денежных величин?</p>
<empty-line></empty-line><p>Тест, который мы только что создали, даже не компилируется, но это легко исправить. (О том, когда и как создаются тесты, я расскажу позже – когда мы будем подробнее говорить о среде тестирования, JUnit.) Как проще всего заставить тест компилироваться (пусть он пока и будет терпеть неудачу)? У нас четыре ошибки компиляции:</p>
<p>• нет класса Dollar;</p>
<p>• нет конструктора;</p>
<p>• нет метода times(int);</p>
<p>• нет поля (переменной) amount.</p>
<p>Устраним их одну за другой. (Я всегда ищу некоторую численную меру прогресса.) От одной ошибки мы избавимся, определив класс Dollar:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>class Dollar</p>
<empty-line></empty-line><p>Одной ошибкой меньше, осталось еще три. Теперь нам понадобится конструктор, причем совершенно необязательно, чтобы он что-то делал – лишь бы компилировался.</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>Dollar(int amount) {</p>
<p>}</p>
<empty-line></empty-line><p>Осталось две ошибки. Необходимо создать заготовку метода times(). Снова мы выполним минимум работы, только чтобы заставить тест компилироваться:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>void times(int multiplier) {</p>
<p>}</p>
<empty-line></empty-line><p>Теперь осталась только одна ошибка. Чтобы от нее избавиться, нужно создать поле (переменную) amount:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>int amount;</p>
<empty-line></empty-line><p>Отлично! Теперь можно запустить тест и убедиться, что он не выполняется: ситуация продемонстрирована на рис. 1.1.</p>
<p>Загорается зловещий красный индикатор. Фреймворк тестирования (JUnit в нашем случае) выполнил небольшой фрагмент кода, с которого мы начали, и выяснил, что вместо ожидаемого результата «10» получился «0». Ужасно…</p>
<empty-line></empty-line><image l:href="#i_004.jpg"></image><p><strong>Рис. 1.1.</strong> Прогресс! Тест терпит неудачу</p>
<empty-line></empty-line><p>Вовсе нет! Неудача – это тоже прогресс. Теперь у нас есть конкретная мера неудачи. Это лучше, чем просто догадываться, что у нас что-то не так. Наша задача «реализовать мультивалютность» превратилась в «заставить работать этот тест, а потом заставить работать все остальные тесты». Так намного проще и намного меньше поводов для страха. Мы заставим этот тест работать.</p>
<p>Возможно, вам это не понравится, но сейчас наша цель не получить идеальное решение, а заставить тест выполняться. Мы принесем свою жертву на алтарь истины и совершенства чуть позже.</p>
<p>Наименьшее изменение, которое заставит тест успешно выполняться, представляется мне таким:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>int amount = 10;</p>
<empty-line></empty-line><p>Рисунок 1.2 показывает результат повторного запуска теста. Теперь мы видим ту самую зеленую полоску, воспетую в поэмах и прославленную в веках.</p>
<p>Вот оно, счастье! Но радоваться рано, ведь цикл еще не завершен. Уж слишком мал набор входных данных, которые заставят такую странно попахивающую и наивную реализацию работать правильно. Перед тем как двигаться дальше, немного поразмышляем.</p>
<empty-line></empty-line><image l:href="#i_005.jpg"></image><p><strong>Рис. 1.2.</strong> Тест успешно выполняется</p>
<empty-line></empty-line><p>Вспомним, полный цикл TDD состоит из следующих этапов:</p>
<p>1. Добавить небольшой тест.</p>
<p>2. Запустить все тесты и убедиться, что новый тест терпит неудачу.</p>
<p>3. Внести небольшое изменение.</p>
<p>4. Снова запустить тесты и убедиться, что все они успешно выполняются.</p>
<p>5. Устранить дублирование с помощью рефакторинга.</p>
<cite><p><strong>ЗАВИСИМОСТЬ И ДУБЛИРОВАНИЕ</strong></p>
<p>Стив Фримен (Steve Freeman) указал, что проблема с тестами и кодом заключается не в дублировании (на которое я еще не указал вам, но сделаю это, как только закончится отступление). Проблема заключается в зависимости между кодом и тестами – вы не можете изменить одно, не изменив другого. Наша цель – иметь возможность писать новые осмысленные тесты, не меняя при этом код, что невозможно при нашей текущей реализации.</p>
<p>Зависимость является ключевой проблемой разработки программного обеспечения. Если фрагменты SQL, зависящие от производителя используемой базы данных, разбросаны по всему коду и вы хотите поменять производителя, то непременно окажется, что код зависит от этого производителя. Вы не сможете поменять производителя базы данных и при этом не изменить код.</p>
<p>Зависимость является проблемой, а дублирование – ее симптомом. Чаще всего дублирование проявляется в виде дублирования логики – одно и то же выражение появляется в различных частях кода. Объекты – отличный способ абстрагирования, позволяющий избежать данного вида дублирования.</p>
<p>В отличие от большинства проблем в реальной жизни, где устранение симптомов приводит только к тому, что проблема проявляется в худшей форме где-то еще, устранение дублирования в программах устраняет и зависимость. Именно поэтому существует второе правило TDD. Устраняя дублирование перед тем, как заняться следующим тестом, мы максимизируем наши шансы сделать его успешным, внеся всего одно изменение.</p>
</cite><p>Мы выполнили первые четыре пункта цикла, и все готово к устранению дублирования. Но где же оно? Обычно мы замечаем дублирование в нескольких разных фрагментах кода, однако в нашем случае – друг друга дублируют тест и тестируемый код. Еще не видите? Как насчет того, чтобы написать так:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>int amount = 5 * 2;</p>
<empty-line></empty-line><p>Теперь ясно, откуда мы взяли число 10. Видимо, мы в уме произвели умножение, причем так быстро, что даже не заметили. Произведение «5 умножить на 2» присутствует как в тесте, так и в тестируемом коде. Только изначально в коде оно было представлено в виде константы 10. Сейчас же 5 и 2 отделены друг от друга, и мы должны безжалостно устранить дублирование, перед тем как двинуться дальше. Такие вот правила.</p>
<p>Действия, с помощью которого мы устранили бы 5 и 2 за один шаг, не существует. Но что, если переместить установку поля (переменной) amount в метод times()?</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>int amount;</p>
<empty-line></empty-line><p>void times(int multiplier) {</p>
<p>amount= 5 * 2;</p>
<p>}</p>
<empty-line></empty-line><p>Тест все еще успешно выполняется, и индикатор остался зеленым. Успех нам пока сопутствует.</p>
<p>Такие шаги кажутся вам слишком мелкими? Помните, TDD не обязывает двигаться только микроскопическими шагами, речь идет о способности совершать эти микроскопические шаги. Буду ли я программировать день за днем такими маленькими шагами? Нет. Но когда дела совсем плохи, я рад возможности выполнять хоть такие шаги. Примените микроскопические шаги к любому собственному примеру. Если вы сможете продвигаться маленькими шагами, вы сумеете делать шаги более крупного и подходящего размера. Если же вы способны делать только огромные шаги, вы никогда не распознаете ситуацию, в которой более уместны меньшие шаги.</p>
<p>Оставим рассуждения. На чем мы остановились? Ну да, мы избавлялись от дублирования между кодом теста и рабочим кодом. Где мы можем взять 5? Это значение передавалось конструктору, поэтому его можно сохранить в переменной amount:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>Dollar(int amount) {</p>
<p>this.amount = amount;</p>
<p>}</p>
<empty-line></empty-line><p>и использовать в методе times():</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>void times(int multiplier) {</p>
<p>amount = amount * 2;</p>
<p>}</p>
<empty-line></empty-line><p>Число 2 передается в параметре multiplier, поэтому подставим параметр вместо константы:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>void times(int multiplier) {</p>
<p>amount= amount * multiplier;</p>
<p>}</p>
<empty-line></empty-line><p>Чтобы продемонстрировать, как хорошо мы знаем синтаксис языка Java, используем оператор *= (который, кстати, уменьшает дублирование):</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>void times(int multiplier) {</p>
<p>amount *= multiplier;</p>
<p>}</p>
<empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p>Сделать переменную amount закрытым членом класса</p>
<p>Побочные эффекты в классе Dollar?</p>
<p>Округление денежных величин?</p>
<empty-line></empty-line><p>Теперь можно пометить первый тест как завершенный. Далее мы позаботимся о тех странных побочных эффектах; но сначала давайте подведем итоги. Мы сделали следующее:</p>
<p>• создали список тестов, которые – мы знаем – нам понадобятся;</p>
<p>• с помощью фрагмента кода описали, какой мы хотим видеть нашу операцию;</p>
<p>• временно проигнорировали особенности среды тестирования JUnit;</p>
<p>• заставили тесты компилироваться, написав соответствующие заготовки;</p>
<p>• заставили тесты работать, использовав сомнительные приемы;</p>
<p>• слегка улучшили работающий код, заменив константы переменными;</p>
<p>• добавили пункты в список задач, вместо того чтобы заняться всеми этими задачами сразу.</p>
</section><section><title><p>2. Вырождающиеся объекты</p>
</title><p>Обычный цикл разработки на основе тестирования состоит из следующих этапов:</p>
<p>1. Напишите тест. Представьте, как будет реализована в коде воображаемая вами операция. Продумав ее интерфейс, опишите все элементы, которые, как вам кажется, понадобятся.</p>
<p>2. Заставьте тест работать. Первоочередная задача – получить зеленую полоску. Если напрашивается простое и элегантное решение, используйте его. Если же на реализацию такого решения потребуется время, отложите его. Просто отметьте, что к нему нужно вернуться, когда будет решена основная задача – быстро получить зеленый индикатор. Такой подход довольно неприятен для опытных разработчиков (в эстетическом плане), ведь они следуют только правилам хорошей разработки. Но зеленая полоска прощает все грехи, правда, всего лишь на мгновение.</p>
<p>3. Улучшите решение. Теперь, когда система работает, избавьтесь от прошлых огрехов и вернитесь на путь истинной разработки. Устраните дублирование, которое вы внесли, и быстро сделайте так, чтобы полоска снова стала зеленой.</p>
<p>Наша цель – <emphasis>чистый код, который работает</emphasis> (отдельное спасибо Рону Джеффризу за этот слоган). Иногда такой код не по силам даже самым лучшим программистам, и почти всегда он не достижим для большинства программистов (вроде меня). Разделяй и властвуй, приятель, – в этом весь смысл! Сначала мы напишем код, «который работает», после чего создадим «чистый код». Такой подход противоречит модели разработки на основе архитектуры, в которой вы сначала пишете «чистый код», а потом мучаетесь, пытаясь интегрировать в проект код, «который работает».</p>
<empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p>Сделать переменную amount закрытым членом класса</p>
<p><strong>Побочные эффекты в классе Dollar?</strong></p>
<p>Округление денежных величин?</p>
<empty-line></empty-line><p>Мы получили один рабочий тест, но в процессе заметили нечто странное: при выполнении операции с объектом Dollar изменяется сам объект. Хотелось бы написать так:</p>
<empty-line></empty-line><p>public void testMultiplication() {</p>
<p>Dollar five = new Dollar(5);</p>
<p>five.times(2);</p>
<p>assertEquals(10, five.amount);</p>
<p>five.times(3);</p>
<p>assertEquals(15, five.amount);</p>
<p>}</p>
<empty-line></empty-line><p>Я не могу представить простого способа, который заставит этот тест выполняться. После первого вызова метода times() пять уже больше не пять – на самом деле это уже десять. Если же метод times() будет возвращать новый объект, тогда мы сможем умножать наши исходные пять баксов хоть целый день, и они не изменятся. Для реализации этой идеи нам потребуется изменить интерфейс объекта Dollar и, соответственно, изменить тест. Это нормально, ведь вполне возможно, что наши догадки о правильном интерфейсе не более правдоподобны, чем догадки о правильной реализации.</p>
<empty-line></empty-line><p>public void testMultiplication() {</p>
<p>Dollar five = new Dollar(5);</p>
<p>Dollar product = five.times(2);</p>
<p>assertEquals(10, product.amount);</p>
<p>product = five.times(3);</p>
<p>assertEquals(15, product.amount);</p>
<p>}</p>
<empty-line></empty-line><p>Новый тест не будет компилироваться, пока мы не изменим объявление метода Dollar.times():</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>Dollar times(int multiplier) {</p>
<p>amount *= multiplier;</p>
<p>return null;</p>
<p>}</p>
<empty-line></empty-line><p>Теперь тест компилируется, но не работает. И это тоже прогресс! Чтобы заставить его работать, придется возвращать новый объект Dollar с правильным значением:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>Dollar times(int multiplier) {</p>
<p>return new Dollar(amount * multiplier);</p>
<p>}</p>
<p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p>Сделать переменную amount закрытым членом класса</p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<empty-line></empty-line><p>В главе 1, когда мы заставляли тест работать, мы начинали с заготовки и постепенно улучшали код, пока он не стал полноценным. Теперь мы написали сразу правильную реализацию и молились, пока выполнялись тесты (довольно короткие молитвы, честно говоря – выполнение тестов занимает миллисекунды). Нам повезло, тесты выполнились успешно, и мы вычеркнули еще один пункт.</p>
<p>Мне известны три способа быстрого получения зеленого индикатора. Вот первые два:</p>
<p>• подделать реализацию, иначе говоря, создать заглушку, возвращающую константу, и постепенно заменять константы переменными до тех пор, пока не получится настоящий код;</p>
<p>• использовать очевидную реализацию – просто написать сразу настоящую реализацию.</p>
<p>Используя TDD на практике, я периодически переключаюсь между двумя этими способами. Когда все идет гладко и я знаю, что делать, – я просто создаю одну за другой очевидные реализации (каждый раз запуская тесты, чтобы убедиться, что решение, очевидное для меня, также очевидно для компьютера). Как только я натыкаюсь на красный индикатор, я возвращаюсь к методике «поддельная реализация», после чего провожу рефакторинг. Когда уверенность возвращается, я снова использую методику «очевидная реализация».</p>
<p>Есть еще одна, третья методика, «Триангуляция» (Triangulation), которую мы рассмотрим в главе 3. Подведем итоги. Мы выполнили следующее:</p>
<p>• сформулировали дефект проектирования (побочный эффект) в виде теста, который потерпел неудачу (из-за дефекта);</p>
<p>• создали заглушку, обеспечившую быструю компиляцию кода;</p>
<p>• заставили тест успешно выполняться, написав вроде бы правильный код.</p>
<p>Преобразование чувства (например, отвращения, вызываемого побочными эффектами) в тест (например, двукратное перемножение одного и того же объекта Dollar) – обычная практика в TDD. Чем дольше я этим занимаюсь, тем легче эстетические суждения переводятся в тесты. В результате мои рассуждения о проектировании становятся более интересными. Сначала мы обсуждаем, должна ли система работать <emphasis>так</emphasis> или <emphasis>по-другому</emphasis>. После определения правильного поведения системы можно поговорить о наилучшем способе его реализации. Можно сколь угодно долго рассуждать об истине и совершенстве за пивом, но раз мы занимаемся программированием, у нас есть возможность оставить пустые разговоры и перейти к конкретике.</p>
</section><section><title><p>3. Равенство для всех</p>
</title><p>Если у меня есть целое число и я прибавляю к нему 1, то не предполагаю, что изменится исходное число, – в результате я ожидаю получить новое число. Объекты же обычно ведут себя иначе. К примеру, если у меня есть контракт и я добавлю 1 к его сумме, это будет означать, что сумма контракта должна измениться (да, несомненно, это пример для обсуждения многих интересных законов бизнеса, которые мы здесь рассматривать <emphasis>не</emphasis> будем).</p>
<p>Мы можем использовать объекты в качестве значений, так же как используем наш объект Dollar. Соответствующий шаблон называется «Объект-значение» (Value Object). Одно из ограничений этого шаблона заключается в том, что значения атрибутов объекта устанавливаются в конструкторе и никогда в дальнейшем не изменяются.</p>
<p>Значительное преимущество использования шаблона «Объект-значение» состоит в том, что не нужно беспокоиться о проблеме наложения имен (aliasing). Скажем, у меня есть объект Check, представляющий собой чек, и я устанавливаю его сумму – $5, а затем присваиваю эти же $5 сумме другого объекта Check. Одна из самых неприятных проблем на моей памяти заключалась в том, что изменение суммы в первом объекте может приводить к непреднамеренному изменению суммы во втором. Это и есть проблема наложения имен.</p>
<p>Используя объекты-значения, не нужно беспокоиться о наложении имен. Если у меня есть пять долларов ($5), они всегда гарантированно будут оставаться именно пятью долларами ($5). Если вдруг кому-то понадобятся $7, придется создать новый объект.</p>
<empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p>Сделать <strikethrough>переменную</strikethrough> amount закрытым членом класса</p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p>equals()</p>
<empty-line></empty-line><p>Одно из следствий использования шаблона «Объект-значение» заключается в том, что все операции должны возвращать результаты в виде новых объектов, как было покзано в главе 2. Другое следствие заключается в том, что объекты-значения должны реализовывать метод equals(), операцию проверки равенства, потому что одни $5 ничем не отличаются от других.</p>
<empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p>Сделать <strikethrough>переменную</strikethrough> «amount» закрытым членом</p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strong>equals()</strong></p>
<p>hashCode()</p>
<empty-line></empty-line><p>Кроме того, если использовать Dollar в качестве ключа хеш-таблицы, вместе с equals() придется реализовать и hashCode(). Добавим этот пункт в список задач и вернемся к нему, когда это будет необходимо.</p>
<p>Вы ведь не собираетесь немедленно приступать к реализации метода equals()? Отлично, я тоже об этом не думаю. Ударив себя линейкой по руке, я стал размышлять над тем, как протестировать равенство. Для начала $5 должны быть равны $5:</p>
<empty-line></empty-line><p>public void testEquality() {</p>
<p>assertTrue(new Dollar(5). equals(new Dollar(5)));</p>
<p>}</p>
<empty-line></empty-line><p>Полоска окрасилась красным. Поддельная реализация могла бы просто вернуть значение true:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>public boolean equals(Object object) {</p>
<p>return true;</p>
<p>}</p>
<empty-line></empty-line><p>Конечно, мы с вами знаем, что на самом деле true – это «5 == 5», что, в свою очередь, означает «amount == 5», что соответствует «amount == dollar.amount». Но если бы я сразу проследил все эти шаги, я не смог бы продемонстрировать третью и наиболее консервативную методику реализации – триангуляцию.</p>
<p>Если две станции слежения, находящиеся на известном расстоянии друг от друга, смогут измерить азимут некоторого источника радиосигнала (взять пеленг), этого вполне достаточно, чтобы вычислить местоположение источника радиосигнала (как вы помните из курса тригонометрии, в отличие от меня). Это вычисление и называется триангуляцией.</p>
<p>По аналогии, используя метод триангуляции, мы обобщаем код только в том случае, когда у нас два примера или больше. При этом мы ненадолго игнорируем дублирование между тестом и самим кодом (приложения). Когда второй пример потребует более общего решения, тогда и только тогда мы выполним обобщение.</p>
<p>Итак, для триангуляции нам понадобится второй пример. Как насчет того, чтобы проверить $5!= $6?</p>
<empty-line></empty-line><p>public void testEquality() {</p>
<p>assertTrue(new Dollar(5). equals(new Dollar(5)));</p>
<p>assertFalse(new Dollar(5). equals(new Dollar(6)));</p>
<p>}</p>
<p>Теперь необходимо обобщить равенство (equality):</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>public boolean equals(Object object) {</p>
<p>Dollar dollar = (Dollar)object;</p>
<p>return amount == dollar.amount;</p>
<p>}</p>
<empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p>Сделать <strikethrough>переменную</strikethrough> amount закрытым членом класса</p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<empty-line></empty-line><p>Мы могли бы использовать триангуляцию и для управления обобщением метода times(). Если бы у нас были примеры $5 * 2 = $10 и $5 * 3 = $15, нам не смогли бы просто возвращать константу.</p>
<p>Думаю, триангуляция – довольно интересная вещь. Я использую ее в случае, если не знаю, как выполнять рефакторинг. Если же я представляю, как устранить дублирование между кодом и тестами и создать более общее решение, я просто создаю его. С какой стати я должен создавать еще один тест, если сразу могу выполнить обобщение?</p>
<p>Однако когда когда в голову не приходит ничего умного, триангуляция дает шанс посмотреть на проблему с другой стороны. Сколько степеней свободы вы хотите поддерживать в вашем приложении (какую степень универсальности, другими словами)? Просто попробуйте ввести некоторые из них, и, возможно, ответ станет очевиднее.</p>
<empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p>Сделать <strikethrough>переменную</strikethrough> amount закрытым членом класса</p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<empty-line></empty-line><p>Итак, сейчас операция проверки равенства реализована полностью. Но как учесть сравнение со значением null и сравнение c другими объектами? Это часто используемые операции, пока они нам еще не нужны, поэтому мы просто добавим их в список задач.</p>
<p>Теперь, когда у нас есть операция проверки равенства, можно напрямую сравнивать объекты Dollar. Это позволит нам сделать переменную amount закрытой, какой и должна быть добропорядочная переменная экземпляра. Резюмируем все вышесказанное:</p>
<p>• поняли, что для использования шаблона проектирования «Объект-значение» необходимо реализовать операцию проверки равенства;</p>
<p>• создали тест для этой операции;</p>
<p>• реализовали ее простейшим способом;</p>
<p>• продолжили тестирование (вместо того, чтобы сразу приступить к рефакторингу);</p>
<p>• выполнили рефакторинг так, чтобы охватить оба теста сразу.</p>
</section><section><title><p>4. Данные должны быть закрытыми</p>
</title><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strong>Сделать переменную amount закрытым членом класса</strong></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<empty-line></empty-line><p>Теперь, когда определена операция проверки равенства, с ее помощью можно повысить наглядность тестов. По идее, метод Dollar.times() должен возвращать новый объект Dollar, величина которого равна величине исходного объекта (метод которого мы вызываем), умноженной на коэффициент. Однако наш тест не показывает этого явно:</p>
<empty-line></empty-line><p>public void testMultiplication() {</p>
<p>Dollar five = new Dollar(5);</p>
<p>Dollar product = five.times(2);</p>
<p>assertEquals(10, product.amount);</p>
<p>product = five.times(3);</p>
<p>assertEquals(15, product.amount);</p>
<p>}</p>
<empty-line></empty-line><p>Мы можем переписать первую проверку и сравнить в ней объекты Dollar:</p>
<empty-line></empty-line><p>public void testMultiplication() {</p>
<p>Dollar five = new Dollar(5);</p>
<p>Dollar product = five.times(2);</p>
<p><strong>assertEquals(new Dollar(10), product);</strong></p>
<p>product = five.times(3);</p>
<p>assertEquals(15, product.amount);</p>
<p>}</p>
<empty-line></empty-line><p>Выглядит неплохо, поэтому перепишем и вторую проверку:</p>
<empty-line></empty-line><p>public void testMultiplication() {</p>
<p>Dollar five = new Dollar(5);</p>
<p>Dollar product = five.times(2);</p>
<p>assertEquals(new Dollar(10), product);</p>
<p>product = five.times(3);</p>
<p><strong>assertEquals(new Dollar(15), product);</strong></p>
<p>}</p>
<empty-line></empty-line><p>Теперь нам не нужна вспомогательная переменная product, поэтому устраним ее:</p>
<empty-line></empty-line><p>public void testMultiplication() {</p>
<p>Dollar five= new Dollar(5);</p>
<p><strong>assertEquals(new Dollar(10), five.times(2));</strong></p>
<p><strong>assertEquals(new Dollar(15), five.times(3));</strong></p>
<p>}</p>
<empty-line></empty-line><p>Согласитесь, этот вариант теста значительно нагляднее.</p>
<p>Учтем внесенные изменения. Теперь только класс Dollar использует переменную экземпляра amount, поэтому мы можем сделать ее закрытой:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>private int amount;</p>
<p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым членом класса</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<empty-line></empty-line><p>Вычеркиваем еще один пункт из списка задач. Заметьте, мы подвергли себя риску: если тест, проверяющий равенство, не смог бы точно определить корректность операции сравнения, тогда и тест умножения не смог бы проверить, правильно ли оно работает. В TDD принято активное управление риском. Мы не гонимся за совершенством. Выражая все двумя способами – тестами и кодом, – мы надеемся уменьшить дефекты настолько, чтобы уверенно идти дальше. Время от времени наши рассуждения будут нас подводить, позволяя появляться ошибкам. Когда это случится, мы вспомним урок о том, что надо написать тест и двигаться дальше. Все остальное время мы отважно продвигаемся вперед под победно развевающейся зеленой полоской нашего индикатора (вообще-то мой индикатор не развевается, но я люблю помечтать).</p>
<empty-line></empty-line><p>Подведем итоги:</p>
<p>• использовали только что разработанную функциональность для улучшения теста;</p>
<p>• заметили, что, если одновременно два теста терпят неудачу, наши дела плохи;</p>
<p>• продолжили несмотря на риск;</p>
<p>• использовали новую функциональность тестируемого объекта для уменьшения зависимости между тестами и кодом.</p>
</section><section><title><p>5. Поговорим о франках</p>
</title><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?Округление денежных величин?</strikethrough></p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strong>5 CHF * 2 = 1 °CHF</strong></p>
<empty-line></empty-line><p>Можем ли мы приступить к реализации первого, самого интересного теста в данном списке? Мне все еще кажется, что это будет слишком большой шаг. Я не представляю себе, как можно написать этот тест за один маленький шажок. Мне кажется, что вначале необходимо создать объект наподобие Dollar, который соответствовал бы не долларам, а франкам. Пусть это будет объект с названием Franc. Для начала объект Franc может функционировать в точности как объект Dollar – если у нас будет такой объект, нам будет проще размышлять о реализации теста, связанного со смешанным сложением двух разных валют.</p>
<p>А если объект Franc работает так же, как объект Dollar, значит, мы можем просто скопировать и слегка отредактировать тест для объекта Dollar:</p>
<empty-line></empty-line><p>public void testFrancMultiplication() {</p>
<p>Franc five = new Franc(5);</p>
<p>assertEquals(new Franc(10), five.times(2));</p>
<p>assertEquals(new Franc(15), five.times(3));</p>
<p>}</p>
<empty-line></empty-line><p>(Хорошо, что в главе 4 мы упростили тест для Dollar. Благодаря этому работа по редактированию теста существенно упростилась. Похоже, в данной книге дела идут довольно гладко, однако я не могут гарантировать, что в будущем все будет так же хорошо.)</p>
<p>Теперь нам надо получить зеленую полоску. Какой способ будет самым простым? Проще всего скопировать код класса Dollar и заменить Dollar на Franc.</p>
<p>Стоп. Подождите-ка. Я уже вижу, как некоторые наиболее ярые сторонники правильных подходов начинают морщиться и плеваться. Повторное использование кода путем его дублирования через буфер обмена? Пренебрежение абстракцией? А как же все эти разговоры об основополагающих принципах ООП и чистом дизайне?</p>
<p>Если вам не по себе, глубоко вдохните через нос, досчитайте до трех и медленно выдохните через рот. Вам лучше? Теперь вспомните, что наш цикл состоит из пяти этапов. Иногда последовательное выполнение всех этапов занимает всего несколько секунд, однако в любом случае мы обязательно выполняем каждый из них:</p>
<p>1. Написать тест.</p>
<p>2. Добиться его безошибочной компиляции.</p>
<p>3. Запустить тест и убедиться, что он потерпел неудачу.</p>
<p>4. Добиться успешного выполнения теста.</p>
<p>5. Устранить дублирование.</p>
<p>На разных этапах решаются разные задачи, преследуются разные цели. То, что совершенно недопустимо для одного из этапов, может быть вполне приемлемым для другого этапа. Однако в целом методика TDD работает только в случае, если ни один из этапов не упущен. Если вы пропустите хотя бы одно звено, развалится вся цепочка.</p>
<p>Первые три фазы цикла разработки TDD должны выполняться как можно быстрее. Определяющая характеристика этих этапов – скорость. На этих этапах в жертву скорости можно принести очень многое, в том числе чистоту дизайна. Честно говоря, сейчас я несколько волнуюсь. Я только что разрешил вам забыть о принципах хорошего дизайна. Представляю, как вы приходите к своим коллегам, подчиненным и во всеуслышание объявляете: «Кент сказал, что все эти разговоры про хороший дизайн – полная ерунда!» Остановитесь. Цикл еще не закончен. Четырехногий уродец из благородного семейства пятиногих стульев вечно падает. Первые четыре шага нашего цикла не работают без пятого. Хороший дизайн в подходящее время! Сначала сделаем, чтобы код заработал, потом сделаем, чтобы код был правильным (make it run, make it right).</p>
<p>Теперь мне стало легче. Теперь я уверен, что до тех пор, пока вы не избавитесь от дублирования, вы не покажете свой код никому за исключением своего партнера по паре. На чем мы остановились? Ах, да. Забываем о принципах хорошего дизайна в угоду скорости (мы будем заниматься искуплением этого греха на протяжении нескольких следующих глав).</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>class Franc {</p>
<p>private int amount;</p>
<p>Franc(int amount) {</p>
<p>this.amount = amount;</p>
<p>}</p>
<empty-line></empty-line><p>Franc times(int multiplier) {</p>
<p>return new Franc(amount * multiplier);</p>
<p>}</p>
<empty-line></empty-line><p>public boolean equals(Object object) {</p>
<p>Franc franc = (Franc) object;</p>
<p>return amount == franc.amount;</p>
<p>}</p>
<p>}</p>
<p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strikethrough>5 CHF * 2 = 1 °CHF</strikethrough></p>
<p>Дублирование Dollar/Franc</p>
<p>Общие операции equals()</p>
<p>Общие операции times()</p>
<empty-line></empty-line><p>Чтобы запустить код, нам не потребовалось прикладывать каких-либо усилий, поэтому мы смогли «перепрыгнуть» через этап «добиться безошибочной компиляции кода» (Make it compile).</p>
<p>Зато теперь в нашем коде полно повторяющихся фрагментов. Прежде чем приступить к разработке следующего теста, мы должны избавиться от дублирования. Думаю, что следует начать с обобщения метода equals(). Однако об этом в следующей главе. На текущий момент мы можем вычеркнуть из нашего списка еще один пункт, однако вместе с этим нам придется добавить в него два дополнительных пункта.</p>
<p>В данной главе мы</p>
<p>• решили отказаться от создания слишком большого теста и вместо этого создали маленький, чтобы обеспечить быстрый прогресс;</p>
<p>• создали код теста путем бесстыдного копирования и редактирования;</p>
<p>• хуже того, добились успешного выполнения теста путем копирования и редактирования разработанного ранее кода;</p>
<p>• дали себе обещание ни в коем случае не уходить домой до тех пор, пока не устраним дублирование.</p>
</section><section><title><p>6. Равенство для всех, вторая серия</p>
</title><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strikethrough>5 CHF * 2 = 1 °CHF</strikethrough></p>
<p>Дублирование Dollar/Franc</p>
<empty-line></empty-line><p><strong>Общие операции equals()</strong></p>
<p>Общие операции times()</p>
<empty-line></empty-line><p>В книге <emphasis>Crossing to Safety</emphasis> автор Вэлленц Стегнер (Wallance Stegner) описывает рабочее место одного из персонажей. Каждый инструмент находится на предназначенном для него месте, пол чисто вымыт и подметен, повсюду превосходный порядок и чистота. Однако чтобы добиться подобного положения вещей, персонаж не делал никаких специальных подготовительных процедур. «Подготовка была делом всей его жизни. Он подготавливался, затем убирался на рабочем месте». (Конец книги заставил меня громко рассмеяться в бизнес-классе трансатлантического «Боинга-747». Так что если решите ее прочитать, читайте с осторожностью.)</p>
<p>В главе 5 мы добились успешного выполнения теста. Это значит, что требуемая функциональность реализована. Однако чтобы сделать это быстро, нам пришлось продублировать огромный объем кода. Теперь пришло время убрать за собой.</p>
<p>Мы можем сделать так, чтобы один из разработанных нами классов стал производным от другого. Я попробовал сделать это, однако понял, что в этом случае ничего не выигрываю. Вместо этого удобнее создать суперкласс, который станет базовым для обоих разработанных нами классов. Ситуация проиллюстрирована на рис. 6.1. (Я уже пробовал так поступить и пришел к выводу, что это именно то, что нужно, однако придется приложить усилия.)</p>
<empty-line></empty-line><image l:href="#i_006.png"></image><p><strong>Рис. 6.1.</strong> Общий суперкласс для двух разработанных нами классов</p>
<empty-line></empty-line><p>Для начала попробуем реализовать в базовом классе Money общий для обоих производных классов метод equals(). Начнем с малого:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>class Money</p>
<empty-line></empty-line><p>Запустим тесты – они по-прежнему выполняются. Конечно же, мы пока не сделали ничего такого, что нарушило бы выполнение наших тестов, однако в любом случае лишний раз запустить тесты не помешает. Теперь попробуем сделать класс Dollar производным от класса Money:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>class Dollar extends <strong>Money</strong> {</p>
<p>private int amount;</p>
<p>}</p>
<empty-line></empty-line><p>Работают ли тесты? Работают. Можем двигаться дальше. Перемещаем переменную amount в класс Money:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>class Money {</p>
<p>protected int <strong>amount</strong>;</p>
<p>}</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>class Dollar extends <strong>Money</strong> {</p>
<p>}</p>
<empty-line></empty-line><p>Режим видимости переменной amount потребовалось изменить: теперь вместо private используем модификатор доступа protected. В противном случае подкласс не сможет обратиться к этой переменной. (Если бы мы хотели двигаться еще медленнее, мы могли бы на первом шаге объявить переменную в классе Money, а на втором шаге удалить ее объявление из класса Dollar, однако я решил действовать смело и решительно.)</p>
<p>Теперь можно переместить код метода equals() вверх по иерархии классов, то есть в класс Money. Прежде всего мы изменим объявление временной переменной:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>public boolean equals(Object object) {</p>
<p><strong>Money</strong> dollar = (Dollar) object;</p>
<p>return amount == dollar.amount;</p>
<p>}</p>
<empty-line></empty-line><p>Все тесты по-прежнему работают. Теперь попробуем изменить приведение типа.</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>public boolean equals(Object object) {</p>
<p>Money dollar = (<strong>Money</strong>) object;</p>
<p>return amount == dollar.amount;</p>
<p>}</p>
<empty-line></empty-line><p>Чтобы исходный код получился более осмысленным, изменим имя временной переменной:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>public boolean equals(Object object) {</p>
<p>Money <strong>money</strong> = (Money) object;</p>
<p>return amount == <strong>money</strong>.amount;</p>
<p>}</p>
<empty-line></empty-line><p>Теперь переместим метод из класса Dollar в класс Money:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>public boolean equals(Object object) {</p>
<p>Money money= (Money) object;</p>
<p>return amount == money.amount;</p>
<p>}</p>
<empty-line></empty-line><p>Теперь настало время удалить метод Franc.equals(). Прежде всего мы обнаруживаем, что у нас до сих пор нет теста, проверяющего равенство двух объектов класса Franc, – когда мы, особо не раздумывая, дублировали код класса Dollar, мы нагрешили еще больше, чем думали. Поэтому, прежде чем модифицировать код, мы должны написать все необходимые тесты.</p>
<p>В ближайшем будущем, скорее всего, вам придется использовать подход TDD в отношении кода, который не сопровождается достаточным количеством тестов. В отсутствие адекватного набора тестов любой рефакторинг может привести к нарушению работоспособности кода. Иными словами, в ходе рефакторинга можно допустить ошибку, при этом все имеющиеся тесты будут выполняться как ни в чем не бывало. Ошибка может вскрыться слишком поздно, а ее устранение может стоить слишком дорого. Что же делать?</p>
<p>Прежде чем что-либо менять в коде, вы должны написать все тесты, которые кажутся вам необходимыми. Если этого не сделать, рано или поздно, выполняя рефакторинг, вы чего-нибудь поломаете. Код перестанет работать так, как должен. Вы потратите кучу времени на поиск ошибки и сформируете предубеждение против рефакторинга. Если подобный инцидент повторится, вы можете вообще перестать делать рефакторинг. Дизайн начнет деградировать. Вас уволят с работы. От вас уйдет ваша любимая собака. Вы перестанете мыться и чистить зубы. У вас начнется кариес. Чтобы сохранить зубы здоровыми, всегда сначала пишите тесты и только после этого выполняйте рефакторинг.</p>
<p>К счастью, в нашем случае написать тесты совсем несложно. Для этого достаточно скопировать и немножко отредактировать тесты для класса Dollar:</p>
<empty-line></empty-line><p>public void testEquality() {</p>
<empty-line></empty-line><p>assertTrue(new Dollar(5). equals(new Dollar(5)));</p>
<p>assertFalse(new Dollar(5). equals(new Dollar(6)));</p>
<p>assertTrue(new Franc(5). equals(new Franc(5)));</p>
<p>assertFalse(new Franc(5). equals(new Franc(6)));</p>
<p>}</p>
<empty-line></empty-line><p>Снова дублирование. Целых две строчки! Этот грех нам тоже придется искупить. Но чуть позже.</p>
<p>Теперь, когда тесты на месте, мы можем сделать класс Franc производным от класса Money:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>class Franc extends Money {</p>
<p>private int amount;</p>
<p>}</p>
<empty-line></empty-line><p>Далее мы можем уничтожить поле amount в классе Franc, так как это значение будет храниться в одноименном поле класса Money:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>class Franc extends Money {</p>
<p>}</p>
<empty-line></empty-line><p>Метод Franc.equals() выглядит фактически так же, как и метод Money.equals(). Сделав их абсолютно одинаковыми, мы сможем удалить реализацию этого метода из класса Franc. При этом смысл нашей программы не изменится. Для начала изменим объявление временной переменной:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>public boolean equals(Object object) {</p>
<p><strong>Money</strong> franc = (Franc) object;</p>
<p>return amount == franc.amount;</p>
<p>}</p>
<empty-line></empty-line><p>После этого изменим операцию преобразования типа:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>public boolean equals(Object object) {</p>
<p>Money franc = (<strong>Money</strong>) object;</p>
<p>return amount == franc.amount;</p>
<p>}</p>
<empty-line></empty-line><p>Теперь, даже не меняя имя временной переменной, можно видеть, что метод получился фактически таким же, как одноименный метод в классе Money. Однако для пущей уверенности переименуем временную переменную:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>public boolean equals(Object object) {</p>
<p>Money <strong>money</strong> = (Money) object;</p>
<p>return amount == <strong>money</strong>.amount;</p>
<p>}</p>
<p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strikethrough>5 CHF * 2 = 1 °CHF</strikethrough></p>
<p>Дублирование Dollar/Franc</p>
<p><strikethrough>Общие операции equals()</strikethrough></p>
<p>Общие операции times()</p>
<p>Сравнение франков (Franc) и долларов (Dollar)</p>
<empty-line></empty-line><p>Теперь нет никакой разницы между методами Franc.equals() и Money.equals(), и мы можем удалить избыточную реализацию этого метода из класса Franc. Запускаем тесты. Они выполняются успешно.</p>
<p>Что должно происходить при сравнении франков и долларов? Мы рассмотрим этот вопрос в главе 7.</p>
<p>В данной главе мы</p>
<p>• поэтапно переместили общий код из одного класса (Dollar) в суперкласс (Money);</p>
<p>• сделали второй класс (Franc) подклассом общего суперкласса (Money);</p>
<p>• унифицировали две реализации метода equals() и удалили избыточную реализацию в классе Franc.</p>
</section><section><title><p>7. Яблоки и апельсины</p>
</title><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p>equals()</p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strikethrough>5 CHF * 2 = 1 °CHF</strikethrough></p>
<p>Дублирование Dollar/Franc</p>
<p><strikethrough>Общие операции equals()</strikethrough></p>
<p>Общие операции times()</p>
<p><strong>Сравнение франков (Franc) и долларов (Dollar)</strong></p>
<empty-line></empty-line><p>В конце главы 6 перед нами встал интересный вопрос: что будет, если мы сравним франки и доллары? Мы немедленно добавили соответствующий пункт в список предстоящих задач. Нам никак не избавиться от этой мысли. И в самом деле, что произойдет?</p>
<empty-line></empty-line><p>public void testEquality() {</p>
<p>assertTrue(new Dollar(5). equals(new Dollar(5)));</p>
<p>assertFalse(new Dollar(5). equals(new Dollar(6)));</p>
<p>assertTrue(new Franc(5). equals(new Franc(5)));</p>
<p>assertFalse(new Franc(5). equals(new Franc(6)));</p>
<p>assertFalse(new Franc(5). equals(new Dollar(5)));</p>
<p>}</p>
<empty-line></empty-line><p>Тест завершается неудачей. С точки зрения написанного кода доллары – это франки. Прежде чем у наших швейцарских клиентов глаза вылезут на лоб, давайте попробуем исправить код. Код сравнения двух денежных значений должен убедиться в том, что он не сравнивает доллары с франками. Для этого мы должны проверить классы сравниваемых объектов – два объекта класса Money считаются равными только в том случае, если у них равны значения amount и классы.</p>
<empty-line></empty-line><p>public boolean equals(Object object) {</p>
<p>Money money = (Money) object;</p>
<p>return amount == money.amount</p>
<p>&amp;&amp; getClass(). equals(money.getClass());</p>
<p>}</p>
<empty-line></empty-line><p>Подобное использование классов, по правде сказать, отдает неприятным запашком. Предпочтительнее было бы использовать критерий из области финансов, а не из области объектов языка Java. Однако на текущий момент в нашей программе еще нет ничего, что соответствовало бы финансовому понятию «валюта», и пока я не вижу достаточно весомой причины, чтобы вводить в программу подобное понятие. Поэтому пока оставим код таким, какой он есть.</p>
<empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strikethrough>5 CHF * 2 = 1 °CHF</strikethrough></p>
<p>Дублирование Dollar/Franc</p>
<p><strikethrough>Общие операции equals()</strikethrough></p>
<p>Общие операции times()</p>
<p><strikethrough>Сравнение франков (Franc) и долларов (Dollar)</strikethrough></p>
<p>Валюта?</p>
<empty-line></empty-line><p>Теперь пришла пора избавиться от дублирующегося кода в методах times(), после этого мы сможем перейти к реализации смешанной валютной арифметики. Однако прежде, чем двинуться дальше, подведем итоги данной главы:</p>
<p>• мы превратили мучающее нас сомнение в тест;</p>
<p>• добились успешного выполнения теста приемлемым, но не идеальным способом – getClass();</p>
<p>• решили не добавлять в программу дополнительной логики, пока у нас не появится более весомая мотивация.</p>
</section><section><title><p>8. Создание объектов</p>
</title><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strikethrough>5 CHF * 2 = 1 °CHF</strikethrough></p>
<p><strong>Дублирование Dollar/Franc</strong></p>
<p><strikethrough>Общие операции equals()</strikethrough></p>
<p>Общие операции times()</p>
<p><strikethrough>Сравнение франков (Franc) и долларов (Dollar)</strikethrough></p>
<p>Валюта?</p>
<empty-line></empty-line><p>Две разные реализации метода times() выглядят на удивление похоже:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>Franc times(int multiplier) {</p>
<p>return new Franc(amount * multiplier)</p>
<p>}</p>
<p><strong>Dollar</strong></p>
<p>Dollar times(int multiplier) {</p>
<p>return new Dollar(amount * multiplier)</p>
<p>}</p>
<empty-line></empty-line><p>Мы можем сделать их еще более похожими, изменив тип возвращаемого значения на Money:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p><strong>Money</strong> times(int multiplier) {</p>
<p>return new Franc(amount * multiplier)</p>
<p>}</p>
<p>Dollar</p>
<p><strong>Money</strong> times(int multiplier) {</p>
<p>return new Dollar(amount * multiplier)</p>
<p>}</p>
<empty-line></empty-line><p>Следующий шаг менее очевиден. Два подкласса, производных от класса Money, мало чем отличаются друг от друга. Возникает желание избавиться от них. Однако мы не можем сделать это за один большой шаг, так как это нельзя будет назвать наглядной демонстрацией методики TDD.</p>
<p>Но что же делать? Полагаю, мы сможем приблизиться к решению задачи об уничтожении подклассов, если избавимся от прямых ссылок на подклассы. Для этого мы можем добавить в класс Money фабричный метод, который возвращал бы объект класса Dollar. Этот метод можно было бы использовать следующим образом:</p>
<empty-line></empty-line><p>public void testMultiplication() {</p>
<p>Dollar five = <strong>Money.dollar</strong>(5);</p>
<p>assertEquals(new Dollar(10), five.times(2));</p>
<p>assertEquals(new Dollar(15), five.times(3));</p>
<p>}</p>
<empty-line></empty-line><p>Реализация этого метода создает объект класса Dollar и возвращает его:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>static Dollar dollar(int amount) {</p>
<p>return new Dollar(amount);</p>
<p>}</p>
<empty-line></empty-line><p>Однако мы хотим избавиться от ссылок на Dollar, поэтому изменим объявление переменной в коде теста:</p>
<empty-line></empty-line><p>public void testMultiplication() {</p>
<p><strong>Money</strong> five = Money.dollar(5);</p>
<p>assertEquals(new Dollar(10), five.times(2));</p>
<p>assertEquals(new Dollar(15), five.times(3));</p>
<p>}</p>
<empty-line></empty-line><p>Компилятор вежливо сообщает нам, что метод times() в классе Money не определен. На текущий момент мы не можем реализовать его, поэтому объявим класс Money абстрактным (может быть, с этого стоило начать?) и объявим также абстрактным метод Money.times():</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>abstract class Money</p>
<p>abstract Money times(int multiplier);</p>
<empty-line></empty-line><p>Теперь мы можем изменить объявление фабричного метода:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>static <strong>Money</strong> dollar(int amount) {</p>
<p>return new Dollar(amount);</p>
<p>}</p>
<empty-line></empty-line><p>Все тесты выполняются успешно, стало быть, по крайней мере, мы ничего не сломали. Теперь мы можем использовать фабричный метод повсюду в тестах:</p>
<empty-line></empty-line><p>public void testMultiplication() {</p>
<p>Money five = Money.dollar(5);</p>
<p>assertEquals(<strong>Money.dollar</strong>(10), five.times(2));</p>
<p>assertEquals(<strong>Money.dollar</strong>(15), five.times(3));</p>
<p>}</p>
<p>public void testEquality() {</p>
<p>assertTrue(<strong>Money.dollar</strong>(5). equals(<strong>Money.dollar</strong>(5)));</p>
<p>assertFalse(<strong>Money.dollar</strong>(5). equals(<strong>Money.dollar</strong>(6)));</p>
<p>assertTrue(new Franc(5). equals(new Franc(5)));</p>
<p>assertFalse(new Franc(5). equals(new Franc(6)));</p>
<p>assertFalse(new Franc(5). equals(<strong>Money.dollar</strong>(5)));</p>
<p>}</p>
<empty-line></empty-line><p>Теперь мы находимся в несколько более выгодной позиции, чем раньше. Клиентский код ничего не знает о существовании подкласса Dollar. Освободив код тестов от ссылок на подклассы, мы получили возможность изменять структуру наследования, не внося при этом каких-либо изменений в клиентский код.</p>
<p>Прежде чем механически исправлять код теста testFrancMultiplication(), обратите внимание, что теперь он не тестирует никакой логики, кроме той, что уже протестирована функцией testMultiplication(). Напрашивается вопрос: нужна ли нам функция testFrancMultiplication()? Если мы удалим этот тест, потеряем ли мы уверенность в нашем коде? Похоже, что нет, однако мы все же сохраним пока этот тест просто так – на всякий случай.</p>
<empty-line></empty-line><p>public void testEquality() {</p>
<p>assertTrue(Money.dollar(5). equals(Money.dollar(5)));</p>
<p>assertFalse(Money.dollar(5). equals(Money.dollar(6)));</p>
<p>assertTrue(Money.franc(5). equals(Money.franc(5)));</p>
<p>assertFalse(Money.franc(5). equals(Money.franc(6)));</p>
<p>assertFalse(Money.franc(5). equals(Money.dollar(5)));</p>
<p>}</p>
<p>public void testFrancMultiplication() {</p>
<p>Money five = Money.franc(5);</p>
<p>assertEquals(Money.franc(10), five.times(2));</p>
<p>assertEquals(Money.franc(15), five.times(3));</p>
<p>}</p>
<empty-line></empty-line><p>Реализация метода Money.franc() почти такая же, как и реализация метода Money.dollar():</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>static Money franc(int amount) {</p>
<p>return new Franc(amount);</p>
<p>}</p>
<p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strikethrough>5 CHF * 2 = 1 °CHF</strikethrough></p>
<p><strong>Дублирование Dollar/Franc</strong></p>
<p><strikethrough>Общие операции equals()</strikethrough></p>
<p>Общие операции times()</p>
<p><strikethrough>Сравнение франков (Franc) и долларов (Dollar)</strikethrough></p>
<p>Валюта?</p>
<p>Нужен ли тест testFrancMultiplication()?</p>
<empty-line></empty-line><p>Далее мы планируем перейти к устранению дублирования в методах times(). А сейчас вспомним, что в данной главе мы</p>
<p>• сделали шаг на пути к устранению дублирования – сформировали общую сигнатуру для двух вариантов одного метода – times();</p>
<p>• добавили объявление метода в общий суперкласс;</p>
<p>• освободили тестовый код от ссылок на производные классы, для этого были созданы фабричные методы;</p>
<p>• заметили, что, когда подклассы исчезли, некоторые тесты стали избыточными, однако никаких действий предпринято не было.</p>
</section><section><title><p>9. Потребность в валюте</p>
</title><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strikethrough>5 CHF * 2 = 1 °CHF</strikethrough></p>
<p>Дублирование Dollar/Franc</p>
<p><strikethrough>Общие операции equals()</strikethrough></p>
<p>Общие операции times()</p>
<p><strikethrough>Сравнение франков (Franc) и долларов (Dollar)</strikethrough></p>
<p><strong>Валюта?</strong></p>
<p>Нужен ли тест testFrancMultiplication()?</p>
<empty-line></empty-line><p>Есть ли в нашем списке задач какой-либо пункт, который помог бы нам избавиться от этих надоедливых подклассов? Что произойдет, если мы попробуем ввести в нашу программу понятие валюты?</p>
<p>Каким образом мы можем реализовать понятие валюты в данный момент? Черт! Опять я говорю ерунду! Вместо того чтобы снова бить себя линейкой по рукам, попробую перефразировать: каким образом мы можем протестировать понятие валюты в данный момент? Слава богу, мои руки спасены.</p>
<p>Возможно, в будущем нам захочется создать специальный класс валюты, применив шаблон «Приспособленец» (Flyweight Factory), чтобы избежать создания лишних объектов. Однако на текущий момент понятие валюты вполне можно реализовать в виде обычных строк:</p>
<empty-line></empty-line><p>public void testCurrency() {</p>
<p>assertEquals("USD", Money.dollar(1). currency());</p>
<p>assertEquals("CHF", Money.franc(1). currency());</p>
<p>}</p>
<empty-line></empty-line><p>Прежде всего объявим метод currency() в классе Money:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>abstract String currency();</p>
<empty-line></empty-line><p>Теперь реализуем этот метод в обоих подклассах:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>String currency() {</p>
<p>return "CHF";</p>
<p>}</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>String currency() {</p>
<p>return "USD";</p>
<p>}</p>
<empty-line></empty-line><p>Однако хотелось бы иметь одну и ту же реализацию в обоих подклассах, поэтому сохраним идентификатор валюты в специальном поле класса и просто вернем его значение в методе currency(). (Я начинаю делать рефакторинг быстрее, чтобы сэкономить время. Если вам покажется, что я рассказываю слишком быстро, не стесняйтесь попросить меня замедлиться. Постойте-ка, это же книга, – наверное, мне не стоит слишком уж ускоряться.)</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>private String currency;</p>
<p>Franc(int amount) {</p>
<p>this.amount = amount;</p>
<p>currency = "CHF";</p>
<p>}</p>
<p>String currency() {</p>
<p>return currency;</p>
<p>}</p>
<empty-line></empty-line><p>То же самое сделаем в классе Dollar:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>private String currency;</p>
<p>Dollar(int amount) {</p>
<p>this.amount = amount;</p>
<p>currency = "USD";</p>
<p>}</p>
<p>String currency() {</p>
<p>return currency;</p>
<p>}</p>
<empty-line></empty-line><p>Теперь мы можем переместить объявление переменной и реализацию метода currency() в базовый класс Money, так как в обоих подклассах они одинаковые:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>protected String currency;</p>
<p>String currency() {</p>
<p>return currency;</p>
<p>}</p>
<empty-line></empty-line><p>Если переместить строковые констаны «USD» и «CHF» в статические фабричные методы, конструкторы двух производных классов станут идентичными, в результате мы сможем создать общую реализацию.</p>
<p>Вначале добавим в конструктор дополнительный параметр:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>Franc(int amount, <strong>String currency</strong>) {</p>
<p>this.amount = amount;</p>
<p>this.currency = "CHF";</p>
<p>}</p>
<empty-line></empty-line><p>При этом возникают ошибки в двух местах при обращении к конструктору:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>static Money franc(int amount) {</p>
<p>return new Franc(amount, null);</p>
<p>}</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>Money times(int multiplier) {</p>
<p>return new Franc(amount * multiplier, null);</p>
<p>}</p>
<empty-line></empty-line><p>Постойте-ка! Почему это метод Franc.times() вызывает конструктор вместо фабричного метода? Будем ли мы заниматься этим сейчас или отложим любые связанные с этим модификации на более позднее время? В рамках догмы мы должны оставить посторонние дела на потом – не следует прерывать то, чем мы сейчас занимаемся. Однако на практике я иногда позволяю себе отвлечься, но лишь ненадолго, и ни в коем случае я не разрешаю себе прерывать прерывание (этому правилу научил меня Джим Коплаен – Jim Coplien). В данном случае будет лучше, если мы подчистим метод times(), прежде чем продолжить:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>Money times(int multiplier) {</p>
<p>return Money.franc(amount * multiplier);</p>
<p>}</p>
<empty-line></empty-line><p>Теперь фабричному методу можно передать значение «CHF»:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>static Money franc(int amount) {</p>
<p>return new Franc(amount,<strong>«CHF»</strong>);</p>
<p>}</p>
<empty-line></empty-line><p>Наконец, мы можем присвоить значение параметра полю класса:</p>
<p><strong>Franc</strong></p>
<p>Franc(int amount, String currency) {</p>
<p>this.amount = amount;</p>
<p>this.currency = <strong>currency</strong>;</p>
<p>}</p>
<empty-line></empty-line><p>Может показаться, что я снова перемещаюсь вперед слишком маленькими шажками. Действительно ли я рекомендую вам работать в таком же темпе? Нет. Я рекомендую вначале научиться работать в таком темпе, а затем самостоятельно определять скорость работы, которая покажется вам наиболее эффективной. Я всего лишь попробовал двигаться вперед большими шагами и на половине дороги допустил глупую ошибку. Запутавшись, я вернулся назад на несколько минут, перешел на пониженную передачу и сделал работу заново, более мелкими шажками. Сейчас я чувствую себя уверенней, поэтому мы можем попробовать внести такие же изменения в класс Dollar за один большой шаг:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>static Money dollar(int amount) {</p>
<p>return new Dollar(amount,<strong>«USD»</strong>);</p>
<p>}</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>Dollar(int amount, String currency) {</p>
<p>this.amount = amount;</p>
<p>this.currency = <strong>currency</strong>;</p>
<p>}</p>
<p>Money times(int multiplier) {</p>
<p>return <strong>Money.dollar(amount * multiplier);</strong></p>
<p>}</p>
<empty-line></empty-line><p>И это сработало с первого раза. Классно!</p>
<p>Подобная настройка скорости весьма характерна для TDD. Вам кажется, что слишком маленькие шажки ограничивают вас? Попробуйте двигаться быстрее. Почувствовали неуверенность? Переходите на короткий шаг. TDD – это процесс плавного управления – немного в одну сторону, немного в другую сторону. Не существует одного-единственного наиболее правильного размера шага, ни сейчас, ни в будущем.</p>
<p>Теперь два конструктора выглядят абсолютно одинаково, и мы можем переместить реализацию в базовый класс:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>Money(int amount, String currency) {</p>
<p>this.amount = amount;</p>
<p>this.currency = currency;</p>
<p>}</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>Franc(int amount, String currency) {</p>
<p>super(amount, currency);</p>
<p>}</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>Dollar(int amount, String currency) {</p>
<p>super(amount, currency);</p>
<p>}</p>
<p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strikethrough>5 CHF * 2 = 1 °CHF</strikethrough></p>
<p><strong>Дублирование Dollar/Franc</strong></p>
<p><strikethrough>Общие операции equals()</strikethrough></p>
<p>Общие операции times()</p>
<p><strikethrough>Сравнение франков (Franc) и долларов (Dollar)</strikethrough></p>
<p><strikethrough>Валюта?</strikethrough></p>
<p>Нужен ли тест testFrancMultiplication()?</p>
<empty-line></empty-line><p>Мы уже почти готовы переместить реализацию times() в базовый класс, но прежде вспомним, что в данной главе мы</p>
<p>• на некоторое время заблудились в крупномасштабных идеях дизайна и, чтобы разобраться в проблеме, решили начать с решения небольшой задачи, на которую мы уже обратили внимание ранее;</p>
<p>• сделали одинаковыми два конструктора, переместив отличающийся код в вызывающий (фабричный) метод;</p>
<p>• на короткое время отвлеклись от рефакторинга, чтобы добавить в метод times() вызов фабричного метода;</p>
<p>• выполнили аналогичный рефакторинг в отношении класса Dollar за один большой шаг;</p>
<p>• получили два абсолютно идентичных конструктора и переместили код в базовый класс.</p>
</section><section><title><p>10. Избавление от двух разных версий times()</p>
</title><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strikethrough>5 CHF * 2 = 1 °CHF</strikethrough></p>
<p>Дублирование Dollar/Franc</p>
<p><strikethrough>Общие операции equals()</strikethrough></p>
<p><strong>Общие операции times()</strong></p>
<p><strikethrough>Сравнение франков (Franc) и долларов (Dollar)</strikethrough></p>
<p><strikethrough>Валюта?</strikethrough></p>
<p>Нужен ли тест testFrancMultiplication()?</p>
<empty-line></empty-line><p>В конце данной главы мы должны получить единый класс Money, соответствующий понятию «деньги». Две реализации метода times() близки друг к другу, однако они не идентичны:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>Money times(int multiplier) {</p>
<p>return Money.franc(amount * multiplier);</p>
<p>}</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>Money times(int multiplier) {</p>
<p>return Money.dollar(amount * multiplier);</p>
<p>}</p>
<empty-line></empty-line><p>Увы, я не вижу простого способа добиться идентичности этих методов, однако в некоторых ситуациях, для того чтобы продвинуться дальше, требуется вернуться немного назад, – это напоминает кубик Рубика. Что будет, если мы заменим вызовы фабричных методов операторами new? (Я отлично понимаю, что совсем недавно мы выполнили обратную процедуру – заменили new вызовами фабричных методов. Но что я могу поделать – сейчас мы решаем несколько иную задачу. Понимаю, что это может показаться обескураживающим, однако потерпите немного.)</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>Money times(int multiplier) {</p>
<p>return new Franc(amount * multiplier, "CHF");</p>
<p>}</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>Money times(int multiplier) {</p>
<p>return new Dollar(amount * multiplier, "USD");</p>
<p>}</p>
<empty-line></empty-line><p>Мы абсолютно уверены, что в экземплярах класса Franc значение поля currency всегда будет равно «CHF», поэтому можем написать:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>Money times(int multiplier) {</p>
<p>return new Franc(amount * multiplier, <strong>currency</strong>);</p>
<p>}</p>
<empty-line></empty-line><p>Сработало! Теперь тот же трюк можно проделать и в отношении класса Dollar:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>Money times(int multiplier) {</p>
<p>return new Dollar(amount * multiplier,<strong>currency</strong>);</p>
<p>}</p>
<empty-line></empty-line><p>Мы почти закончили. Имеет ли значение, что мы используем в данном случае – Franc или Money? Об этом можно рассуждать в течение некоторого времени исходя из имеющихся знаний о внутреннем устройстве нашей системы, однако у нас есть чистый код и тесты, которые дают нам уверенность в том, что код работает так, как надо. Вместо того чтобы тратить несколько минут на рассуждения, мы можем спросить об этом компьютер. Для этого достаточно внести интересующие нас изменения в код и запустить тесты. Обучая методике TDD, я наблюдаю подобную ситуацию постоянно – опытные умные программисты тратят от 5 до 10 минут на обсуждение вопроса, на который компьютер может дать ответ в течение 15 секунд. Если у вас нет тестов, вам остается только размышлять и предполагать. Если же у вас есть тесты, вместо того, чтобы напрасно тратить время, вы можете провести быстрый эксперимент. Как правило, если у вас есть тесты, быстрее спросить компьютер.</p>
<p>Чтобы провести интересующий нас эксперимент, модифицируем код так, чтобы метод Franc.times() возвращал значение типа Money:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>Money times(int multiplier) {</p>
<p>return new <strong>Money</strong> (amount * multiplier, currency);</p>
<p>}</p>
<empty-line></empty-line><p>В ответ компилятор сообщил, что Money должен быть конкретным (не абстрактным) классом:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>class Money</p>
<p>Money times(int amount) {</p>
<p>return null;</p>
<p>}</p>
<empty-line></empty-line><p>Получаем красную полоску и сообщение об ошибке: «expected:&lt;Money.Franc@31aebf&gt; but was:&lt;Money.Money@478a43&gt;». Не очень-то информативно. Не так информативно, как нам хотелось бы. Чтобы получить более осмысленное сообщение об ошибке, добавим метод toString():</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>public String toString() {</p>
<p>return amount + " " + currency;</p>
<p>}</p>
<empty-line></empty-line><p>О, ужас! Код без тестов?! Допустимо ли такое? Конечно же, прежде чем писать код метода toString, мы должны были написать соответствующий тест, однако</p>
<p>• мы увидим результаты работы этого метода на экране;</p>
<p>• метод toString() используется только для отладки, поэтому риск, связанный с потенциальными ошибками, невелик;</p>
<p>• перед нами красная полоса, а мы предпочитаем не писать новых тестов, пока не избавимся от красной полосы.</p>
<p>Обстоятельства приняты к сведению.</p>
<p>Теперь сообщение об ошибке изменилось: "expected:&lt;1 °CHF&gt; but was:&lt;1 °CHF&gt;". Выглядит осмысленней, однако сбивает с толку. В двух объектах хранятся одни и те же данные, однако при этом объекты не считаются равными. Проблема кроется в реализации метода equals():</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>public boolean equals(Object object) {</p>
<p>Money money = (Money) object;</p>
<p>return amount == money.amount</p>
<p>&amp;&amp; getClass(). equals(money.getClass());</p>
<p>}</p>
<empty-line></empty-line><p>В данном случае происходит сравнение имен классов, в то время как логичнее сравнивать идентификаторы валют.</p>
<p>Лучше не писать никаких новых тестов, если перед вами красная полоса. Однако нам нужно внести изменения в разрабатываемый код, и мы не можем изменить код, не обладая соответствующим тестом. Консервативный подход заключается в том, чтобы отменить изменение, которое привело к появлению красной полосы. В этом случае мы вновь получим зеленую полосу. После этого мы сможем модифицировать тест для метода equals(), исправить его реализацию и вновь применить изначальное изменение.</p>
<p>В данном случае мы будем действовать консервативно. (Иногда я плюю на все и пишу тест, не обращая внимания на красную полосу, однако я поступаю так, только когда дети уже спят.)</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>Money times(int multiplier) {</p>
<p>return new <strong>Franc</strong> (amount * multiplier, currency);</p>
<p>}</p>
<empty-line></empty-line><p>Перед нами снова зеленая полоса. Мы попали в ситуацию, когда объект Franc(10,"CHF") не равен объекту Money(10,"CHF"), хотя нам хотелось бы, чтобы эти объекты были равны. Превращаем наше желание в тест:</p>
<empty-line></empty-line><p>public void testDifferentClassEquality() {</p>
<p>assertTrue(new Money(10, "CHF"). equals(new Franc(10, "CHF")));</p>
<p>}</p>
<empty-line></empty-line><p>Как и ожидалось, тест потерпел неудачу. Код метода equal() должен сравнивать идентификаторы валют, а не имена классов:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>public boolean equals(Object object) {</p>
<p>Money money = (Money) object;</p>
<p>return amount == money.amount</p>
<p><strong>&amp;&amp; currency(). equals(money.currency());</strong></p>
<p>}</p>
<empty-line></empty-line><p>Теперь метод Franc.times() может возвращать значение Money, и все тесты будут по-прежнему успешно выполняться:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>Money times(int multiplier) {</p>
<p>return new <strong>Money</strong>(amount * multiplier, currency);</p>
<p>}</p>
<empty-line></empty-line><p>Сработает ли этот трюк для метода Dollar.times()?</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>Money times(int multiplier) {</p>
<p>return new <strong>Money</strong> (amount * multiplier, currency);</p>
<p>}</p>
<empty-line></empty-line><p>Да! Теперь две реализации абсолютно идентичны, и мы можем переместить их в базовый класс.</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>Money times(int multiplier) {</p>
<p>return new Money(amount * multiplier, currency);</p>
<p>}</p>
<p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strikethrough>5 CHF * 2 = 1 °CHF</strikethrough></p>
<p>Дублирование Dollar/Franc</p>
<p><strikethrough>Общие операции equals()</strikethrough></p>
<p><strikethrough>Общие операции times()</strikethrough></p>
<p><strikethrough>Сравнение франков (Franc) и долларов (Dollar)</strikethrough></p>
<p><strikethrough>Валюта?</strikethrough></p>
<p>Нужен ли тест testFrancMultiplication()?</p>
<empty-line></empty-line><p>Метод умножения там, где ему следует быть, теперь мы готовы удалить ненужные нам производные классы.</p>
<p>В данной главе мы</p>
<p>• сделали идентичными две реализации метода times(), для этого мы избавились от вызовов фабричных методов в них, и заменили константы переменными;</p>
<p>• добавили в класс отладочный метод toString() без теста;</p>
<p>• попробовали модифицировать код (заменили тип Franc возвращаемого значения на Money) и обратились к тестам, чтобы узнать, сработает ли это;</p>
<p>• отменили изменения и написали еще один тест, добились успешного выполнения теста и вновь применили изменения.</p>
</section><section><title><p>11. Корень всего зла</p>
</title><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strikethrough>5 CHF * 2 = 1 °CHF</strikethrough></p>
<p><strong>Дублирование Dollar/Franc</strong></p>
<p><strikethrough>Общие операции equals()</strikethrough></p>
<p><strikethrough>Общие операции times()</strikethrough></p>
<p><strikethrough>Сравнение франков (Franc) и долларов (Dollar)</strikethrough></p>
<p><strikethrough>Валюта?</strikethrough></p>
<p>Нужен ли тест testFrancMultiplication()?</p>
<empty-line></empty-line><p>Два производных класса, Dollar и Franc, обладают только конструкторами, однако конструктор – это недостаточная причина для создания подкласса. Мы должны избавиться от бесполезных подклассов.</p>
<p>Ссылки на подклассы можно заменить ссылками на суперкласс, не изменив при этом смысл кода. Начнем с класса Franc:</p>
<empty-line></empty-line><p><strong>Franc</strong></p>
<p>static Money franc(int amount) {</p>
<p>return new <strong>Money</strong> (amount, «CHF»);</p>
<p>}</p>
<empty-line></empty-line><p>Затем перейдем к классу Dollar:</p>
<empty-line></empty-line><p><strong>Dollar</strong></p>
<p>static Money dollar(int amount) {</p>
<p>return new <strong>Money</strong> (amount, «USD»);</p>
<p>}</p>
<empty-line></empty-line><p>Ссылок на класс Dollar больше нет, поэтому мы можем удалить этот класс. Однако в только что написанном нами тесте есть одна ссылка на класс Franc:</p>
<empty-line></empty-line><p>public void testDifferentClassEquality() {</p>
<p>assertTrue(new Money(10, "CHF"). equals(new Franc(10, "CHF")));</p>
<p>}</p>
<empty-line></empty-line><p>Если равенство объектов достаточно хорошо протестировано другими тестами, значит, мы можем безбоязненно удалить этот тест. Давайте взглянем на другие тесты:</p>
<empty-line></empty-line><p>public void testEquality() {</p>
<p>assertTrue(Money.dollar(5). equals(Money.dollar(5)));</p>
<p>assertFalse(Money.dollar(5). equals(Money.dollar(6)));</p>
<p>assertTrue(Money.franc(5). equals(Money.franc(5)));</p>
<p>assertFalse(Money.franc(5). equals(Money.franc(6)));</p>
<p>assertFalse(Money.franc(5). equals(Money.dollar(5)));</p>
<p>}</p>
<empty-line></empty-line><p>Похоже, что все возможные случаи определения равенства достаточно полно охвачены другими тестами. Я даже сказал бы, что тестов слишком много. Мы можем удалить третье и четвертое выражение assert, так как они дублируют первое и второе:</p>
<empty-line></empty-line><p>public void testEquality() {</p>
<p>assertTrue(Money.dollar(5). equals(Money.dollar(5)));</p>
<p>assertFalse(Money.dollar(5). equals(Money.dollar(6)));</p>
<p>assertFalse(Money.franc(5). equals(Money.dollar(5)));</p>
<p>}</p>
<p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 * 2 = $10</strikethrough></p>
<p><strikethrough>Сделать переменную amount закрытым (private) членом</strikethrough></p>
<p><strikethrough>Побочные эффекты в классе Dollar?</strikethrough></p>
<p>Округление денежных величин?</p>
<p><strikethrough>equals()</strikethrough></p>
<p>hashCode()</p>
<p>Равенство значению null</p>
<p>Равенство объектов</p>
<p><strikethrough>5 CHF * 2 = 1 °CHF</strikethrough></p>
<p><strikethrough>Дублирование Dollar/Franc</strikethrough></p>
<p><strikethrough>Общие операции equals()</strikethrough></p>
<p><strikethrough>Общие операции times()</strikethrough></p>
<p><strikethrough>Сравнение франков (Franc) и долларов (Dollar)</strikethrough></p>
<p><strikethrough>Валюта?</strikethrough></p>
<p><strikethrough>Нужен ли тест testFrancMultiplication()?</strikethrough></p>
<empty-line></empty-line><p>Тест testDifferentClassEquality() служит доказательством того, что, сравнивая объекты, мы сравниваем различные валюты, но не различные классы. Этот тест имеет смысл только в случае, если в программе существует несколько различных классов. Однако мы уже избавились от класса Dollar и намерены точно так же избавиться от класса Franc. Иными словами, в нашем распоряжении останется только один денежный класс: Money. С учетом наших намерений, тест testDifferentClassEquality() оказывается для нас излишней обузой. Мы удалим его, а затем избавимся от класса Franc.</p>
<p>Обратите также внимание, что в программе присутствуют отдельные тесты для проверки умножения франков на доллары. Если заглянуть в код, можно увидеть, что на текущий момент логика метода, реализующего умножение, не зависит от типа валюты (зависимость была бы только в случае, если бы мы использовали два различных класса). То есть мы можем удалить функцию testFrancMultiplication(), не опасаясь, что потеряем уверенность в правильности работы системы.</p>
<p>Итак, в нашем распоряжении единый денежный класс, и мы готовы приступить к реализации сложения.</p>
<p>Но сначала подведем итоги. В этой главе мы</p>
<p>• закончили потрошить производные классы и избавились от них;</p>
<p>• удалили тесты, которые имели смысл только при использовании старой структуры кода, но оказались избыточными в коде с новой структурой.</p>
</section><section><title><p>12. Сложение, наконец-то</p>
</title><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<empty-line></empty-line><p>Наступил новый день, и я заметил, что список задач переполнен вычеркнутыми пунктами. Лучше всего переписать оставшиеся не зачеркнутыми пункты в новый свежий список. (Я люблю физически копировать пункты из старого списка в новый список. Если в старом списке много мелких недоделанных задач, вместо того, чтобы копировать их в новый список, я просто добавляю в программу соответствующий код. В результате из-за моей лени куча мелочей, которая могла бы расти со временем, просто исчезает. Используйте свои слабости.)</p>
<empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strong>$5 + $5 = $10</strong></p>
<empty-line></empty-line><p>Пока что я не представляю себе, как можно реализовать смешанное сложение долларов и франков, поэтому предлагаю начать с более простой задачи: $5 + $5 = $10.</p>
<empty-line></empty-line><p>public void testSimpleAddition() {</p>
<p>Money sum = Money.dollar(5). plus(Money.dollar(5));</p>
<p>assertEquals(Money.dollar(10), sum);</p>
<p>}</p>
<empty-line></empty-line><p>Мы могли бы подделать реализацию, просто вернув значение Money.dollar(10), однако в данном случае реализация кажется очевидной. Давайте попробуем:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>Money plus(Money addend) {</p>
<p>return new Money(amount + addend.amount, currency);</p>
<p>}</p>
<empty-line></empty-line><p>(Далее я буду ускорять процесс разработки, чтобы сэкономить бумагу и сохранить ваш интерес. Там, где дизайн не очевиден, я буду подделывать реализацию и выполнять рефакторинг. Я надеюсь, что благодаря этому вы увидите, каким образом в TDD выполняется контроль над величиной шагов.)</p>
<p>Сказав, что планирую увеличить скорость, я немедленно замедляю процесс разработки. Однако я не планирую замедлять процесс написания кода, который обеспечивает успешное тестирование. Я планирую замедлить процесс написания самих тестов. Некоторые ситуации и некоторые тесты требуют тщательного обдумывания. Каким образом мы планируем представить арифметику со смешанными валютами? Это как раз тот случай, когда требуется тщательное обдумывание.</p>
<p>Наиболее важное и сложное ограничение, с которым нам приходится иметь дело, заключается в том, что мы не хотим, чтобы код нашей системы знал о существовании каких-либо валют. Нам хотелось бы, чтобы система имела дело с деньгами и не зависела от того, в какой валюте они представлены. Возможная стратегия состоит в том, чтобы немедленно преобразовывать любые денежные значения в некоторую единую валюту (попробуйте угадать, какая валюта является самой любимой у американских программистов). Однако подобное решение не позволит нам с легкостью варьировать соотношения (курсы обмена) между различными валютами.</p>
<p>Вместо этого мы хотели бы найти решение, которое позволило бы нам в удобной форме реализовать механизм обменных курсов и при этом обеспечить запись арифметических выражений в форме, близкой к стандартной арифметической записи.</p>
<p>Решение основано на объектах. Если имеющийся объект ведет себя не так, как нам хотелось бы, мы создаем еще один объект, обладающий точно таким же внешним протоколом, но отличающейся внутренней реализацией. Этот шаблон называется «Самозванец» (Imposter).</p>
<p>Возможно, многим это покажется хиромантией. Каким образом в данной ситуации можно использовать шаблон «Самозванец»? Однако я не собираюсь шутить над вами – не существует формулы, позволяющей генерировать гениальные дизайнерские решения. Решение проблемы было придумано Уордом Каннигемом десятилетие назад. Я еще не встречал человека, который независимо от Уорда придумал бы нечто подобное. К сожалению, методика TDD не гарантирует генерацию гениальных идей. Вместе с тем благодаря TDD вы имеете тесты, формирующие вашу уверенность в коде, а также тщательно вылизанный код, – все это является хорошей почвой для возникновения идеи и ее воплощения в реальность.</p>
<p>Итак, что же является решением в нашем случае? Предлагается создать объект, который ведет себя как объект Money, однако соответствует сумме двух объектов Money. Чтобы объяснить эту идею, я пробовал использовать несколько разных метафор. Например, можно рассматривать сумму различных денежных величин как <emphasis>бумажник</emphasis>. В один бумажник можно положить несколько банкнот разных валют и разных достоинств.</p>
<p>Еще одна метафора: <emphasis>выражение</emphasis>. Имеется в виду математическое выражение, например: (2 + 3) * 5. В нашем случае мы имеем дело с денежными величинами, поэтому выражение может быть таким: ($2 + 3 CHF) * 5. Класс Money – это атомарная форма выражения. В результате выполнения любых операций над денежными величинами получается объект класса Expression. Одним из таких объектов может быть объект Sum<a type="note" l:href="#n_7">[7]</a>. После того как операция (например, сложение нескольких значений в разных валютах) выполнена, полученный объект Expression можно привести к некоторой заданной валюте. Преобразование к некоторой валюте осуществляется на основании набора курсов обмена.</p>
<p>Как выразить эту метафору в виде набора тестов? Прежде всего, мы знаем, к чему мы должны прийти:</p>
<empty-line></empty-line><p>public void testSimpleAddition() {</p>
<p>…</p>
<p>assertEquals(Money.dollar(10), reduced);</p>
<p>}</p>
<empty-line></empty-line><p>Переменная reduced – это объект класса Expression, который создан путем применения обменных курсов в отношении объекта Expression, полученного в результате выполнения математической операции. Кто в реальном мире отвечает за применение обменных курсов? <emphasis>Банк</emphasis>. Стало быть, было бы неплохо, если бы мы могли написать</p>
<empty-line></empty-line><p>public void testSimpleAddition() {</p>
<p>…</p>
<p>Money reduced = bank.reduce(sum, "USD");</p>
<p>assertEquals(Money.dollar(10), reduced);</p>
<p>}</p>
<empty-line></empty-line><p>(Плохо, когда в одной программе смешиваются две разные метафоры: <emphasis>банк</emphasis> и <emphasis>математическое выражение</emphasis>. Однако сейчас предлагаю не заострять на этом внимания. Сначала воплотим в жизнь то, что запланировали, а затем посмотрим, можно ли улучшить нашу систему с литературно-художественной точки зрения.)</p>
<p>Обратите внимание на важное дизайнерское решение: метод reduce() принадлежит объекту bank. С такой же легкостью мы могли бы написать</p>
<empty-line></empty-line><p>…educed = sum.reduce(«USD», bank).</p>
<empty-line></empty-line><p>Почему ответственным за выполнение операции reduce() сделан именно объект bank? На самом деле ответ следующий: «Это первое, что пришло мне в голову», однако такой ответ нельзя считать удовлетворительным. Почему мне в голову пришло сделать ответственным за выполнение операции reduce() именно объект класса Bank, а не объект класса Expression? Вот что мне известно на текущий момент:</p>
<p>• Объекты класса Expression, по всей видимости, лежат в самом сердце того, что мы делаем. Я стараюсь делать объекты, являющиеся сердцем системы, как можно менее зависимыми от всего остального мира. Благодаря этому они остаются гибкими в течение длительного времени («гибкие» в данном случае означает «простые для понимания, тестирования и повторного использования»).</p>
<p>• Я могу предположить, что класс Expression будет нести ответственность за множество операций. Значит, мы должны по возможности освободить этот класс от лишней ответственности и переложить часть ответственности на другие классы там, где это допустимо. В противном случае класс Expression разрастется до неконтролируемых размеров.</p>
<empty-line></empty-line><p>Конечно, это всего лишь догадки – этого не достаточно, чтобы принимать какие-либо окончательные решения, однако этого вполне достаточно, чтобы я начал двигаться в избранном направлении. Безусловно, если выяснится, что наша система вполне может обойтись без класса Bank, я переложу ответственность за выполнение метода reduce() на класс Expression. Если мы используем объект bank, значит, его необходимо создать:</p>
<empty-line></empty-line><p>public void testSimpleAddition() {</p>
<p>…</p>
<p>Bank bank = new Bank();</p>
<p>Money reduced = bank.reduce(sum, "USD");</p>
<p>assertEquals(Money.dollar(10), reduced);</p>
<p>}</p>
<empty-line></empty-line><p>Сумма двух объектов Money – это объект класса Expression:</p>
<empty-line></empty-line><p>public void testSimpleAddition() {</p>
<p>…</p>
<p>Expression sum = five.plus(five);</p>
<p>Bank bank = new Bank();</p>
<p>Money reduced = bank.reduce(sum, "USD");</p>
<p>assertEquals(Money.dollar(10), reduced);</p>
<p>}</p>
<empty-line></empty-line><p>Наконец, операция, в которой мы абсолютно уверены, – создание пяти долларов:</p>
<empty-line></empty-line><p>public void testSimpleAddition() {</p>
<p>Money five = Money.dollar(5);</p>
<p>Expression sum = five.plus(five);</p>
<p>Bank bank = new Bank();</p>
<p>Money reduced = bank.reduce(sum, "USD");</p>
<p>assertEquals(Money.dollar(10), reduced);</p>
<p>}</p>
<empty-line></empty-line><p>Что надо сделать, чтобы данный код откомпилировался? Для начала создадим интерфейс Expression (мы могли бы создать класс, однако интерфейс обладает существенно меньшим весом):</p>
<empty-line></empty-line><p>Expression</p>
<p>interface Expression</p>
<empty-line></empty-line><p>Метод Money.plus() должен возвращать значение типа Expression:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>Expression plus(Money addend) {</p>
<p>return new Money(amount + addend.amount, currency):</p>
<p>}</p>
<empty-line></empty-line><p>Это означает, что класс Money должен реализовать интерфейс Expression (это очень просто, так как в этом интерфейсе пока что нет ни одной операции):</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>class Money implements Expression</p>
<empty-line></empty-line><p>Кроме того, нам потребуется пустой класс Bank:</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>class Bank</p>
<empty-line></empty-line><p>Добавим в этот класс заглушку для метода reduce():</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>Money reduce(Expression source, String to) {</p>
<p>return null;</p>
<p>}</p>
<empty-line></empty-line><p>Теперь код компилируется и выдает нам красную полоску. Ура! У нас прогресс! Теперь можем легко подделать реализацию:</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>Money reduce(Expression source, String to) {</p>
<p>return Money.dollar(10);</p>
<p>}</p>
<empty-line></empty-line><p>Зеленая полоса! Теперь мы готовы выполнить рефакторинг. Но сначала подведем итоги главы. В этой главе мы</p>
<p>• вместо большого теста реализовали меньший тест, чтобы добиться быстрого прогресса (вместо операции $5 + 1 °CHF ограничились более простой операцией $5 + $5);</p>
<p>• основательно обдумали возможные метафоры для нашего предполагаемого дизайна;</p>
<p>• переписали первоначальный тест в свете новой метафоры;</p>
<p>• как можно быстрее добились компиляции теста;</p>
<p>• добились успешного выполнения теста;</p>
<p>• с трепетом посмотрели вперед, оценив объем рефакторинга, который необходим, чтобы сделать реализацию реальной.</p>
<p>7 В переводе на русский язык <emphasis>sum</emphasis> – это сумма. – <emphasis>Примеч. пер</emphasis>.</p>
</section><section><title><p>13. Делаем реализацию реальной</p>
</title><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strong>$5 + $5 = $10</strong></p>
<empty-line></empty-line><p>Мы не можем вычеркнуть пункт $5 + $5, пока не удалим из кода все повторяющиеся фрагменты. Внимательно рассмотрим код. В нем нет повторяющегося кода, но есть повторяющиеся данные – $10 в «поддельной» реализации:</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>Money reduce(Expression source, String to) {</p>
<p>return <strong>Money.dollar(10)</strong>;</p>
<p>}</p>
<empty-line></empty-line><p>Это выражение по своей сути дублирует выражение $5 + $5 в коде теста:</p>
<empty-line></empty-line><p>public void testSimpleAddition() {</p>
<p>Money five = Money.dollar(5);</p>
<p>Expression sum = <strong>five.plus(five)</strong>;</p>
<p>Bank bank = new Bank();</p>
<p>Money reduced = bank.reduce(sum, "USD");</p>
<p>assertEquals(Money.dollar(10), reduced);</p>
<p>}</p>
<empty-line></empty-line><p>Раньше, если у нас имелась «поддельная» реализация, для нас было очевидным, как можно вернуться назад и сформировать реальную реализацию. Для этого достаточно было заменить константы переменными. Однако в данном случае пока не понимаю, как вернуться назад. Поэтому, несмотря на некоторый риск, я решаю двигаться вперед:</p>
<empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strong>$5 + $5 = $10</strong></p>
<p>Операция $5 + $5 возвращает объект Money</p>
<empty-line></empty-line><p>Прежде всего, метод Money.plus() должен возвращать не просто объект Money, а реальное выражение (Expression), то есть сумму (Sum). (Возможно, в будущем мы оптимизируем специальный случай сложения двух одинаковых валют, однако это произойдет позже.)</p>
<empty-line></empty-line><p>Итак, в результате сложения двух объектов Money должен получиться объект класса Sum:</p>
<empty-line></empty-line><p>public void testPlusReturnsSum() {</p>
<p>Money five = Money.dollar(5);</p>
<p>Expression result = five.plus(five);</p>
<p>Sum sum = (Sum) result;</p>
<p>assertEquals(five, sum.augend);</p>
<p>assertEquals(five, sum.addend);</p>
<p>}</p>
<empty-line></empty-line><p>(Вы когда-нибудь слышали, что в английском языке первое слагаемое обозначается термином <emphasis>augend</emphasis>, а второе слагаемое – термином <emphasis>addend</emphasis>? Об этом не слышал даже автор до тех пор, пока не приступил к написанию данной книги.)</p>
<p>Только что написанный тест, скорее всего, проживет недолго. Дело в том, что он сильно связан с конкретной реализацией разрабатываемой нами операции и мало связан с видимым внешним поведением этой операции. Однако, заставив его работать, мы окажемся на шаг ближе к поставленной цели. Чтобы скомпилировать тест, нам потребуется класс Sum с двумя полями: augend и addend:</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>class Sum {</p>
<p>Money augend;</p>
<p>Money addend;</p>
<p>}</p>
<empty-line></empty-line><p>В результате получаем исключение преобразования классов (ClassCastException) – метод Money.plus() возвращает объект Money, но не объект Sum:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>Expression plus(Money addend) {</p>
<p>return new Sum(this, addend);</p>
<p>}</p>
<empty-line></empty-line><p>Класс Sum должен иметь конструктор:</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>Sum(Money augend, Money addend) {</p>
<p>}</p>
<empty-line></empty-line><p>Кроме того, класс Sum должен поддерживать интерфейс Expression:</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>class Sum implements Expression</p>
<empty-line></empty-line><p>Наша система компилируется, однако тесты терпят неудачу – это из-за того, что конструктор класса Sum не присваивает значений полям (мы могли бы создать «поддельную» реализацию, инициализировав поля константами, однако я обещал двигаться быстрее):</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>Sum(Money augend, Money addend) {</p>
<p>this.augend = augend;</p>
<p>this.addend = addend;</p>
<p>}</p>
<empty-line></empty-line><p>Теперь в метод Bank.reduce() передается объект класса Sum. Если суммируются две одинаковые валюты и целевая валюта совпадает с валютой обоих слагаемых, значит, результатом будет объект класса Money, чье значение будет равно сумме значений двух слагаемых:</p>
<empty-line></empty-line><p>public void testReduceSum() {</p>
<p>Expression sum = new Sum(Money.dollar(3), Money.dollar(4));</p>
<p>Bank bank = new Bank();</p>
<p>Money result = bank.reduce(sum, "USD");</p>
<p>assertEquals(Money.dollar(7), result);</p>
<p>}</p>
<empty-line></empty-line><p>Я тщательно выбираю значения параметров так, чтобы нарушить работу существующего теста. Когда мы приводим (метод reduce()) объект класса Sum к некоторой валюте, в результате (с учетом упомянутых упрощенных условий) должен получиться объект класса Money, чье значение (amount) совпадает с суммой значений двух объектов Money, переданных конструктору объекта Sum, а валюта (currency) совпадает с валютой обоих этих объектов:</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>Money reduce(Expression source, String to) {</p>
<p>Sum sum = (Sum) source;</p>
<p>int amount = sum.augend.amount + sum.addend.amount;</p>
<p>return new Money(amount, to);</p>
<p>}</p>
<empty-line></empty-line><p>Код выглядит уродливо по двум причинам:</p>
<p>• мы выполняем приведение к типу Sum, в то время как код должен работать с любым объектом типа Expression;</p>
<p>• мы используем общедоступные поля и два уровня ссылок на поля объектов.</p>
<p>Это достаточно легко исправить. Вначале переместим тело метода в класс Sum и благодаря этому избавимся от лишнего уровня ссылок:</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>Money reduce(Expression source, String to) {</p>
<p>Sum sum = (Sum) source;</p>
<p>return sum.reduce(to);</p>
<p>}</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>public Money reduce(String to) {</p>
<p>int amount = augend.amount + addend.amount;</p>
<p>return new Money(amount, to);</p>
<p>}</p>
<empty-line></empty-line><p>На секундочку заглянем в будущее. Приведение (reduce) суммы к некоторой валюте не может быть выполнено, если объект Sum не знает об обменном курсе. Однако обменный курс хранится в классе Bank, значит, скорее всего, в будущем нам потребуется передавать в метод Sum.reduce() еще один параметр типа Bank. Однако сейчас наш код не требует этого. Поэтому мы не добавляем никаких лишних параметров, чтобы лишний раз в них не путаться. (Что касается меня, то искушение было столь велико, что я все-таки добавил этот параметр, когда в первый раз писал данный код, – мне очень, очень стыдно.)</p>
<empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strong>$5 + $5 = $10</strong></p>
<p>Операция $5 + $5 возвращает объект Money</p>
<p>Bank.reduce(Money)</p>
<empty-line></empty-line><p>Так, а что же происходит в случае, если аргументом метода Bank.reduce() является объект Money?</p>
<p>Давайте напишем тест, слава богу, перед нами зеленая полоса и мы не видим каких-либо других очевидных способов модификации кода:</p>
<empty-line></empty-line><p>public void testReduceMoney() {</p>
<p>Bank bank = new Bank();</p>
<p>Money result = bank.reduce(Money.dollar(1), "USD");</p>
<p>assertEquals(Money.dollar(1), result);</p>
<p>}</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>Money reduce(Expression source, String to) {</p>
<p>if (source instanceof Money) return (Money) source;</p>
<p>Sum sum= (Sum) source;</p>
<p>return sum.reduce(to);</p>
<p>}</p>
<empty-line></empty-line><p>Какой кошмар! Отвратительно! Тем не менее мы получили зеленую полоску и можем приступать к рефакторингу. Прежде всего, вместо прямой проверки класса всегда следует использовать полиморфизм. Класс Sum реализует метод reduce(String), и, если этот метод добавить в класс Money, мы сможем включить reduce(String) в состав интерфейса Expression.</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>Money reduce(Expression source, String to) {</p>
<p>if (source instanceof Money)</p>
<p>return (Money) source.reduce(to);</p>
<p>Sum sum = (Sum) source;</p>
<p>return sum.reduce(to);</p>
<p>}</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>public Money reduce(String to) {</p>
<p>return this;</p>
<p>}</p>
<empty-line></empty-line><p>Включаем метод reduce(String) в состав интерфейса Expression:</p>
<empty-line></empty-line><p><strong>Expression</strong></p>
<p>Money reduce(String to);</p>
<empty-line></empty-line><p>Теперь можно избавиться от этих уродливых операций приведения типа и проверок классов:</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>Money reduce(Expression source, String to) {</p>
<p>return source.reduce(to);</p>
<p>}</p>
<empty-line></empty-line><p>Я не вполне доволен ситуацией, когда в интерфейсе Expression и классе Bank присутствуют методы с одинаковыми именами, но с разным набором параметров. Я так и не смог найти приемлемого решения этой проблемы в Java. В языках, где поддерживаются ключевые параметры, разница между методами Bank.reduce(Expression, String) и Expression.reduce(String) делается очевидной благодаря синтаксису языка. Однако в языках, в которых различие параметров определяется различием их позиций в списке параметров, разница между двумя подобными методами становится менее очевидной.</p>
<empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strong>$5 + $5 = $10</strong></p>
<p>Операция $5 + $5 возвращает объект Money</p>
<p><strikethrough>Bank.reduce(Money)</strikethrough></p>
<p>Приведение объекта Money с одновременной конверсией валют</p>
<p>Reduce(Bank,String)</p>
<empty-line></empty-line><p>Теперь можно приступить к задаче реального обмена одной валюты на другую.</p>
<p>В данной главе мы</p>
<p>• не отметили тест как завершенный, так как не избавились от дублирования;</p>
<p>• чтобы прояснить реализацию, решили двигаться вперед вместо того, чтобы двигаться назад;</p>
<p>• написали тест, чтобы форсировать создание объекта, который, как нам кажется, потребуется в будущем (объект класса Sum);</p>
<p>• ускорили процесс реализации (конструктор класса Sum);</p>
<p>• реализовали код с приведением типов в одном месте, добились успешного выполнения тестов, а затем переместили код туда, где он должен находиться;</p>
<p>• использовали полиморфизм, чтобы избавиться от явной проверки типа (класса).</p>
</section><section><title><p>14. Обмен валюты</p>
</title><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p>$5 + $5 = $10</p>
<p>Операция $5 + $5 возвращает объект Money</p>
<p><strikethrough>Bank.reduce(Money)</strikethrough></p>
<p><strong>Приведение объекта Money с одновременной конверсией валют</strong></p>
<p>Reduce(Bank,String)</p>
<empty-line></empty-line><p>Изменения, перемены, обмены – их объятия заслуживают внимания (особенно если у вас есть книга с фразой в заголовке «в объятиях изменений» (embrace change))<a type="note" l:href="#n_8">[8]</a>. Впрочем, нас заботит простейшая форма обмена – у нас есть два франка и мы хотим получить один доллар. Это звучит как готовый тест:</p>
<empty-line></empty-line><p>public void testReduceMoneyDifferentCurrency() {</p>
<p>Bank bank = new Bank();</p>
<p>bank.addRate("CHF", "USD", 2);</p>
<p>Money result = bank.reduce(Money.franc(2), "USD");</p>
<p>assertEquals(Money.dollar(1), result);</p>
<p>}</p>
<empty-line></empty-line><p>Когда я конвертирую франки в доллары, я просто делю значение на два (мы по-прежнему игнорируем все эти неприятные проблемы, связанные с дробными числами). Чтобы сделать полоску зеленой, мы добавляем в код еще одну уродливую конструкцию:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>public Money reduce(String to) {</p>
<p>int rate = (currency.equals("CHF") &amp;&amp; to.equals("USD"))</p>
<p>? 2</p>
<p>: 1;</p>
<p>return new Money(amount / rate, to);</p>
<p>}</p>
<empty-line></empty-line><p>Получается, что класс Money знает о курсе обмена. Это неправильно. Единственным местом, в котором выполняются любые операции, связанные с курсом обмена, должен быть класс Bank. Мы должны передать параметр типа Bank в метод Expression.reduce(). (Вот видите? Мы так и думали, что нам это потребуется. И мы оказались правы.) Вначале меняем вызывающий код:</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>Money reduce(Expression source, String to) {</p>
<p>return source.reduce(<strong>this</strong>, to);</p>
<p>}</p>
<empty-line></empty-line><p>Затем меняем код реализаций:</p>
<empty-line></empty-line><p><strong>Expression</strong></p>
<p>Money reduce(<strong>Bank bank</strong>, String to);</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>public Money reduce(<strong>Bank bank</strong>, String to) {</p>
<p>int amount = augend.amount + addend.amount;</p>
<p>return new Money(amount, to);</p>
<p>}</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>public Money reduce(<strong>Bank bank</strong>, String to) {</p>
<p>int rate = (currency.equals("CHF") &amp;&amp; to.equals("USD"))</p>
<p>? 2</p>
<p>: 1;</p>
<p>return new Money(amount / rate, to);</p>
<p>}</p>
<empty-line></empty-line><p>Методы должны быть общедоступными (public), так как все методы интерфейсов должны быть общедоступными (я надеюсь, можно не объяснять, почему).</p>
<p>Теперь мы можем вычислить курс обмена внутри класса Bank:</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>int rate(String from, String to) {</p>
<p>return (from.equals("CHF") &amp;&amp; to.equals("USD"))</p>
<p>? 2</p>
<p>: 1;</p>
<p>}</p>
<empty-line></empty-line><p>И обратиться к объекту bank с просьбой предоставить значение курса обмена:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>public Money reduce(Bank bank, String to) {</p>
<p>int rate = bank.rate(currency, to);</p>
<p>return new Money(amount / rate, to);</p>
<p>}</p>
<empty-line></empty-line><p>Эта надоедливая цифра 2 снова отсвечивает как в разрабатываемом коде, так и в теле теста. Чтобы избавиться от нее, мы должны создать таблицу обменных курсов в классе Bank и при необходимости обращаться к этой таблице для получения значения обменного курса. Для этой цели мы могли бы воспользоваться хеш-таблицей, которая ставит в соответствие паре валют соответствующий обменный курс. Можем ли мы в качестве ключа использовать двухэлементный массив, содержащий в себе две валюты? Проверяет ли метод Array.equals() эквивалентность элементов массива?</p>
<empty-line></empty-line><p>public void testArrayEquals() {</p>
<p>assertEquals(new Object[] {"abc"}, new Object[] {"abc"});</p>
<p>}</p>
<empty-line></empty-line><p>Нет. Тест провалился. Придется создавать специальный объект, который будет использоваться в качестве ключа хеш-таблицы:</p>
<empty-line></empty-line><p><strong>Pair</strong></p>
<p>private class Pair {</p>
<p>private String from;</p>
<p>private String to;</p>
<empty-line></empty-line><p>Pair(String from, String to) {</p>
<p>this.from = from;</p>
<p>this.to = to;</p>
<p>}</p>
<p>}</p>
<empty-line></empty-line><p>Мы планируем использовать объекты Pair в качестве ключей, поэтому нам необходимо реализовать методы equals() и hashCode(). Я не собираюсь писать для этого тесты, так как мы разрабатываем код в контексте рефакторинга. Дело в том, что от работоспособности этого кода жестко зависит успешное выполнение существующих тестов. Если код работает неправильно, существующие тесты потерпят неудачу. Однако если бы я программировал в паре с кем-то, кто плохо представлял бы себе направление дальнейшего движения, или если бы логика кода была более сложной, я несомненно приступил бы к разработке специальных тестов.</p>
<empty-line></empty-line><p><strong>Pair</strong></p>
<p>public boolean equals(Object object) {</p>
<p>Pair pair = (Pair) object;</p>
<p>return from.equals(pair.from) &amp;&amp; to.equals(pair.to);</p>
<p>}</p>
<p>public int hashCode() {</p>
<p>return 0;</p>
<p>}</p>
<empty-line></empty-line><p>0 – ужасное хеш-значение, однако такой метод хеширования легко реализовать, стало быть, мы быстрее получим работающий код. Поиск валюты будет осуществляться простым линейным перебором. Позже, когда у нас будет множество валют, мы сможем тщательнее проработать этот вопрос, использовав реальные данные.</p>
<p>Теперь нам нужно место, в котором мы могли бы хранить значения обменных курсов:</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>private Hashtable rates= new Hashtable();</p>
<empty-line></empty-line><p>Нам также потребуется метод добавления нового курса обмена:</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>void addRate(String from, String to, int rate) {</p>
<p>rates.put(new Pair(from, to), new Integer(rate));</p>
<p>}</p>
<empty-line></empty-line><p>И метод, возвращающий обменный курс:</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>int rate(String from, String to) {</p>
<p>Integer rate = (Integer) rates.get(new Pair(from, to));</p>
<p>return rate.intValue();</p>
<p>}</p>
<empty-line></empty-line><p>Подождите-ка минутку! Перед нами красная полоса. Что случилось? Взглянув на код, мы видим, что проблема в неправильном значении курса при обмене доллара на доллары. Мы ожидаем, что при обмене USD на USD курс обмена будет равен 1, однако на текущий момент это не так. Поскольку эта ситуация стала для нас сюрпризом, оформим ее в виде дополнительного теста:</p>
<empty-line></empty-line><p>public void testIdentityRate() {</p>
<p>assertEquals(1, new Bank(). rate("USD", "USD"));</p>
<p>}</p>
<empty-line></empty-line><p>Теперь у нас три ошибки, однако все они могут быть исправлены при помощи одного небольшого изменения:</p>
<empty-line></empty-line><p><strong>Bank</strong></p>
<p>int rate(String from, String to) {</p>
<p><strong>if (from.equals(to)) return 1;</strong></p>
<p>Integer rate = (Integer) rates.get(new Pair(from, to));</p>
<p>return rate.intValue();</p>
<p>}</p>
<empty-line></empty-line><p>Зеленая полоска!</p>
<empty-line></empty-line><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 + $5 = $10</strikethrough></p>
<p>Операция $5 + $5 возвращает объект Money</p>
<p><strikethrough>Bank.reduce(Money)</strikethrough></p>
<p><strikethrough>Приведение объекта Money с одновременной конверсией валют</strikethrough></p>
<p><strikethrough>Reduce(Bank,String)</strikethrough></p>
<empty-line></empty-line><p>Далее мы переходим к нашему последнему, самому большому тесту, $5 + 1 °CHF. В данной главе мы применили несколько важных технологий:</p>
<p>• добавили параметр, который может нам понадобиться;</p>
<p>• удалили дублирование между кодом и тестами;</p>
<p>• написали тест (testArrayEquals), чтобы проверить порядок функционирования встроенной операции Java;</p>
<p>• создали вспомогательный закрытый (private) класс, не обладающий собственными тестами;</p>
<p>• допустили ошибку при рефакторинге и написали еще один тест, чтобы изолировать проблему.</p>
<p>8 Используя игру слов (английское change означает как «изменение», так и «обмен»), автор намекает на свою знаменитую книгу-бестселлер <emphasis>Extreme Programming Explained: Embrace Change</emphasis>. Русский перевод: Бек К. Экстремальное программирование. СПб.: Питер, 2002. 224 с. – <emphasis>Примеч. ред</emphasis>.</p>
</section><section><title><p>15. Смешение валют</p>
</title><p>$5 + 1 °CHF = $10, если курс обмена 2:1</p>
<p><strikethrough>$5 + $5 = $10</strikethrough></p>
<p>Операция $5 + $5 возвращает объект Money</p>
<p><strikethrough>Bank.reduce(Money)</strikethrough></p>
<p><strikethrough>Приведение объекта Money с одновременной конверсией валют</strikethrough></p>
<p><strikethrough>Reduce(Bank,String)</strikethrough></p>
<empty-line></empty-line><p>Теперь мы готовы написать тест, с которого все началось, – $5 + 1 °CHF:</p>
<empty-line></empty-line><p>public void testMixedAddition() {</p>
<p>Expression fiveBucks = Money.dollar(5);</p>
<p>Expression tenFrancs = Money.franc(10);</p>
<p>Bank bank = new Bank();</p>
<p>bank.addRate("CHF", "USD", 2);</p>
<p>Money result = bank.reduce(fiveBucks.plus(tenFrancs), "USD");</p>
<p>assertEquals(Money.dollar(10), result);</p>
<p>}</p>
<empty-line></empty-line><p>Именно такой код нам хотелось бы написать. К сожалению, мы сразу же получаем кучу ошибок компиляции. Обобщая код в процессе перехода от Money к Expression, мы оставили много висящих хвостов, на которые я, конечно же, обратил внимание, но решил вас не беспокоить. Теперь настало время заняться устранением дефектов.</p>
<p>Мы не сможем достаточно быстро обеспечить компиляцию предыдущего теста. Как только мы внесем в код первое изменение, нам потребуется внести в код еще изменения, и так далее. Теперь мы можем двигаться дальше одним из двух путей. Мы можем заставить тест работать быстро, для этого надо написать более специфичный тест и затем выполнить обобщение. Второй путь: довериться компилятору и с его помощью найти все ошибки. Давайте попробуем действовать медленно (на практике я внес бы в код все необходимые изменения за один раз).</p>
<empty-line></empty-line><p>public void testMixedAddition() {</p>
<p>Money fiveBucks = Money.dollar(5);</p>
<p>Money tenFrancs = Money.franc(10);</p>
<p>Bank bank = new Bank();</p>
<p>bank.addRate("CHF", "USD", 2);</p>
<p>Money result = bank.reduce(fiveBucks.plus(tenFrancs), "USD");</p>
<p>assertEquals(Money.dollar(10), result);</p>
<p>}</p>
<empty-line></empty-line><p>Тест терпит неудачу. Мы получаем 15 USD вместо 10 USD. Дело в том, что метод Sum.reduce() не выполняет приведение аргументов:</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>public Money reduce(Bank bank, String to) {</p>
<p>int amount = augend.amount + addend.amount;</p>
<p>return new Money(amount, to);</p>
<p>}</p>
<empty-line></empty-line><p>Если выполнить приведение обоих аргументов, тест должен сработать:</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>public Money reduce(Bank bank, String to) {</p>
<p>int amount= augend.reduce(bank, to). amount</p>
<p>+ addend.reduce(bank, to). amount;</p>
<p>return new Money(amount, to);</p>
<p>}</p>
<empty-line></empty-line><p>И действительно, тест срабатывает. Теперь мы можем заменить тип Money на тип Expression. Чтобы избежать взаимовлияний, мы начнем издалека и будем двигаться в направлении тестирующего кода. Итак, поля augend и addend теперь могут иметь тип Expression:</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>Expression augend;</p>
<p>Expression addend;</p>
<empty-line></empty-line><p>Аргументы конструктора тоже могут иметь тип Expression:</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>Sum(Expression augend, Expression addend) {</p>
<p>this.augend = augend;</p>
<p>this.addend = addend;</p>
<p>}</p>
<empty-line></empty-line><p>(Класс Sum начинает напоминать мне шаблон «Компоновщик» (Composite), однако еще не настолько, чтобы я захотел обобщить его.) С классом Sum, пожалуй, закончили, а что насчет Money?</p>
<p>Аргумент метода plus() может иметь тип Expression:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>Expression plus(Expression addend) {</p>
<p>return new Sum(this, addend);</p>
<p>}</p>
<empty-line></empty-line><p>Метод times() может возвращать значение типа Expression:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>Expression times(int multiplier) {</p>
<p>return new Money(amount * multiplier, currency);</p>
<p>}</p>
<empty-line></empty-line><p>Это означает, что операции plus() и times() должны входить в состав интерфейса Expression. С классом Money закончили. Теперь можно изменить аргументы метода plus() в реализации теста:</p>
<empty-line></empty-line><p>public void testMixedAddition() {</p>
<p>Money fiveBucks = Money.dollar(5);</p>
<p><strong>Expression</strong> tenFrancs = Money.franc(10);</p>
<p>Bank bank = new Bank();</p>
<p>bank.addRate("CHF", "USD", 2);</p>
<p>Money result = bank.reduce(fiveBucks.plus(tenFrancs), "USD");</p>
<p>assertEquals(Money.dollar(10), result);</p>
<p>}</p>
<empty-line></empty-line><p>Объект tenFrancs теперь принадлежит типу Expression, а это значит, что мы должны внести в код некоторые изменения. К счастью, компилятор подсказывает нам, что именно мы должны сделать. Прежде всего вносим изменение:</p>
<empty-line></empty-line><p>public void testMixedAddition() {</p>
<p><strong>Expression</strong> fiveBucks = Money.dollar(5);</p>
<p>Expression tenFrancs = Money.franc(10);</p>
<p>Bank bank = new Bank();</p>
<p>bank.addRate("CHF", "USD", 2);</p>
<p>Money result = bank.reduce(fiveBucks.plus(tenFrancs), "USD");</p>
<p>assertEquals(Money.dollar(10), result);</p>
<p>}</p>
<empty-line></empty-line><p>Компилятор вежливо сообщает, что plus() не является методом интерфейса Expression. Добавим этот метод в интерфейс:</p>
<empty-line></empty-line><p>Expression</p>
<p>Expression plus(Expression addend);</p>
<empty-line></empty-line><p>Теперь мы должны добавить этот метод в классы Money и Sum. Money? Да, этот метод должен быть открытым (public) в классе Money:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>public Expression plus(Expression addend) {</p>
<p>return new Sum(this, addend);</p>
<p>}</p>
<empty-line></empty-line><p>Что касается класса Sum, просто добавим заглушку и отметим необходимость реализации этого метода в списке задач:</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>public Expression plus(Expression addend) {</p>
<p>return null;</p>
<p>}</p>
<p><strikethrough>$5 + 1 °CHF = $10, если курс</strikethrough> <strikethrough>обмена 2:1</strikethrough></p>
<p><strikethrough>$5 + $5 = $10</strikethrough></p>
<p>Операция $5 + $5 возвращает объект Money</p>
<p><strikethrough>Bank.reduce(Money)</strikethrough></p>
<p><strikethrough>Приведение объекта Money с одновременной конверсией валют</strikethrough></p>
<p><strikethrough>Reduce(Bank,String)</strikethrough></p>
<p>Sum.plus</p>
<p>Expression.times</p>
<empty-line></empty-line><p>Теперь программа компилируется и все тесты выполняются успешно.</p>
<p>Мы готовы завершить обобщение класса Money до Expression, но прежде, как всегда, подведем краткий итог. В этой главе мы</p>
<p>• за один шаг написали необходимый тест и затем модифицировали его, чтобы добиться успешного его выполнения;</p>
<p>• выполнили обобщение (использовали более абстрактное объявление);</p>
<p>• воспользовались подсказками компилятора, чтобы внести изменения (Expression fiveBucks), которые привели к необходимости дополнительных изменений (добавление метода plus() в интерфейс Expression и т. п.).</p>
</section><section><title><p>16. Абстракция, наконец-то!</p>
</title><p><strikethrough>$5 + 1 °CHF = $10, если курс обмена 2:1</strikethrough></p>
<p><strikethrough>$5 + $5 = $10</strikethrough></p>
<p>Операция $5 + $5 возвращает объект Money</p>
<p><strikethrough>Bank.reduce(Money)</strikethrough></p>
<p><strikethrough>Приведение объекта Money с одновременной конверсией валют</strikethrough></p>
<p><strikethrough>Reduce(Bank,String)</strikethrough></p>
<p><strong>Sum.plus</strong></p>
<p>Expression.times</p>
<empty-line></empty-line><p>Чтобы завершить добавление метода Expression.plus, мы должны реализовать метод Sum.plus(). Затем нам останется добавить метод Expression.times(), и мы сможем считать пример завершенным. Вот тест для метода Sum.plus():</p>
<empty-line></empty-line><p>public void testSumPlusMoney() {</p>
<p>Expression fiveBucks = Money.dollar(5);</p>
<p>Expression tenFrancs = Money.franc(10);</p>
<p>Bank bank = new Bank();</p>
<p>bank.addRate("CHF", "USD", 2);</p>
<p>Expression sum = new Sum(fiveBucks, tenFrancs). plus(fiveBucks);</p>
<p>Money result = bank.reduce(sum, "USD");</p>
<p>assertEquals(Money.dollar(15), result);</p>
<p>}</p>
<empty-line></empty-line><p>Мы могли бы создать объект Sum путем сложения fiveBucks и tenFrancs, однако приведенный код, который явно создает объект Sum, выглядит более понятным. Ведь мы пишем эти тесты не только ради удовольствия от программирования, но также для того, чтобы будущие поколения программистов могли оценить нашу гениальность. Однако они не смогут сделать этого, если код будет непонятным. Поэтому, разрабатывая любой код, думайте о тех, кто будет его читать.</p>
<p>В данном случае код теста длиннее, чем сам тестируемый код. Код точно такой же, как код в классе Money (кажется, я уже предвижу необходимость создания абстрактного класса):</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>public Expression plus(Expression addend) {</p>
<p>return new Sum(this, addend);</p>
<p>}</p>
<p><strikethrough>$5 + 1 °CHF = $10, если курс обмена 2:1</strikethrough></p>
<p><strikethrough>$5 + $5 = $10</strikethrough></p>
<p>Операция $5 + $5 возвращает объект Money</p>
<p><strikethrough>Bank.reduce(Money)</strikethrough></p>
<p><strikethrough>Приведение объекта Money с одновременной конверсией валют</strikethrough></p>
<p><strikethrough>Reduce(Bank,String)</strikethrough></p>
<p><strikethrough>Sum.plus</strikethrough></p>
<p>Expression.times</p>
<empty-line></empty-line><p>При использовании TDD вы часто будете сталкиваться с тем, что количество строк в тестовом коде будет приблизительно таким же, как и количество строк в тестируемом коде. Чтобы методика TDD обладала экономическим смыслом, вы должны либо записывать в два раза большее количество строк кода, чем обычно, либо реализовывать ту же самую функциональность при помощи количества строк, в два раза меньшего, чем обычно. Эти показатели рекомендуется оценить самостоятельно на примере собственной практики. Однако, выполняя оценку, вы должны принять во внимание время, которое тратится на отладку, интеграцию и объяснение внутреннего устройства другим людям.</p>
<empty-line></empty-line><p><strikethrough>$5 + 1 °CHF = $10, если курс обмена 2:1</strikethrough></p>
<p><strikethrough>$5 + $5 = $10</strikethrough></p>
<p>Операция $5 + $5 возвращает объект Money</p>
<p><strikethrough>Bank.reduce(Money)</strikethrough></p>
<p><strikethrough>Приведение объекта Money с одновременной конверсией валют</strikethrough></p>
<p><strikethrough>Reduce(Bank,String)</strikethrough></p>
<p><strikethrough>Sum.plus</strikethrough></p>
<p><strikethrough>Expression.times</strikethrough></p>
<empty-line></empty-line><p>Если мы получили работающий метод Sum.times(), значит, объявление Expression.times() не составит для нас труда. Вот соответствующий тест:</p>
<empty-line></empty-line><p>public void testSumTimes() {</p>
<p>Expression fiveBucks = Money.dollar(5);</p>
<p>Expression tenFrancs = Money.franc(10);</p>
<p>Bank bank = new Bank();</p>
<p>bank.addRate("CHF", "USD", 2);</p>
<p>Expression sum = new Sum(fiveBucks, tenFrancs). times(2);</p>
<p>Money result = bank.reduce(sum, "USD");</p>
<p>assertEquals(Money.dollar(20), result);</p>
<p>}</p>
<empty-line></empty-line><p>И снова тест получился длиннее тестируемого кода. (Те, кто достаточно много работал с JUnit, должно быть уже догадались, как решить эту проблему. Остальным я рекомендую прочитать раздел «<emphasis>Fixture (Фикстура)</emphasis>» в главе 29, посвященной шаблонам xUnit.)</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>Expression times(int multiplier) {</p>
<p>return new Sum(augend.times(multiplier), addend.times(multiplier));</p>
<p>}</p>
<empty-line></empty-line><p>В предыдущей главе мы изменили тип переменных augend и addend на Expression, поэтому теперь, чтобы скомпилировать код, нам необходимо добавить в интерфейс Expression метод times():</p>
<empty-line></empty-line><p><strong>Expression</strong></p>
<p>Expression times(int multiplier);</p>
<empty-line></empty-line><p>При этом нам следует изменить режим видимости методов Money.times() и Sum.times() (они должны стать общедоступными):</p>
<empty-line></empty-line><p><strong>Sum</strong></p>
<p>public Expression times(int multiplier) {</p>
<p>return new Sum(augend.times(multiplier), addend.times(multiplier));</p>
<p>}</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>public Expression times(int multiplier) {</p>
<p>return new Money(amount * multiplier, currency);</p>
<p>}</p>
<p><strikethrough>$5 + 1 °CHF = $10, если курс обмена 2:1</strikethrough></p>
<p><strikethrough>$5 + $5 = $10</strikethrough></p>
<p>Операция $5 + $5 возвращает объект Money</p>
<p><strikethrough>Bank.reduce(Money)</strikethrough></p>
<p><strikethrough>Приведение объекта Money с одновременной конверсией валют</strikethrough></p>
<p><strikethrough>Reduce(Bank,String)</strikethrough></p>
<p><strikethrough>Sum.plus</strikethrough></p>
<p><strikethrough>Expression.times</strikethrough></p>
<empty-line></empty-line><p>Все заработало.</p>
<empty-line></empty-line><p>Осталось провести эксперимент для случая, когда в результате выполнения операции $5 + $5 получается объект Money. Вот соответствующий тест:</p>
<empty-line></empty-line><p>public void testPlusSameCurrencyReturnsMoney() {</p>
<p>Expression sum = Money.dollar(1). plus(Money.dollar(1));</p>
<p>assertTrue(sum instanceof Money);</p>
<p>}</p>
<empty-line></empty-line><p>Тест выглядит несколько неопрятно, так как тестирует внутреннюю реализацию, а не внешнее поведение объектов. Однако он принуждает нас внести в программу изменения, которые нам необходимы, и, в конце концов, это всего лишь эксперимент. Вот код, который мы должны модифицировать, чтобы заставить тест работать:</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>public Expression plus(Expression addend) {</p>
<p>return new Sum(this, addend);</p>
<p>}</p>
<p><strikethrough>$5 + 1 °CHF = $10, если курс обмена 2:1</strikethrough></p>
<p><strikethrough>$5 + $5 = $10</strikethrough></p>
<p>Операция $5 + $5 возвращает объект Money</p>
<p><strikethrough>Bank.reduce(Money)</strikethrough></p>
<p><strikethrough>Приведение объекта Money с одновременной конверсией валют</strikethrough></p>
<p><strikethrough>Reduce(Bank,String)</strikethrough></p>
<p><strikethrough>Sum.plus</strikethrough></p>
<p><strikethrough>Expression.times</strikethrough></p>
<empty-line></empty-line><p>Не существует очевидного и ясного способа проверить валюту аргумента, если этот аргумент является объектом класса Money (по крайней мере, я не могу найти такого способа, однако вы можете над этим подумать). Эксперимент окончился неудачей, мы удаляем тест (который нам все равно не нравился).</p>
<empty-line></empty-line><p>Подводим итог. Мы</p>
<p>• написали тест так, чтобы его смысл легко был понят другими программистами, которые в будущем будут читать разработанный нами код;</p>
<p>• наметили эксперимент, призванный сравнить эффективность TDD по отношению к обычному стилю программирования, используемому вами на текущий момент;</p>
<p>• снова столкнулись с необходимостью изменения множества объявлений в разрабатываемом коде и снова воспользовались услугами компилятора, чтобы исправить все неточности;</p>
<p>• попробовали провести быстрый эксперимент, однако отказались от идеи, так как она не сработала, и уничтожили соответствующий тест.</p>
</section><section><title><p>17. Ретроспектива денежного примера</p>
</title><p>Давайте еще раз окинем взглядом пример реализации мультивалютных вычислений и попробуем оценить использованный нами подход и полученные результаты. Вот несколько тезисов, которых хотелось бы коснуться:</p>
<p><emphasis> Что дальше?</emphasis> Как определить дальнейшее направление разработки?</p>
<p><emphasis> Метафора</emphasis>. Впечатляющий эффект, который метафора оказывает на структуру дизайна.</p>
<p><emphasis> Использование JUnit</emphasis>. Как часто мы запускали тесты и как мы использовали JUnit?</p>
<p><emphasis> Метрики кода</emphasis>. Численные характеристики получившегося кода.</p>
<p><emphasis> Процесс</emphasis>. Мы говорим: «красный – зеленый – рефакторинг». Как много усилий прикладывается на каждом из этих этапов?</p>
<p><emphasis> Качество тестов</emphasis>. Каким образом характеристики тестов TDD соотносятся с характеристиками обычных методик тестирования?</p>
<subtitle><emphasis><strong>Что дальше?</strong></emphasis></subtitle><p>Можно ли считать код завершенным? Нет. Методы Sum.plus() и Money.plus() во многом дублируют друг друга. Если мы преобразуем интерфейс Expression в класс (не совсем обычное преобразование – чаще классы становятся интерфейсами), мы получим возможность переместить общий код в единый общий метод.</p>
<p>На самом деле мне сложно представить себе код, который полностью завершен. Методику TDD можно использовать как способ приближения к идеалу, однако это будет не самое эффективное ее использование. Если вы имеете дело с крупной системой, тогда части системы, с которыми вы работаете каждый день, должны быть тщательно «вылизаны». Иными словами, дизайн должен быть чистым и понятным, а код должен быть хорошо протестированным. В этом случае вы изо дня в день сможете вносить в систему необходимые изменения, не теряя при этом уверенности в работоспособности кода. Однако на периферии системы, где располагаются части, к которым вы обращаетесь относительно редко, количество тестов может быть меньше, а дизайн – уродливее.</p>
<p>Когда я завершаю решение всех очевидных задач, я люблю запускать инструмент проверки оформления кода (например, SmallLint для Smalltalk). Многие полученные в результате этого предложения мне и без того известны. Со многими предложениями я не согласен. Однако автоматизированный инструмент проверки кода ни о чем не забывает, поэтому иногда он обнаруживает то, что было упущено мною из виду.</p>
<p>Еще один полезный вопрос: «Какие дополнительные тесты необходимо написать для системы?» Иногда кажется, что некоторый тест должен потерпеть неудачу, однако, добавив его в тестовый набор, вы обнаруживаете, что он работает. В этом случае необходимо определить, почему так происходит. Иногда тест, который не должен работать, действительно не работает, и вы добавляете его в набор, как признак известного вам ограничения разрабатываемой системы или как напоминание о работе, которую необходимо выполнить позднее.</p>
<p>Наконец, когда список задач пуст, неплохо еще раз проверить дизайн. Удовлетворяет ли данная реализация всем предъявляемым требованиям? Существует ли дублирование, которое сложно устранить при использовании данного дизайна? (Сохранившееся дублирование – признак нереализованного дизайна.)</p>
<subtitle><emphasis><strong>Метафора</strong></emphasis></subtitle><p>Лично для меня самым большим сюрпризом в данном примере явилось впечатляющее отличие окончательного дизайна от тех разработок, с которыми мне приходилось иметь дело до написания этой книги. Я выполнял разработку аналогичного мультивалютного кода для различных программных систем, реально используемых в производстве, по меньшей мере три раза (насколько я могу припомнить). Кроме того, я использовал эту же задачу для разного рода публикаций еще раз шесть или семь. Помимо публикаций я пятнадцать раз программировал этот пример перед аудиторией на различных конференциях (программировал со сцены – звучит здорово, но выглядит менее впечатляюще). Наконец, прежде чем написать окончательный вариант первой части данной книги, я перебрал три или четыре различных направления разработки кода (я менял направление своих мыслей в соответствии с поступавшими ранними рецензиями и отзывами о написанном материале). И вот, пока я работал над текстом первой части, мне в голову пришла мысль использовать в качестве метафоры <emphasis>математические выражения</emphasis> (expressions). В результате дизайн стал развиваться по совершенно иному, не известному мне ранее пути.</p>
<p>Я никогда не думал, что метафора – это настолько мощный инструмент. Многие думают, что метафора – это всего лишь источник имен. Разве не так? Похоже, что нет.</p>
<p>Для представления «комбинации нескольких денежных величин, которые могут быть выражены в разных валютах», Уорд Каннингэм использовал метафору <emphasis>вектора</emphasis>. Имеется в виду математический вектор – набор коэффициентов, каждому из которых соответствует некоторая валюта. Лично я некоторое время использовал метафору <emphasis>суммы денег</emphasis> (MoneySum), затем придумал <emphasis>денежный мешок</emphasis> (MoneyBag) – звучит понятно и близко к реальности, – наконец, остановился на метафоре <emphasis>бумажника</emphasis> (Wallet). Что такое бумажник и как он функционирует, известно абсолютно всем. Все эти метафоры подразумевают, что набор денежных значений (объектов Money) является плоским. Иначе говоря, выражение 2 USD + 5 CHF + 3 USD эквивалентно выражению 5 USD + 5 CHF. Два значения в одной и той же валюте автоматически сливаются в одно.</p>
<p>Метафора <emphasis>математического выражения</emphasis> избавила меня от множества неприятных проблем, связанных со слиянием дублирующихся валют. Результирующий код получился чище, чем я когда-либо видел. Конечно же, я несколько обеспокоен производительностью кода, основанного на подобной метафоре, однако, прежде чем приступать к оптимизации, я намерен проанализировать статистику обращений к различным участкам кода.</p>
<p>Почему я был вынужден переписать заново то, что я уже писал до этого не меньше 20 раз? Буду ли я и дальше сталкиваться с подобными сюрпризами? Существует ли способ, который позволит мне найти правильное решение, по крайней мере в течение первых трех попыток? А может быть, этот способ позволит мне найти правильное решение с первой попытки?</p>
<subtitle><emphasis><strong>Использование JUnit</strong></emphasis></subtitle><p>Я поручил инфраструктуре JUnit вести журнал в процессе разработки мультивалютного примера. Выяснилось, что за все время я нажал клавишу Enter ровно 125 раз. Оценку интервала между запусками тестов нельзя считать достоверной, так как в ходе работы я не только программировал, но и писал текст книги. Однако когда я занимался только программированием, я запускал тесты приблизительно раз в минуту.</p>
<p>На рис. 17.1 представлена гистограмма интервалов между запусками тестов. Большое количество длительных интервалов, скорее всего, обусловлено тем, что я тратил значительное время на написание текста книги.</p>
<empty-line></empty-line><image l:href="#i_007.png"></image><p><strong>Рис. 17.1.</strong> Гистограмма интервалов времени между запусками тестов</p>
<subtitle><emphasis><strong>Метрики кода</strong></emphasis></subtitle><p>В табл. 17.1 приводятся некоторые статистические данные, характеризующие код.</p>
<empty-line></empty-line><p><strong>Таблица 17.1.</strong> Метрики кода</p>
<image l:href="#i_008.png"></image><empty-line></empty-line><p>Вот некоторые примечания к данной таблице:</p>
<p>1. Мы не реализовали весь программный интерфейс (API) целиком, поэтому не можем достоверно оценить полное количество функций, или количество функций на один класс, или количество строк кода на один класс. Однако соотношения этих параметров можно считать поучительными. Количество функций и количество строк в тестах приблизительно такое же, как и в функциональном коде.</p>
<p>2. Количество строк кода в тестах можно сократить, если извлечь из кода операции подготовки тестовых данных. Однако общее соотношение между строками функционального кода и строками тестирующего кода при этом сохранится.</p>
<p>3. Цикломатическая сложность (cyclomatic complexity) – это величина, характеризующая сложность обычного потока управления в программе. Цикломатическая сложность тестов равна 1, так как в тестирующем коде нет ни ветвлений, ни циклов. Цикломатическая сложность функционального кода близка к единице, так как вместо явных ветвлений для передачи управления чаще используется полиморфизм.</p>
<p>4. Оценка количества строк в функции дана с учетом заголовка функции и закрывающей скобки.</p>
<p>5. Количество строк на функцию для тестирующего кода в нашем случае больше чем могло бы быть, так как мы не выделили общий код в отдельные функции. Об этом рассказывается в главе 29, которая посвящена методам работы с xUnit.</p>
<subtitle><emphasis><strong>Процесс</strong></emphasis></subtitle><p>Цикл TDD выглядит следующим образом:</p>
<p>• написать тест;</p>
<p>• запустить все тесты и убедиться, что добавленный тест терпит неудачу;</p>
<p>• внести в код изменения;</p>
<p>• запустить тесты и убедиться, что все они выполнились успешно;</p>
<p>• выполнить рефакторинг, чтобы устранить дублирование.</p>
<p>Если исходить из того, что разработка теста – это один шаг, какое количество изменений требуется сделать, чтобы выполнить компиляцию, запуск и рефакторинг? (Под изменением я подразумеваю изменение определения метода или класса.) На рис. 17.2 показана гистограмма количества изменений для каждого из тестов «денежного» примера, над которым мы работали в первой части книги.</p>
<empty-line></empty-line><image l:href="#i_009.png"></image><p><strong>Рис. 17.2.</strong> Гистограмма количества изменений, приходящихся на каждый период рефакторинга</p>
<empty-line></empty-line><p>Я полагаю, что если бы мы собирали статистику для достаточно крупного проекта, мы обнаружили бы, что количество изменений, необходимых для компиляции и запуска кода, очень невелико (это количество можно уменьшить, если среда разработки будет понимать, что пытаются ей сказать тесты, и, например, автоматически добавлять в функциональный код необходимые заглушки). Однако количество изменений, вносимых в код во время рефакторинга, должно соответствовать (вот главный тезис) кривой распределения с эксцессом больше нормального, то есть с большим числом изменений, чем предсказывается стандартной кривой нормального распределения. Подобный профиль характерен для многих других естественных процессов, например для изменения стоимости акций на рынке ценных бумаг<a type="note" l:href="#n_9">[9]</a>.</p>
<subtitle><emphasis><strong>Качество тестов</strong></emphasis></subtitle><p>Тесты являются неотъемлемой частью методики TDD. Они могут запускаться в любое время работы над программой, а также после того, как программа будет завершена. Однако не стоит путать их с другими важными типами тестирования:</p>
<p>• тестированием производительности;</p>
<p>• нагрузочным тестированием;</p>
<p>• тестированием удобства использования.</p>
<p>Тем не менее, если плотность вероятности дефектов в коде, разработанном с использованием TDD, невелика, роль профессионального тестирования меняется. Если обычно профессиональное тестирование используется для постоянного надзора за работой программистов, то при использовании TDD профессиональное тестирование больше напоминает вспомогательный инструмент, облегчающий коммуникацию между теми, кто знает, как должна работать система, и теми, кто создает систему.</p>
<p>Как можно оценить качество разработанных нами тестов? Вот два широко распространенных метода:</p>
<p><emphasis>Охват кода</emphasis> (statement coverage). Для оценки качества тестов этой характеристики недостаточно, однако ее можно использовать как отправную точку. Если программист ревностно следует всем требованиям TDD, тесты должны охватывать 100 % кода. Для оценки этой характеристики можно использовать специальные программные средства. Например, программа JProbe (www.sitaka.com/software/jprobe) сообщает нам, что в нашем примере не охваченной тестами осталась всего одна строка в одном методе – Money.toString(). Напомню, что эта строка была добавлена в отладочных целях, фактически она не является функциональным кодом.</p>
<p><emphasis>Намеренное добавление дефекта</emphasis> (defect insertion). Это еще один способ проверки качества тестов. Идея проста: изменить значение строки кода и убедиться, что тест перестал работать. Делать это можно вручную или при помощи специального инструмента, такого как Jester (jester.sourceforge.net). Этот инструмент сообщает нам, что в нашей программе существует всего одна строка, которую можно изменить, не нарушив работы тестов. Вот эта строка: Pair.hashCode(). Здесь мы просто подделали реализацию – вместо хеш-кода метод возвращает постоянное значение: 0. Если одно постоянное значение заменить другим, смысл программы не изменится (одна подделка ничем не лучше другой), поэтому подобную модификацию кода нельзя считать дефектом.</p>
<p>Флип, один из рецензентов моей книги, сообщил мне некоторые дополнительные соображения относительно охвата тестами. Абсолютный показатель охвата вычисляется следующим образом: количество тестов, предназначенных для тестирования различных аспектов программы, необходимо разделить на количество аспектов, которые нуждаются в тестировании (сложность логики программы). Существует два способа улучшить показатель охвата тестами. Во-первых, можно написать больше тестов. Отсюда разница в количестве тестов, которые пишутся разработчиком, использующим TDD, и профессиональным тестером. (В главе 32 приводится пример задачи, для решения которой я написал 6 тестов, а человек, профессионально занимающийся тестированием, – 65 тестов.) Однако существует и другой способ улучшить охват – ограничиться фиксированным набором тестов и упростить логику программы. Подобный эффект зачастую достигается в процессе рефакторинга – условные операторы заменяются сообщениями классов или вовсе удаляются из программы. Флип выражает эту мысль так: «Вместо того чтобы увеличить количество тестов и тем самым охватить всевозможные комбинации входных данных (говоря точнее, эффективное подмножество всех комбинаций), мы оставляем количество тестов неизменным и меняем количество внутренних структурных комбинаций кода».</p>
<subtitle><emphasis><strong>Последний взгляд назад</strong></emphasis></subtitle><p>Существует три важных навыка, которые необходимо освоить тем, кто впервые изучает TDD:</p>
<p>• три основных подхода, которые используются, чтобы заставить тест работать: подделка реализации, триангуляция и очевидная реализация;</p>
<p>• устранение дублирования между функциональным кодом и тестами – важный способ формирования дизайна;</p>
<p>• способность контролировать расстояние между тестами: когда дорога становится скользкой, необходимо двигаться маленькими шажками; когда дальнейший путь ясен, можно увеличить скорость.</p>
</section></section><section><title><p>Часть II</p>
<p>На примере xUnit</p>
</title><section><p>Какой подход использовать при создании инструмента для разработки через тестирование? Естественно, разработку через тестирование.</p>
<p>Архитектура xUnit хорошо реализуется на языке Python, поэтому во второй части книги я перейду на использование Python. Не беспокойтесь, для тех, кто никогда раньше не имел дела с Python, я добавлю в текст необходимые пояснения. Когда вы прочитаете вторую часть, вы, во-первых, освоите базовые навыки программирования на Python, во-вторых, узнаете, как самому разработать свою собственную инфраструктуру для автоматического тестирования, и, в-третьих, ознакомитесь с более сложным примером использования методики TDD – три по цене одного!</p>
</section><section><title><p>18. Первые шаги на пути к xUnit</p>
</title><p>Разработка инструмента тестирования с использованием самого этого инструмента для тестирования многим может показаться чем-то, напоминающим хирургическую операцию на своем собственном мозге. («Только не вздумай трогать центры моторики! О! Слишком поздно! Игра окончена».) Сначала эта идея может показаться жутковатой. Однако инфраструктура тестирования обладает более сложной внутренней логикой, если сравнивать с относительно несложным денежным примером, рассмотренным в первой части книги. Часть II можно рассматривать как шаг в сторону разработки «настоящего» программного обеспечения. Кроме того, вы можете рассматривать этот материал как упражнение в самодокументируемом программировании.</p>
<p>Прежде всего, у нас должна быть возможность создать тест и запустить тестовый метод. Например: TestCase("testMethod"). run(). Возникает проблема: мы собираемся написать тест для программного кода, который мы будем использовать для написания тестов. Так как у нас пока еще нет даже намека на инфраструктуру тестирования, мы вынуждены проверить правильность нашего самого первого шага вручную. К счастью, мы достаточно хорошо отдохнули, а значит, вероятность того, что мы допустим ошибку, относительно невелика. Однако чтобы сделать ее еще меньше, мы планируем двигаться маленькими-маленькими шажками, тщательно проверяя все, что мы делаем. Вот список задач, который приходит на ум, когда начинаешь размышлять о разработке собственной инфраструктуры тестирования:</p>
<empty-line></empty-line><p><strong>Вызов тестового метода</strong></p>
<p>Вызов метода setUp перед обращением к методу</p>
<p>Вызов метода tearDown после обращения к методу</p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p>Выполнение нескольких тестов</p>
<p>Отчет о результатах</p>
<empty-line></empty-line><p>Конечно же, мы по-прежнему работаем в стиле «сначала тесты». Для нашего прототеста нам потребуется небольшая программа, которая должна отображать на экране значение «истина», если произошло обращение к тестовому методу, и значение «ложь» в противном случае. Теперь представим, что у нас есть тест, который устанавливает флаг внутри тестового метода, в этом случае мы могли бы после выполнения теста отобразить состояние флага на экране и самостоятельно убедиться в том, что флаг установлен правильно. Выполнив проверку вручную, мы сможем попробовать автоматизировать процесс.</p>
<p>Итак, у нас наметилась следующая стратегия. Мы создаем объект, который соответствует нашему тесту. В объекте содержится флаг. Перед выполнением тестового метода флаг должен быть установлен в состояние «ложь». Тестовый метод устанавливает флаг в состояние «истина». После выполнения тестового метода мы должны проверить состояние флага. Назовем наш тестовый класс именем WasRun<a type="note" l:href="#n_10">[10]</a>, так как объект этого класса будет сигнализировать нам о том, был ли выполнен тестовый метод. Флаг внутри этого класса также будет называться wasRun (это несколько сбивает с толку, однако wasRun – такое подходящее имя). Собственно объект (экземпляр класса WasRun) будет называться просто test. То есть мы сможем написать инструкцию assert test.wasRun (assert – встроенная инструкция языка Python).</p>
<p>Язык программирования Python является интерпретируемым – команды исполняются по мере чтения их из файла с исходным кодом. Поэтому, чтобы выполнить тестирование, мы можем написать следующий короткий файл и попробовать запустить его:</p>
<empty-line></empty-line><p>test = WasRun(«testMethod»)</p>
<p>print(test.wasRun)</p>
<p>test.testMethod()</p>
<p>print(test.wasRun)</p>
<empty-line></empty-line><p>Мы ожидаем, что эта миниатюрная программа напечатает None до выполнения тестового метода и 1 – после. (В языке Python значение None является аналогом null или nil и наряду с числом 0 соответствует значению «ложь».) Однако программа не делает того, что мы от нее ждем. И немудрено – мы еще не определили класс WasRun (сначала тесты!).</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>class WasRun:</p>
<p>pass</p>
<empty-line></empty-line><p>(Ключевое слово pass используется в случае, если реализация класса или метода отсутствует.) Теперь интерпретатор сообщает нам, что в классе WasRun нет атрибута с именем wasRun. Создание атрибута происходит в момент создания объекта (экземпляра класса), то есть в процессе выполнения конструктора (для удобства конструктор любого класса называется __init__). Внутри конструктора мы присваиваем флагу wasRun значение None (ложь):</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>class WasRun:</p>
<p>def __init__(self, name):</p>
<p>self.wasRun = None</p>
<empty-line></empty-line><p>Теперь программа действительно отображает на экране значение None, однако после этого интерпретатор сообщает нам, что мы должны определить в классе WasRun метод testMethod. (Было бы неплохо, если бы среда разработки автоматически реагировала на это: самостоятельно создавала бы функцию-заглушку и открывала редактор с курсором, установленным в теле этой функции. Не правда ли, это было бы просто здорово? Кстати, некоторые производители IDE уже додумались до этого.)</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>def testMethod(self):</p>
<p>pass</p>
<empty-line></empty-line><p>Запускаем файл и видим на экране два значения: None и None<a type="note" l:href="#n_11">[11]</a>. Нам хотелось бы видеть None и 1. Чтобы получить желаемый результат, в теле метода testMethod присвоим флагу wasRun желаемое значение:</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>def testMethod(self):</p>
<p>self.wasRun = 1</p>
<empty-line></empty-line><p>Запускаем программу – то, что нужно! Мы получили желаемый результат. Зеленая полоса – ур-р-ра! Нам предстоит сложный рефакторинг, однако если мы видим перед собой зеленую полосу, значит, мы добились прогресса.</p>
<p>Теперь, вместо того чтобы напрямую обращаться к нашему тестовому методу, мы должны использовать наш реальный интерфейс – метод run(). Изменим тест следующим образом:</p>
<empty-line></empty-line><p>test= WasRun(«testMethod»)</p>
<p>print(test.wasRun)</p>
<p>test.run()</p>
<p>print(test.wasRun)</p>
<empty-line></empty-line><p>Чтобы заставить тест работать, достаточно воспользоваться следующей несложной реализацией:</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>def run(self):</p>
<p>self.testMethod()</p>
<empty-line></empty-line><p>Наша тестовая программа снова печатает на экране то, что нам нужно. Зачастую во время рефакторинга возникает ощущение, что необходимо разделить код, с которым вы работаете, на две части, чтобы работать с ними по отдельности. Если в конце работы они снова сольются воедино, – замечательно. Если нет, значит, вы можете оставить их отдельно друг от друга. В данном случае со временем мы планируем создать класс TestCase, однако вначале мы должны обособить части нашего примера.</p>
<p>Следующий этап – динамический вызов метода testMethod. Одной из приятных отличительных характеристик языка Python является возможность использования имен классов и методов в качестве функций (см. создание экземпляра класса WasRun). Получив атрибут, соответствующий имени теста, мы можем обратиться к нему, как к функции. В результате будет выполнено обращение к методу с соответствующим именем<a type="note" l:href="#n_12">[12]</a>.</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>class WasRun:</p>
<p>def __init__(self, name):</p>
<p>self.wasRun = None</p>
<p>self.name = name</p>
<p>def run(self):</p>
<p>method = getattr(self, self.name)</p>
<p>method()</p>
<empty-line></empty-line><p>Это еще один шаблон рефакторинга: разработать код, который работает с некоторым конкретным экземпляром, и обобщить его, чтобы он мог работать со всеми остальными экземплярами, для этого константы заменяются переменными. В данном случае роль константы играет не некоторое значение, а фиксированный код (имя конкретного метода). Однако принцип остается тем же. В рамках TDD эта проблема решается очень легко: методика TDD снабжает вас конкретными работающими примерами, исходя из которых можно выполнить обобщение. Это значительно проще, чем выполнять обобщение исходя только из собственных умозаключений.</p>
<p>Теперь наш маленький класс WasRun занят решением двух разных задач: во-первых, он следит за тем, был ли выполнен метод; во-вторых, он динамически вызывает метод. Пришло время разделить полномочия (разделить нашу работу на две разные части). Прежде всего, создадим пустой суперкласс TestCase и сделаем класс WasRun производным классом:</p>
<empty-line></empty-line><p><strong>TestCase</strong></p>
<p>class TestCase:</p>
<p>pass</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>class WasRun(TestCase):.</p>
<empty-line></empty-line><p>Теперь переместим атрибут name из подкласса в суперкласс:</p>
<empty-line></empty-line><p><strong>TestCase</strong></p>
<p>def __init__(self, name):</p>
<p>self.name = name</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>def __init__(self, name):</p>
<p>self.wasRun = None</p>
<p>TestCase.__init__(self, name)</p>
<empty-line></empty-line><p>Наконец, замечаем, что метод run() использует только атрибуты суперкласса, значит, скорее всего, он должен располагаться в суперклассе. (Я всегда стараюсь размещать операции рядом с данными.)</p>
<empty-line></empty-line><p><strong>TestCase</strong></p>
<p>def __init__(self, name):</p>
<p>self.name= name</p>
<p>def run(self):</p>
<p>method = getattr(self, self.name)</p>
<p>method()</p>
<empty-line></empty-line><p>Естественно, между выполнениями этих модификаций я каждый раз запускаю тесты, чтобы убедиться, что все работает как надо.</p>
<p>Нам надоело смотреть на то, как наша программа каждый раз печатает одно и то же: None и 1. Использовав разработанный механизм, мы можем теперь написать:</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>class TestCaseTest(TestCase):</p>
<p>def testRunning(self):</p>
<p>test = WasRun("testMethod")</p>
<p>assert(not test.wasRun)</p>
<p>test.run()</p>
<p>assert(test.wasRun)</p>
<p>TestCaseTest("testRunning"). run()</p>
<empty-line></empty-line><p><strikethrough>Вызов тестового метода</strikethrough></p>
<p>Вызов метода setUp перед обращением к методу</p>
<p>Вызов метода tearDown после обращения к методу</p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p>Выполнение нескольких тестов</p>
<p>Отчет о результатах</p>
<empty-line></empty-line><p>Сердцем этого теста являются операторы print, превращенные в выражения assert, таким образом, вы можете видеть, что выполненная нами процедура – это усложненный шаблон рефакторинга «Выделение метода» (Extract Method).</p>
<p>Я открою вам маленький секрет. Шажки, которыми мы двигались от теста к тесту в данной главе, выглядят смехотворно маленькими. Однако до того, как получить представленный результат, я пытался выполнить разработку более крупными шагами и потратил на это около шести часов (конечно, мне пришлось тратить дополнительное время на изучение тонкостей языка Python). Я два раза начинал с нуля и каждый раз думал, что мой код сработает, однако этого не происходило. Я понял, что попытка пропустить самый начальный, самый примитивный этап разработки, – это грубейшее нарушение принципов TDD.</p>
<p>Конечно же, вы не обязаны постоянно перемещаться такими лилипутскими шажками. После того как вы освоите TDD, вы сможете двигаться вперед более уверенно, реализуя между тестами значительно больший объем функциональности. Однако чтобы в совершенстве освоить TDD, вы должны научиться перемещаться маленькими шажками тогда, когда это необходимо.</p>
<p>Далее мы планируем перейти к решению задачи обращения к методу setUp(). Однако вначале подведем итог.</p>
<p>В данной главе мы</p>
<p>• поняли, как начать работу со смехотворно малюсенького шага;</p>
<p>• реализовали функциональность путем создания фиксированного кода, а затем обобщения этого кода путем замены констант на переменные;</p>
<p>• использовали шаблон «Встраиваемый переключатель» (Pluggable Selector) и дали себе обещание не использовать его вновь в течение как минимум четырех месяцев, так как он существенно усложняет анализ кода;</p>
<p>• начали работу над инфраструктурой тестирования маленькими шажками.</p>
</section><section><title><p>19. Сервируем стол (метод setUp)</p>
</title><p>Начав писать тесты, вы обнаружите, что действуете в рамках некоторой общей последовательности (Билл Уэйк (Bill Wake) придумал сокращение 3A – <emphasis>Arrange, Act, Assert</emphasis>):</p>
<p>• вначале вы создаете некоторые тестовые объекты – <emphasis>Arrange</emphasis>;</p>
<p>• затем заставляете эти объекты действовать – <emphasis>Act</emphasis>;</p>
<p>• потом проверяете результаты их работы – <emphasis>Assert</emphasis>.</p>
<empty-line></empty-line><p><strikethrough>Вызов тестового метода</strikethrough></p>
<p><strong>Вызов метода setUp перед обращением к методу</strong></p>
<p>Вызов метода tearDown после обращения к методу</p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p>Выполнение нескольких тестов</p>
<p>Отчет о результатах</p>
<empty-line></empty-line><p>Первый этап – <emphasis>Arrange</emphasis> – зачастую совпадает для нескольких разных тестов, в то время как второй и третий этапы для разных тестов различаются. У меня есть два числа: 7 и 9. Если я сложу их, я должен получить 16; если я вычту второе из первого, я ожидаю получить –2; наконец, если я перемножу их, я полагаю, должно получиться 63. Операции и ожидаемые результаты различаются, однако исходные данные одни и те же – два числа: 7 и 9.</p>
<p>Если подобное повторяется раз за разом в разных масштабах (а ведь так оно и есть), мы должны подумать о том, как можно оптимизировать создание тестовых объектов. Возникает конфликт между следующими двумя ограничениями:</p>
<p><emphasis> Производительность</emphasis>. Мы хотим, чтобы тесты срабатывали как можно быстрее. Отсюда следует, что если одни и те же объекты используются в нескольких тестах, желательно, чтобы создание этих объектов выполнялось всего один раз.</p>
<p><emphasis> Изоляция</emphasis>. Успех или неудача одного теста никак не должны влиять на работу других тестов. Если несколько тестов используют одни и те же объекты и если один из тестов меняет внутреннее состояние какого-либо объекта, результаты работы остальных тестов, скорее всего, изменятся.</p>
<p>Взаимозависимость между тестами приводит к одному весьма неприятному эффекту: если один тест перестает работать, остальные десять тестов тоже перестают работать, несмотря на то, что тестируемый ими код выполняется правильно. Характерен также и другой, еще более неприятный эффект, когда порядок выполнения тестов имеет значение: если я запускаю тест A перед тестом Б, оба теста выполняются успешно, если я запускаю тест Б перед тестом А, тест А не выполняется. Или, еще хуже, код, проверяемый тестом Б, действует неправильно, однако из-за того, что тест А запускается перед тестом Б, тест Б выполняется успешно.</p>
<p>Итак, мы хотим избежать взаимозависимости между тестами. Предположим, что мы можем сделать процедуру создания объектов достаточно быстрой. В этом случае мы могли бы создавать объекты для теста каждый раз перед выполнением очередного теста. Этот подход в замаскированном виде уже использовался нами в классе WasRun, в котором требовалось, чтобы перед запуском теста флаг wasRun сбрасывался в состояние «ложь». Напишем тест:</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def testSetUp(self):</p>
<p>test= WasRun("testMethod")</p>
<p>test.run()</p>
<p>assert(test.wasSetUp)</p>
<empty-line></empty-line><p>Чтобы запустить этот код, необходимо добавить в конец нашего файла строку TestCaseTest(«testSetUp»). run(). Интерпретатор вежливо сообщает нам, что атрибут с именем wasSetUp отсутствует. И немудрено, ведь мы пока еще не определили значение этого атрибута. Вот необходимый для этого код:</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>def setUp(self):</p>
<p>self.wasSetUp= 1</p>
<empty-line></empty-line><p>Однако метод setUp() должен быть откуда-то вызван. Обращение к методу setUp() – это работа класса TestCase. Добавим соответствующий код:</p>
<empty-line></empty-line><p><strong>TestCase</strong></p>
<p>def setUp(self):</p>
<p>pass</p>
<p>def run(self):</p>
<p>self.setUp()</p>
<p>method = getattr(self, self.name)</p>
<p>method()</p>
<empty-line></empty-line><p>Чтобы заставить тест работать, мы сделали целых два шага – это слишком много, особенно если учесть, что мы движемся почти вслепую. Проверим, работает ли тест? Да, работает. Однако если вы хотите чему-то научиться, попробуйте придумать, как мы можем заставить тест работать, изменяя лишь по одному методу за один шаг.</p>
<p>Немедленно воспользуемся новым механизмом, чтобы сократить длину наших тестов. Прежде всего упростим класс WasRun, для этого перенесем процедуру установки флага wasRun в метод setUp():</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>def setUp(self):</p>
<p>self.wasRun = None</p>
<p>self.wasSetUp = 1</p>
<p>Теперь можно упростить метод testRunning() – освободить его от</p>
<p>обязанности проверять состояние флага перед вызовом тестового метода. Можем ли мы быть настолько уверенными в правильной работе нашего кода? Только при условии, что в наборе тестов присутствует тестовый метод testSetUp(). Это часто встречающийся шаблон – один тест может быть простым, только если в системе имеется другой тест, выполняющийся успешно:</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def testRunning(self):</p>
<p>test = WasRun("testMethod")</p>
<p>test.run()</p>
<p>assert(test.wasRun)</p>
<empty-line></empty-line><p>Мы также можем упростить сами тесты. В обоих случаях мы создаем экземпляр класса WasRun, а ведь задача создания тестовых объектов возлагается на подготовительный этап – именно об этом мы с вами говорили. Стало быть, мы можем создать объект WasRun в методе setUp(), а затем использовать его в тестовых методах. Каждый тестовый метод выполняется в отдельном экземпляре класса TestCaseTest, поэтому два разных теста не могут быть взаимозависимы. (Мы исходим из того, что объект не будет взаимодействовать с внешним миром некоторым непредусмотренным уродливым способом, например путем изменения значений глобальных переменных.)</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def setUp(self):</p>
<p>self.test = WasRun("testMethod")</p>
<p>def testRunning(self):</p>
<p>self.test.run()</p>
<p>assert(self.test.wasRun)</p>
<p>def testSetUp(self):</p>
<p>self.test.run()</p>
<p>assert(self.test.wasSetUp)</p>
<empty-line></empty-line><p><strikethrough>Вызов тестового метода</strikethrough></p>
<p><strikethrough>Вызов метода setUp перед обращением к методу</strikethrough></p>
<p>Вызов метода tearDown после обращения к методу</p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p>Выполнение нескольких тестов</p>
<p>Отчет о результатах</p>
<empty-line></empty-line><p>Теперь сделаем так, чтобы после выполнения тестового метода обязательно выполнялся метод tearDown().</p>
<p>В данной главе мы</p>
<p>• решили, что на текущий момент тестов важнее простота, чем их производительность;</p>
<p>• написали тест для метода setUp() и реализовали этот метод;</p>
<p>• использовали метод setUp(), чтобы упростить тестируемый объект-контейнер теста;</p>
<p>• использовали метод setUp(), чтобы упростить тесты, проверяющие созданный нами тестовый объект (я же говорил, что временами это напоминает нейрохирургическую операцию на собственном мозге).</p>
</section><section><title><p>20. Убираем со стола (метод tearDown)</p>
</title><p><strikethrough>Вызов тестового метода</strikethrough></p>
<p><strikethrough>Вызов метода setUp перед обращением к методу</strikethrough></p>
<p><strong>Вызов метода tearDown после обращения к методу</strong></p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p>Выполнение нескольких тестов</p>
<p>Отчет о результатах</p>
<empty-line></empty-line><p>Иногда для выполнения теста требуется выделить некоторые внешние ресурсы. Очевидно, что связанные с этим операции должны выполняться в теле метода setUp(). Если мы хотим, чтобы тесты были независимыми друг от друга, мы должны позаботиться об освобождении этих ресурсов. Для выполнения связанных с этим операций предлагаю использовать специальный метод tearDown(), который будет автоматически выполняться после завершения теста.</p>
<p>Как можно протестировать выполнение метода tearDown()? Проще всего – использовать еще один флаг. Однако все эти флаги начинают сбивать меня с толку. Если мы будем использовать флаги, мы упустим один очень важный аспект: метод setUp() должен быть выполнен непосредственно перед обращением к тестовому методу, а метод tearDown() – непосредственно после обращения к тестовому методу. Чтобы убедиться в этом, я намерен изменить стратегию тестирования. Предлагаю создать миниатюрный журнал, в котором будет отмечаться последовательность выполнения методов. Каждый метод будет добавлять в конец журнала соответствующую запись. Таким образом, просмотрев журнал, мы сможем установить порядок выполнения методов.</p>
<empty-line></empty-line><p><strikethrough>Вызов тестового метода</strikethrough></p>
<p><strikethrough>Вызов метода setUp перед обращением к методу</strikethrough></p>
<p>Вызов метода tearDown после обращения к методу</p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p>Выполнение нескольких тестов</p>
<p>Отчет о результатах</p>
<p><strong>Строка журнала в классе WasRun</strong></p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>def setUp(self):</p>
<p>self.wasRun = None</p>
<p>self.wasSetUp = 1</p>
<p>self.log = "setUp "</p>
<empty-line></empty-line><p>Теперь можно изменить метод testSetUp(), чтобы вместо флага он проверял содержимое журнала:</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def testSetUp(self):</p>
<p>self.test.run()</p>
<p>assert("setUp " == self.test.log)</p>
<empty-line></empty-line><p>После этого мы можем удалить флаг wasSetUp. Мы также можем добавить в журнал запись о выполнении метода:</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>def testMethod(self):</p>
<p>self.wasRun = 1</p>
<p>self.log = self.log + "testMethod "</p>
<empty-line></empty-line><p>В результате нарушается работа теста testSetUp(), так как в момент выполнения этого метода журнал содержит строку «setUp testMethod». Изменяем ожидаемое значение:</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def testSetUp(self):</p>
<p>self.test.run()</p>
<p>assert("setUp testMethod " == self.test.log)</p>
<empty-line></empty-line><p>Теперь этот тест выполняет работу обоих тестов, поэтому можно удалить testRunning и переименовать testSetUp:</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def setUp(self):</p>
<p>self.test = WasRun("testMethod")</p>
<p>def testTemplateMethod(self):</p>
<p>self.test.run()</p>
<p>assert("setUp testMethod " == self.test.log)</p>
<empty-line></empty-line><p>Мы используем экземпляр класса WasRun всего в одном месте, поэтому необходимо отменить добавленный ранее хитрый трюк, связанный с setUp():</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def testTemplateMethod(self):</p>
<p>test = WasRun("testMethod")</p>
<p>test.run()</p>
<p>assert("setUp testMethod " == test.log)</p>
<empty-line></empty-line><p>Нет ничего страшного в том, что мы сделали рефакторинг, исходя из нескольких ранних соображений, а чуть позже отменили его, – подобная ситуация складывается достаточно часто. Некоторые предпочитают подождать, пока у них накопится достаточное количество оснований для рефакторинга, иными словами, они оттягивают выполнение рефакторинга, чтобы быть полностью уверенными в его необходимости. Они поступают так потому, что не любят аннулировать результаты проделанной работы. Однако я предпочитаю не отвлекаться на рассуждения о том, не придется ли в будущем отменять то или иное исправление, необходимое мне в настоящем. Вместо этого я предпочитаю сосредоточиться на дизайне. По этой причине я рефлекторно делаю рефакторинг тогда, когда считаю нужным, ни капли не опасаясь, что сразу после этого мне, возможно, придется отменить его.</p>
<empty-line></empty-line><p><strikethrough>Вызов тестового метода</strikethrough></p>
<p><strikethrough>Вызов метода setUp перед обращением к методу</strikethrough></p>
<p>Вызов метода tearDown после обращения к методу</p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p>Выполнение нескольких тестов</p>
<p>Отчет о результатах</p>
<p><strikethrough>Строка журнала в классе WasRun</strikethrough></p>
<empty-line></empty-line><p>Теперь мы готовы к реализации метода tearDown(). Ага! Опять я вас поймал! Теперь мы готовы к тестированию метода tearDown():</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def testTemplateMethod(self):</p>
<p>test = WasRun("testMethod")</p>
<p>test.run()</p>
<p>assert("setUp testMethod tearDown " == test.log)</p>
<empty-line></empty-line><p>Он потерпел неудачу. Чтобы заставить его работать, выполняем несложные добавления:</p>
<empty-line></empty-line><p><strong>TestCase</strong></p>
<p>def run(self, result):</p>
<p>result.testStarted()</p>
<p>self.setUp()</p>
<p>exec "self." + self.name + "()"</p>
<p>self.tearDown()</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>def setUp(self):</p>
<p>self.log = "setUp "</p>
<p>def testMethod(self):</p>
<p>self.log = self.log + "testMethod "</p>
<p>def tearDown(self):</p>
<p>self.log = self.log + "tearDown "</p>
<empty-line></empty-line><p>Неожиданно мы получаем ошибку не в классе WasRun, а в классе TestCaseTest. У нас нет «пустой» реализации метода teardown() в классе TestCase:</p>
<empty-line></empty-line><p><strong>TestCase</strong></p>
<p>def tearDown(self):</p>
<p>pass</p>
<empty-line></empty-line><p>Мы начинаем получать пользу от разрабатываемой инфраструктуры. Замечательно! Никакого рефакторинга не требуется. Очевидная реализация, созданная нами после обнаружения ошибки, сработала, и код получился чистым.</p>
<empty-line></empty-line><p><strikethrough>Вызов тестового метода</strikethrough></p>
<p><strikethrough>Вызов метода setUp перед обращением к методу</strikethrough></p>
<p><strikethrough>Вызов метода tearDown после обращения к методу</strikethrough></p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p>Выполнение нескольких тестов</p>
<p>Отчет о результатах</p>
<p><strikethrough>Строка журнала в классе WasRun</strikethrough></p>
<empty-line></empty-line><p>Далее мы перейдем к формированию отчета о результатах выполнения тестов. Вместо использования встроенного в Python механизма обработки ошибок мы планируем реализовать и использовать собственный механизм наблюдения за работой тестов.</p>
<p>В данной главе мы</p>
<p>• перешли от использования флагов к использованию журнала;</p>
<p>• создали тесты для метода tearDown() и реализовали этот метод с использованием нового механизма журналирования;</p>
<p>• обнаружили проблему и вместо того чтобы возвращаться назад, смело исправили ошибку.</p>
</section><section><title><p>21. Учет и контроль</p>
</title><p><strikethrough>Вызов тестового метода</strikethrough></p>
<p><strikethrough>Вызов метода setUp перед обращением к методу</strikethrough></p>
<p><strikethrough>Вызов метода tearDown после обращения к методу</strikethrough></p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p>Выполнение нескольких тестов</p>
<p><strong>Отчет о результатах</strong></p>
<p><strikethrough>Строка журнала в классе WasRun</strikethrough></p>
<empty-line></empty-line><p>Метод tearDown() должен выполняться, даже когда в процессе выполнения теста возникло исключение. Однако чтобы добиться этого, мы должны перехватывать исключения. (Честно говоря, я уже пытался реализовать это, но у меня не получилось, и я вернул все на свои места.) Если при реализации перехвата исключений мы допустим ошибку, мы можем не заметить этого, так как стандартный механизм доклада об исключениях не будет функционировать.</p>
<p>Работая в стиле TDD, важно понимать, что особое значение имеет порядок, в котором вы реализуете тесты. Выбирая тест, над которым я буду работать дальше, я стараюсь выбрать тот, который, во-первых, послужит для меня источником новых знаний, а во-вторых, достаточно прост, чтобы я был уверен в том, что могу заставить его работать. Если я добиваюсь успешного выполнения этого теста, но захожу в тупик при реализации следующего, я вполне могу выполнить откат назад на два шага. Было бы неплохо, если бы среда разработки оказывала мне в этом помощь. Например, было бы неплохо, если бы в момент срабатывания всех тестов автоматически создавалась резервная копия всего исходного кода, с которым я работаю.</p>
<p>После выполнения всех тестов желательно получить информацию о том, как они выполнились, например: «запущено 5, неудачных 2: TestCaseTest.testFooBar – ZeroDivideException, MoneyTest.testNegation – AssertionError». Если тесты перестают выполняться или результаты перестают отображаться на экране мы, по крайней мере, сможем обнаружить ошибку. Однако наша инфраструктура не обязана знать обо всех разработанных тестах.</p>
<p>Пусть метод TestCase.run() возвращает объект класса TestResult с результатами выполнения теста (вначале тест будет только один, однако позже мы усовершенствуем этот объект).</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def testResult(self):</p>
<p>test = WasRun("testMethod")</p>
<p>result = test.run()</p>
<p>assert("1 run, 0 failed" == result.summary())</p>
<empty-line></empty-line><p>Начнем с поддельной реализации:</p>
<empty-line></empty-line><p><strong>TestResult</strong></p>
<p>class TestResult:</p>
<p>def summary(self):</p>
<p>return "1 run, 0 failed"</p>
<empty-line></empty-line><p>Теперь сделаем так, чтобы в результате выполнения метода TestCase.run() возвращался объект класса TestResult:</p>
<empty-line></empty-line><p><strong>TestCase</strong></p>
<p>def run(self):</p>
<p>self.setUp()</p>
<p>method = getattr(self, self.name)</p>
<p>method()</p>
<p>self.tearDown()</p>
<p>return TestResult()</p>
<empty-line></empty-line><p>Теперь, когда все тесты выполнились успешно, можно сделать реализацию метода summary() реальной. Как и раньше, будем двигаться маленькими шажками. Для начала заменим количество выполненных тестов константой:</p>
<empty-line></empty-line><p><strong>TestResult</strong></p>
<p>def __init__(self):</p>
<p>self.runCount = 1</p>
<p>def summary(self):</p>
<p>return "%d run, 0 failed" % self.runCount</p>
<empty-line></empty-line><p>(Оператор % в языке Python является аналогом функции sprintf в языке C.) Однако runCount не может быть константой, это должна быть переменная, значение которой вычисляется исходя из количества выполненных тестов. Мы можем инициализировать эту переменную значением 0, а затем увеличивать ее на единицу при выполнении очередного теста.</p>
<p><strong>TestResult</strong></p>
<p>def __init__(self):</p>
<p>self.runCount = 0</p>
<p>def testStarted(self):</p>
<p>self.runCount = self.runCount + 1</p>
<p>def summary(self):</p>
<p>return "%d run, 0 failed" % self.runCount</p>
<empty-line></empty-line><p>Теперь мы должны позаботиться о вызове этого нового метода:</p>
<empty-line></empty-line><p><strong>TestCase</strong></p>
<p>def run(self):</p>
<p>result = TestResult()</p>
<p>result.testStarted()</p>
<p>self.setUp()</p>
<p>method = getattr(self, self.name)</p>
<p>method()</p>
<p>self.tearDown()</p>
<p>return result</p>
<empty-line></empty-line><p>Мы точно так же могли бы преобразовать константу «0», обозначающую количество тестов, потерпевших неудачу, в переменную, как сделали это с переменной runCount, однако существующие тесты этого не требуют. Поэтому напишем новый тест:</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def testFailedResult(self):</p>
<p>test = WasRun("testBrokenMethod")</p>
<p>result = test.run()</p>
<p>assert("1 run, 1 failed", result.summary)</p>
<empty-line></empty-line><p>Здесь:</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>def testBrokenMethod(self):</p>
<p>raise Exception</p>
<p><strikethrough>Вызов тестового метода</strikethrough></p>
<p><strikethrough>Вызов метода setUp перед обращением к методу</strikethrough></p>
<p><strikethrough>Вызов метода tearDown после обращения к методу</strikethrough></p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p>Выполнение нескольких тестов</p>
<p><strikethrough>Отчет о результатах</strikethrough></p>
<p><strikethrough>Строка журнала в классе WasRun</strikethrough></p>
<p>Отчет о неудачных тестах</p>
<empty-line></empty-line><p>Мы немедленно замечаем, что исключение, генерируемое в методе WasRun.testBrokenMethod(), не перехватывается. Нам хотелось бы перехватить это исключение и в отчете о результатах тестирования отметить, что тест потерпел неудачу. Добавим соответствующий пункт в список задач.</p>
<empty-line></empty-line><p>Подведем итог. Мы</p>
<p>• разработали поддельную реализацию и начали поэтапно делать ее реальной путем замены констант переменными;</p>
<p>• написали еще один тест;</p>
<p>• когда тест потерпел неудачу, написали еще один тест меньшего масштаба, чтобы обеспечить выполнение неудачного теста.</p>
</section><section><title><p>22. Обработка неудачного теста</p>
</title><p><strikethrough>Вызов тестового метода</strikethrough></p>
<p><strikethrough>Вызов метода setUp перед обращением к методу</strikethrough></p>
<p><strikethrough>Вызов метода tearDown после обращения к методу</strikethrough></p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p>Выполнение нескольких тестов</p>
<p><strikethrough>Отчет о результатах</strikethrough></p>
<p><strikethrough>Строка журнала в классе WasRun</strikethrough></p>
<p><strong>Отчет о неудачных тестах</strong></p>
<empty-line></empty-line><p>Напишем еще один тест меньшего масштаба, демонстрирующий, что при обнаружении неудачного теста наша инфраструктура распечатывает на экране корректный результат:</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def testFailedResultFormatting(self):</p>
<p>result = TestResult()</p>
<p>result.testStarted()</p>
<p>result.testFailed()</p>
<p>assert("1 run, 1 failed" == result.summary())</p>
<empty-line></empty-line><p>В данном тесте фигурируют два новых метода: testStarted() и testFailed(). Первый из них должен вызываться в начале работы теста, а второй – в случае, если тест не срабатывает. Тестовый метод testFailedResultFormatting() предполагает, что, если эти два метода вызываются в указанном порядке, отчет о результате тестирования должен выглядеть корректно. Если мы заставим этот тестовый метод работать, наша проблема сведется к тому, чтобы обеспечить вызов метода testStarted() в начале выполнения теста и вызов testFailed() в случае, если тест потерпел неудачу.</p>
<p>Чтобы реализовать функциональность методов testStarted() и testFailed(), воспользуемся двумя счетчиками: счетчиком запущенных тестов и счетчиком неудачных тестов:</p>
<empty-line></empty-line><p><strong>TestResult</strong></p>
<p>def __init__(self):</p>
<p>self.runCount = 0</p>
<p>self.errorCount = 0</p>
<p>def testFailed(self):</p>
<p>self.errorCount = self.errorCount + 1</p>
<empty-line></empty-line><p>Если счетчик будет работать корректно (мы должны были бы это протестировать, однако кофе, похоже, ударил мне в голову), отчет будет напечатан корректно:</p>
<empty-line></empty-line><p><strong>TestResult</strong></p>
<p>def summary(self):</p>
<p>return "%d run, %d failed" % (self.runCount, self.failureCount)</p>
<empty-line></empty-line><p>Теперь можно предположить, что, если обращение к методу testFailed() будет выполнено корректно, мы получим на экране желаемый результат. Но где следует вызвать этот метод? В обработчике исключения, перехваченного в процессе выполнения тестового метода:</p>
<empty-line></empty-line><p><strong>TestCase</strong></p>
<p>def run(self):</p>
<p>result = TestResult()</p>
<p>result.testStarted()</p>
<p>self.setUp()</p>
<p>try:</p>
<p>method = getattr(self, self.name)</p>
<p>method()</p>
<p>except:</p>
<p>result.testFailed()</p>
<p>self.tearDown()</p>
<p>return result</p>
<empty-line></empty-line><p>В этом коде присутствует одно тонкое место: если исключение возникает во время выполнения метода setUp(), оно не будет перехвачено. Это означает, что в определенной степени тесты зависят друг от друга. Однако прежде, чем менять код, мы должны написать еще один тест. (Я научил мою старшую дочку Бетани программировать в стиле TDD, когда ей было 12 лет. Это самый первый стиль программирования, с которым она познакомилась. Она не умеет программировать иначе и абсолютно уверена, что добавлять в программу новый функциональный код можно только в случае, если существует тест, который терпит неудачу. Однако более опытные программисты, как правило, вынуждены напоминать себе о том, что сначала необходимо писать тесты, а потом – код, заставляющий их выполняться.) Я оставляю этот следующий тест и его реализацию вам в качестве самостоятельного упражнения (мои пальцы опять устали):</p>
<empty-line></empty-line><p><strikethrough>Вызов тестового метода</strikethrough></p>
<p><strikethrough>Вызов метода setUp перед обращением к методу</strikethrough></p>
<p><strikethrough>Вызов метода tearDown после обращения к методу</strikethrough></p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p>Выполнение нескольких тестов</p>
<p><strikethrough>Отчет о результатах</strikethrough></p>
<p><strikethrough>Строка журнала в классе WasRun</strikethrough></p>
<p><strikethrough>Отчет о неудачных тестах</strikethrough></p>
<p>Перехват и отчет об ошибках setUp</p>
<empty-line></empty-line><p>Далее мы сделаем так, чтобы наша инфраструктура смогла запустить несколько тестов подряд.</p>
<empty-line></empty-line><p>В данной главе мы</p>
<p>• обеспечили успешное выполнение нашего теста меньшего масштаба;</p>
<p>• заново приступили к реализации более крупного теста;</p>
<p>• обеспечили успешное выполнение крупного теста, воспользовавшись механизмом, реализованным для маленького теста;</p>
<p>• обратили внимание на потенциальную проблему, но вместо того, чтобы немедленно браться за ее решение, добавили соответствующую пометку в список задач.</p>
</section><section><title><p>23. Оформляем тесты в набор</p>
</title><p><strikethrough>Вызов тестового метода</strikethrough></p>
<p><strikethrough>Вызов метода setUp перед обращением к методу</strikethrough></p>
<p><strikethrough>Вызов метода tearDown после обращения к методу</strikethrough></p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p><strong>Выполнение нескольких тестов</strong></p>
<p><strikethrough>Отчет о результатах</strikethrough></p>
<p><strikethrough>Строка журнала в классе WasRun</strikethrough></p>
<p><strikethrough>Отчет о неудачных тестах</strikethrough></p>
<p>Перехват и отчет об ошибках setUp</p>
<empty-line></empty-line><p>Мы не можем оставить работу над xUnit, не реализовав класс TestSuite, представляющий собой набор тестов. Конец нашего файла, где мы запускаем все наши тесты, выглядит весьма неопрятно:</p>
<empty-line></empty-line><p>print(TestCaseTest(«testTemplateMethod»). run(). summary())</p>
<p>print(TestCaseTest("testResult"). run(). summary())</p>
<p>print(TestCaseTest("testFailedResultFormatting"). run(). summary())</p>
<p>print(TestCaseTest("testFailedResult"). run(). summary())</p>
<empty-line></empty-line><p>Дублирование – это всегда плохо, за исключением случаев, когда вы используете его в качестве мотивации для поиска недостающего элемента дизайна. В данном случае нам хотелось бы сгруппировать тесты и запустить их при помощи одной команды. (Мы приложили массу усилий для изоляции тестов, однако все эти усилия не окупят себя, если мы будем запускать тесты по одному.) Еще одна хорошая причина, по которой было бы неплохо реализовать TestSuite, заключается в том, что этот класс хорошо демонстрирует использование шаблона «Компоновщик» (Composite), – мы хотим, чтобы набор тестов вел себя в точности так же, как единичный тест.</p>
<p>Мы хотим обладать возможностью создать набор тестов (объект TestSuite), добавить в него несколько тестов и получить общий результат выполнения всех этих тестов:</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def testSuite(self):</p>
<p>suite = TestSuite()</p>
<p>suite.add(WasRun("testMethod"))</p>
<p>suite.add(WasRun("testBrokenMethod"))</p>
<p>result = suite.run()</p>
<p>assert("2 run, 1 failed" == result.summary())</p>
<empty-line></empty-line><p>Для успешного выполнения теста создадим в объекте TestSuite список тестов и реализуем метод add(), который просто добавляет тест, переданный в качестве аргумента, в список:</p>
<empty-line></empty-line><p><strong>TestSuite</strong></p>
<p>class TestSuite:</p>
<p>def __init__(self):</p>
<p>self.tests = []</p>
<p>def add(self, test):</p>
<p>self.tests.append(test)</p>
<empty-line></empty-line><p>(В языке Python оператор [] создает пустую коллекцию.)</p>
<empty-line></empty-line><p>Однако с реализацией метода run() возникают проблемы. Мы хотим, чтобы результаты срабатывания всех тестов накапливались в едином объекте класса TestResult. Таким образом, мы можем написать следующий код:</p>
<empty-line></empty-line><p><strong>TestSuite</strong></p>
<p>def run(self):</p>
<p>result = TestResult()</p>
<p>for test in tests:</p>
<p>test.run(result)</p>
<p>return result</p>
<empty-line></empty-line><p>Здесь оператор цикла «for test in tests» выполняет итерации по всем элементам последовательности tests, присваивает их по одному переменной цикла test и запускает соответствующий тест. Однако шаблон «Компоновщик» (Composite) подразумевает, что набор объектов должен обладать точно таким же интерфейсом, каким обладает отдельный объект. Если мы передаем параметр методу TestCase.run(), значит, мы должны передавать точно такой же параметр методу TestSuite.run(). Можно использовать одну из трех альтернатив.</p>
<p>• Воспользоваться встроенным в язык Python механизмом параметров со значениями по умолчанию. К сожалению, значение параметра по умолчанию вычисляется во время компиляции, но не во время выполнения, а мы не хотим повторно использовать один и тот же объект TestResult.</p>
<p>• Разделить метод на две части – одна создает объект TestResult, а вторая выполняет тест, используя переданный ей объект TestResult. Я не могу придумать хороших имен для двух частей метода, а это означает, что данная стратегия не является самой лучшей.</p>
<p>• Создавать объекты TestResult в вызывающем коде.</p>
<empty-line></empty-line><p>Мы будем создавать объекты TestResult в вызывающем коде. Этот шаблон называется «Накапливающий параметр» (Collecting Parameter).</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def testSuite(self):</p>
<p>suite = TestSuite()</p>
<p>suite.add(WasRun("testMethod"))</p>
<p>suite.add(WasRun("testBrokenMethod"))</p>
<p>result = TestResult()</p>
<p>suite.run(result)</p>
<p>assert("2 run, 1 failed" == result.summary())</p>
<empty-line></empty-line><p>При использовании данного подхода метод run() не возвращает никакого явного значения:</p>
<empty-line></empty-line><p><strong>TestSuite</strong></p>
<p>def run(self, result):</p>
<p>for test in tests:</p>
<p>test.run(result)</p>
<empty-line></empty-line><p><strong>TestCase</strong></p>
<p>def run(self, result):</p>
<p>result.testStarted()</p>
<p>self.setUp()</p>
<p>try:</p>
<p>method = getattr(self, self.name)</p>
<p>method()</p>
<p>except:</p>
<p>result.testFailed()</p>
<p>self.tearDown()</p>
<empty-line></empty-line><p>Теперь мы можем облагородить обращение к тестовым методам в конце файла:</p>
<empty-line></empty-line><p><strong>suite = TestSuite()</strong></p>
<p>suite.add(TestCaseTest("testTemplateMethod"))</p>
<p>suite.add(TestCaseTest("testResult"))</p>
<p>suite.add(TestCaseTest("testFailedResultFormatting"))</p>
<p>suite.add(TestCaseTest("testFailedResult"))</p>
<p>suite.add(TestCaseTest("testSuite"))</p>
<p>result = TestResult()</p>
<p>suite.run(result)</p>
<p>print(result.summary())</p>
<p><strikethrough>Вызов тестового метода</strikethrough></p>
<p><strikethrough>Вызов метода setUp перед обращением к методу</strikethrough></p>
<p><strikethrough>Вызов метода tearDown после обращения к методу</strikethrough></p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p><strong>Выполнение нескольких тестов</strong></p>
<p><strikethrough>Отчет о результатах</strikethrough></p>
<p><strikethrough>Строка журнала в классе WasRun</strikethrough></p>
<p><strikethrough>Отчет о неудачных тестах</strikethrough></p>
<p>Перехват и отчет об ошибках setUp</p>
<p>Создать объект TestSuite автоматически на основе класса TestCase</p>
<empty-line></empty-line><p>Здесь слишком много повторяющегося кода, от которого можно избавиться, если обеспечить способ конструирования набора тестов автоматически, исходя из предоставленного класса TestCase.</p>
<p>Однако вначале восстановим корректное выполнение четырех не неудачных тестов (эти тесты используют старый интерфейс функции run() без аргументов):</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def testTemplateMethod(self):</p>
<p>test = WasRun("testMethod")</p>
<p>result = TestResult()</p>
<p>test.run(result)</p>
<p>assert("setUp testMethod tearDown " == test.log)</p>
<p>def testResult(self):</p>
<p>test = WasRun("testMethod")</p>
<p>result = TestResult()</p>
<p>test.run(result)</p>
<p>assert("1 run, 0 failed" == result.summary())</p>
<p>def testFailedResult(self):</p>
<p>test = WasRun("testBrokenMethod")</p>
<p>result = TestResult()</p>
<p>test.run(result)</p>
<p>assert("1 run, 1 failed" == result.summary())</p>
<p>def testFailedResultFormatting(self):</p>
<p>result = TestResult()</p>
<p>result.testStarted()</p>
<p>result.testFailed()</p>
<p>assert("1 run, 1 failed" == result.summary())</p>
<empty-line></empty-line><p>Обратите внимание, что каждый из тестов создает экземпляр класса TestResult – эту операцию можно выполнить однократно внутри метода setUp(). Благодаря реализации этой идеи мы упростим тесты, однако сделаем их несколько более сложными в прочтении:</p>
<empty-line></empty-line><p><strong>TestCaseTest</strong></p>
<p>def setUp(self):</p>
<p>self.result = TestResult()</p>
<p>def testTemplateMethod(self):</p>
<p>test = WasRun("testMethod")</p>
<p>test.run(self.result)</p>
<p>assert("setUp testMethod tearDown " == test.log)</p>
<p>def testResult(self):</p>
<p>test = WasRun("testMethod")</p>
<p>test.run(self.result)</p>
<p>assert("1 run, 0 failed" == self.result.summary())</p>
<p>def testFailedResult(self):</p>
<p>test = WasRun("testBrokenMethod")</p>
<p>test.run(self.result)</p>
<p>assert("1 run, 1 failed" == self.result.summary())</p>
<p>def testFailedResultFormatting(self):</p>
<p>self.result.testStarted()</p>
<p>self.result.testFailed()</p>
<p>assert("1 run, 1 failed" == self.result.summary())</p>
<p>def testSuite(self):</p>
<p>suite = TestSuite()</p>
<p>suite.add(WasRun("testMethod"))</p>
<p>suite.add(WasRun("testBrokenMethod"))</p>
<p>suite.run(self.result)</p>
<p>assert("2 run, 1 failed" == self.result.summary())</p>
<p><strikethrough>Вызов тестового метода</strikethrough></p>
<p><strikethrough>Вызов метода setUp перед обращением к методу</strikethrough></p>
<p><strikethrough>Вызов метода tearDown после обращения к методу</strikethrough></p>
<p>Метод tearDown должен вызываться даже в случае неудачи теста</p>
<p><strikethrough>Выполнение нескольких тестов</strikethrough></p>
<p><strikethrough>Отчет о результатах</strikethrough></p>
<p><strikethrough>Строка журнала в классе WasRun</strikethrough></p>
<p><strikethrough>Отчет о неудачных тестах</strikethrough></p>
<p>Перехват и отчет об ошибках setUp</p>
<p>Создать объект TestSuite автоматически на основе класса TestCase</p>
<empty-line></empty-line><p>Все эти бесчисленные ссылки self выглядят ужасно, однако без этого в языке Python никак не обойтись. Если бы этот язык изначально был объектно-ориентированным, наверное, в этих ссылках не было бы надобности, а ссылки на глобальные переменные требовали бы квалификации. Однако язык Python изначально является интерпретируемым языком с добавленной в него поддержкой объектов (надо отметить, что поддержка объектов в этом языке реализована великолепно). В результате по умолчанию переменные считаются глобальными, а явные ссылки на self – необходимыми.</p>
<p>Я оставляю реализацию оставшихся пунктов вам в качестве упражнения. Надеюсь, обретенные навыки работы в стиле TDD помогут вам.</p>
<empty-line></empty-line><p>Чтобы подвести итог, напомню, что в данной главе мы</p>
<p>• написали тест для класса TestSuite;</p>
<p>• написали часть реализации, однако не добились успешного выполнения тестов – это нарушение правил (я уверен, что существует простая поддельная реализация, которая заставила бы тесты работать, благодаря чему мы могли бы выполнять рефакторинг, имея перед глазами зеленую полоску, однако сейчас я не хочу думать на эту тему);</p>
<p>• изменили интерфейс метода run(), благодаря чему набор тестов можно использовать точно так же, как и отдельный тест, – в результате тесты наконец выполнились успешно;</p>
<p>• выполнили рефакторинг имеющихся тестов – переместили общий код создания объекта результатов в метод setUp().</p>
</section><section><title><p>24. Ретроспектива xUnit</p>
</title><p>Если перед вами встала задача разработки своей собственной инфраструктуры тестирования, методика, описанная в части II данной книги, послужит вам руководством. Не следует слишком много внимания уделять деталям реализации – значительно больший интерес представляют тесты. Если вы напишете код, обеспечивающий успешное выполнение представленных здесь тестов, в вашем распоряжении окажется минимальная инфраструктура тестирования, пригодная для запуска тестов в условиях изоляции и обеспечивающая композицию тестов. Вы сможете приступить к разработке программного кода в стиле TDD.</p>
<p>На момент написания данной книги инфраструктура тестирования xUnit адаптирована для более чем 30 языков программирования. Язык, на котором вы программируете, скорее всего, уже обладает своей собственной реализацией xUnit. Однако, даже если кто-то уже сделал это до вас, возможно, будет лучше, если вы попробуете разработать свою собственную новую версию xUnit самостоятельно. На то есть две важные причины:</p>
<p><emphasis> Контроль над реализацией</emphasis>. Основополагающая характеристика xUnit – это простота. Мартин Фаулер (Martin Fowler) сказал: «Никогда в истории программной индустрии еще не было случая, чтобы столь многие разработчики были обязаны столь немногому количеству строк программного кода». На мой взгляд, некоторые реализации xUnit к настоящему времени стали слишком большими и сложными. Если вы разработаете собственную версию xUnit, то получите инструмент, который вы будете контролировать в полном объеме.</p>
<p><emphasis> Обучение</emphasis>. Когда я сталкиваюсь с необходимостью изучить новый язык программирования, я приступаю к реализации xUnit. Когда я добиваюсь срабатывания первых восьми-десяти тестов, я овладеваю навыками работы с основными конструкциями и возможностями нового для меня языка.</p>
<p>Когда вы начнете работать с xUnit, вы обнаружите, что существует значительная разница между выражениями assert, потерпевшими неудачу, и ошибками других типов, возникающими в процессе выполнения тестов. В отличие от остальных ошибок выражения assert требуют больше времени для отладки. Из-за этого большинство реализаций xUnit отличает сбои операторов assert от всех остальных ошибок: в рамках GUI зачастую информация об ошибках отображается в начале списка.</p>
<p>Инфраструктура JUnit объявляет простой интерфейс Test, который реализуется классами TestCase и TestSuite. Если вы хотите создать тестовый класс, который мог бы взаимодействовать со стандартными средствами тестирования, встроенными в JUnit, вы можете реализовать функции интерфейса Test самостоятельно:</p>
<empty-line></empty-line><p>public interface Test {</p>
<p>public abstract int countTestCases();</p>
<p>public abstract void run(TestResult result);</p>
<p>}</p>
<empty-line></empty-line><p>В языках с оптимистическим (динамическим) приведением типов можно даже не объявлять о поддержке этого интерфейса – достаточно реализовать входящие в его состав операции. При использовании языка сценариев Сценарий может ограничивать реализацию countTestCases() возвратом единицы и выполнять проверку TestResult на отказ, а вы можете выполнять ваши сценарии с обычными объектами TestCase.</p>
</section></section><section><title><p>Часть III. Шаблоны разработки через тестирование</p>
</title><section><p>Далее следуют «величайшие хиты» – шаблоны разработки через тестирование. Некоторые из них являются эффективными приемами работы в стиле TDD, другие – шаблонами проектирования и, наконец, третьи – шаблонами рефакторинга. Третья часть книги является коллекцией справочного материала, необходимого как для освоения представленных в книге примеров, так и для самостоятельного совершенствования навыков работы в стиле TDD. Здесь представлены сведения, которые помогут лучше понять смысл примеров, рассмотренных в первых двух частях книги, а также подогреют ваш интерес и стимулируют обратиться к дополнительной информации, которую следует искать в других источниках.</p>
</section><section><title><p>25. Шаблоны разработки через тестирование</p>
</title><p>Прежде чем приступить к обсуждению эффективных методов тестирования, давайте попробуем ответить на несколько стратегических вопросов:</p>
<p>• Что такое тестирование?</p>
<p>• Когда мы выполняем тестирование?</p>
<p>• Какая логика нуждается в тестировании?</p>
<p>• Какие данные нуждаются в тестировании?</p>
<subtitle><emphasis><strong>Тест</strong></emphasis></subtitle><p>Каким образом следует тестировать программное обеспечение? При помощи автоматических тестов.</p>
<p><emphasis>Тестировать</emphasis> означает <emphasis>проверять</emphasis>. Ни один программист не считает работу над некоторым фрагментом кода завершенной, не проверив его работоспособность (исключение составляют либо слишком самоуверенные, либо слишком небрежные программисты, но я надеюсь, что среди читателей данной книги таких нет). Однако, если вы тестируете свой код, это не означает, что у вас <emphasis>есть</emphasis> тесты. <emphasis>Тест</emphasis> – это процедура, которая позволяет либо подтвердить, либо опровергнуть работоспособность кода. Когда программист проверяет работоспособность разработанного им кода, он выполняет тестирование вручную: нажимает кнопки на клавиатуре и смотрит на результат работы программы, отображаемый на экране. В данном контексте тестирование состоит из двух этапов: запуск кода и проверка результатов его работы. <emphasis>Автоматический тест</emphasis> выполняется автоматически: вместо программиста запуском кода и проверкой результатов занимается компьютер, который отображает на экране результат выполнения теста: <emphasis>код работоспособен</emphasis> или <emphasis>код неработоспособен</emphasis>. В чем состоит принципиальное отличие автоматического теста от тестирования кода вручную?</p>
<p>На рис. 25.1 представлена диаграмма взаимовлияния между стрессом и тестированием (она напоминает диаграммы Герри Вейнберга (Gerry Weinberg) в его книге <emphasis>Quality Software Management</emphasis>). Стрелка между узлами диаграммы означает, что увеличение первого показателя влечет за собой увеличение второго показателя. Стрелка с кружком означает, что увеличение первого показателя влечет за собой уменьшение второго показателя.</p>
<empty-line></empty-line><image l:href="#i_010.png"></image><p><strong>Рис. 25.1.</strong> Зловещая спираль «нет времени для тестирования»</p>
<empty-line></empty-line><p>Что происходит, когда уровень стресса возрастает?</p>
<p>Чем больший стресс вы ощущаете, тем меньше вы тестируете разрабатываемый код. Чем меньше вы тестируете разрабатываемый код, тем больше ошибок вы допускаете. Чем больше ошибок вы допускаете, тем выше уровень стресса, который вы ощущаете. Получается замкнутый круг с положительной обратной связью: рост стресса приводит к росту стресса.</p>
<p>Что надо сделать, чтобы разорвать этот зловещий цикл? Необходимо либо добавить новый элемент, либо заменить один из элементов, либо изменить стрелки. Попробуем заменить «тестирование» на «автоматическое тестирование».</p>
<p>«Я только что внес в код изменение. Нарушил ли я тем самым его работоспособность?» Рисунок 25.1 показывает динамику в действии. При использовании автоматического тестирования, когда я начинаю ощущать стресс, я запускаю тесты. Тесты превращают страх в скуку. «Нет, я ничего не сломал. Тесты по-прежнему показывают зеленую полосу.» Чем больший стресс я ощущаю, тем чаще я запускаю тесты. Выполнив тесты, я успокаиваюсь. Когда я спокоен, я допускаю меньше ошибок, а это ведет к снижению уровня стресса.</p>
<p>«Да поймите же вы, что у нас нет времени на тестирование!» – теперь эта жалоба перестает быть актуальной, так как выполнение автоматического тестирования почти не требует времени. Компьютер выполняет тестирование значительно быстрее, чем человек. Если вы не выполняете тестирования, вы опасаетесь за корректность кода. Используя автоматическое тестирование, вы можете выбирать удобный для вас уровень страха.</p>
<p>Должны ли вы запустить тест сразу же после его написания, даже если вы полностью уверены, что он не сработает? Конечно, вы можете этого не делать. Но… Приведу поучительный пример. Некоторое время назад я работал с двумя очень умными молодыми программистами над реализацией транзакций, выполняемых внутри оперативной памяти (это чрезвычайно мощная технология, поддержка которой должна быть добавлена во все современные языки программирования). Перед нами встал вопрос: как реализовать откат транзакции, если начали выполнение транзакции, затем изменили значение нескольких переменных, а затем нарушили ее выполнение (транзакция была уничтожена сборщиком мусора)? Достаточно просто, чтобы проверить способности малоопытных разработчиков. Отойдите в сторону и смотрите, как работает мастер. Вот тест. Теперь подумаем над тем, как заставить его работать. Мы приступили к написанию кода.</p>
<p>Прошло два часа. Два часа, заполненных мучениями и разочарованиями (в большинстве случаев при возникновении ошибки среда разработки давала фатальный сбой и ее приходилось перезапускать). Испробовав множество методов решения проблемы, мы отменили все изменения в коде, восстановили изначальное состояние системы и вернулись к тому, с чего начали: заново написали тот самый тест. На удачу запустили его. Он успешно выполнился. Это было потрясение… Оказалось, что механизм поддержки транзакций на самом деле не менял значений переменных, пока транзакция не считалась полностью выполненной. Надеюсь, теперь вы сами решите для себя, нужно ли вам запускать тесты сразу же после их написания.</p>
<subtitle><emphasis><strong>Изолированный тест (Isolated Test)</strong></emphasis></subtitle><p>Каким образом выполнение одного теста может повлиять на выполнение другого? Никаким.</p>
<p>Я впервые столкнулся с автоматическим тестированием, когда был еще молодым программистом. В то время в компании с другими программистами (привет, Джоси, привет, Джон!) я занимался разработкой отладчика с графическим интерфейсом. Для контроля корректности его работы использовалась длинная серия автоматических тестов. Это был набор автоматически выполняемых тестов, основанных на взаимодействии с графическим интерфейсом (специальная программа перехватывала нажатия клавиш и события мыши, а затем автоматически воспроизводила их, имитируя работу пользователя с программой). Для выполнения всей серии тестов требовалось длительное время, поэтому обычно тесты запускались вечером, перед уходом с работы, и выполнялись в течение почти всей ночи. Каждое утро, когда я приходил на работу, я видел на своем стуле аккуратно сложенную пачку листов, на которых были распечатаны результаты ночного тестирования. (Привет, Эл!) В удачные дни это мог быть всего один лист, на котором было написано, что ничего не поломалось. В плохие дни на стуле могла лежать огромная кипа бумаги – по одному листу на каждый «сломанный» тест. Постепенно я стал пугаться вида листов бумаги на моем стуле, – если я приходил на работу и видел на своем стуле кипу бумажных листов, меня немедленно бросало в дрожь.</p>
<p>Работая в таком стиле, я пришел к двум важным выводам. Во-первых, тесты должны выполняться достаточно быстро, чтобы я мог запускать их самостоятельно и делать это достаточно часто. В этом случае я мог бы обнаруживать ошибки раньше, чем кто-либо другой. Во-вторых, спустя некоторое время я заметил, что огромная кипа бумаги далеко не всегда означает огромную кучу проблем. Чаще оказывалось, что в самом начале выполнения тестов один из них завершался неудачей, оставляя систему в непредсказуемом состоянии, из-за чего следующий тест тоже завершался неудачей, а за ним и многие другие – по цепочке.</p>
<p>В то время мы пытались решить эту проблему, автоматически перезапуская систему перед выполнением каждого теста, однако для этого требовалось слишком большое время. Именно тогда у меня возникла еще одна хорошая мысль: тестирование можно выполнять на более низком уровне: вовсе не обязательно, чтобы каждый из тестов выполнялся в отношении всего приложения в целом. Чтобы убедиться в работоспособности всего приложения, достаточно протестировать каждую из его составных частей. Тестирование части приложения можно выполнить быстрее, чем тестирование всего приложения. Однако самый важный вывод состоял в том, что выполнение одного теста никоим образом не должно влиять на выполнение другого теста. Тесты должны полностью игнорировать друг друга. Если один из тестов не срабатывает, это значит, что в программе присутствует одна проблема. Если не срабатывают два теста, значит, в программе присутствуют две проблемы.</p>
<p>Если тесты изолированы друг от друга, значит, порядок их выполнения не имеет значения. Если я хочу выполнить не все, а некоторое подмножество тестов, я не должен беспокоиться о том, что некоторый тест не сработает только потому, что некоторый другой тест не был предварительно запущен.</p>
<p>Производительность является основной причиной, по которой предлагается делать данные общими для нескольких тестов. Требование изоляции тестов принуждает вас разделить проблему на несколько ортогональных измерений, благодаря чему формирование среды для каждого из тестов выполняется достаточно просто и быстро. Иногда, чтобы выполнить подобное разделение, приходится прикладывать значительные усилия. Если вы хотите, чтобы разрабатываемое вами приложение можно было протестировать при помощи набора изолированных друг от друга тестов, вы должны «собрать» это приложение из множества относительно небольших взаимодействующих между собой объектов. Я всегда знал, что это неплохая идея, и всегда радовался, когда мне удавалось реализовать ее на деле, однако я не был знаком ни с одной методикой, которая позволяла бы мне регулярно воплощать эту идею в жизнь. Ситуация изменилась в лучшую сторону после того, как я стал писать изолированные тесты.</p>
<subtitle><emphasis><strong>Список тестов (Test List)</strong></emphasis></subtitle><p>Что необходимо тестировать? Прежде чем начать, запишите на листке бумаги список всех тестов, которые вам потребуются. Чтобы успешно справляться со стрессом, вы должны постоянно соблюдать важное правило: никогда не делайте шага вперед, пока не узнаете, в каком месте ваша нога должна коснуться земли. Приступая к сеансу программирования, определите, какие задачи вы намерены решить в ходе этого сеанса.</p>
<p>В рамках весьма распространенной стратегии предлагается держать все в голове. Я пробовал использовать этот подход в течение нескольких лет, однако постоянно сталкивался с одной и той же проблемой. По мере того как я работаю, передо мной возникают все новые и новые задачи, которые необходимо решить. Чем больше задач предстоит решить, тем меньше внимания я уделяю тому, над чем я работаю. Чем меньше внимания я уделяю тому, над чем я работаю, тем меньше задач мне удается решить. Чем меньше задач мне удается решить, тем больше вещей, о которых мне приходится помнить в процессе работы. Замкнутый круг.</p>
<p>Я пытался игнорировать случайные элементы списка и программировать по прихоти, однако это не позволяет разорвать замкнутый круг.</p>
<p>Я выработал привычку записывать на листок бумаги все задачи, которые планирую решить в течение нескольких следующих часов. Этот листок постоянно лежит рядом с моим компьютером. Похожий список задач, которые я планирую решить в течение ближайшей недели или ближайшего месяца, приколот к стене над моим компьютером. Если я записал все эти задачи на бумагу, я уверен в том, что я ничего не забуду. Если передо мной возникает новая задача, я быстро и осознанно решаю, к какому списку («сейчас» или «позднее») она принадлежит и нужно ли вообще ею заниматься.</p>
<p>В контексте разработки через тестирование, список задач – это список тестов, которые мы планируем реализовать. Прежде всего включите в список примеры всех операций, которые требуется реализовать. Далее, для каждой из операций, которые еще не существуют, внесите в список нуль-версию этой операции. Наконец, перечислите в списке все изменения, которые потребуется выполнить, чтобы в конце сеанса программирования получить чистый код.</p>
<p>Но зачем записывать тесты на бумагу, когда можно записать их один за другим в виде готового тестирующего кода? Существует пара причин, по которым я не рекомендую заниматься массовым созданием тестов. Во-первых, каждый из тестов создает некоторую инерцию, мешающую выполнению рефакторинга. Чем больше тестов, тем больше эта инерция. Согласитесь, что выполнить рефакторинг кода, для тестирования которого написаны два теста, сложнее, чем выполнить рефакторинг кода, для тестирования которого написан всего один тест. Конечно, существуют инструменты автоматизированного рефакторинга, которые упрощают эту задачу (например, специальный пункт в меню осуществляет модификацию имени переменной в строке, где она объявляется, и во всех местах, в которых эта переменная используется). Однако представьте, что вы написали десять тестов для некоторого метода и <emphasis>после</emphasis> этого обнаружили, что порядок аргументов метода следует изменить на обратный. В подобной ситуации придется приложить существенные усилия, чтобы заставить себя сделать рефакторинг. Во-вторых, чем больше не работающих тестов, тем дольше путь к зеленой полосе. Если перед вами десять «сломанных» тестов, зеленую полосу вы увидите еще не скоро. Если вы хотите быстро получить перед собой зеленую полосу, вы должны выкинуть все десять тестов. Если же вы хотите добиться успешного выполнения всех этих тестов, вы будете вынуждены долгое время смотреть на красную полосу. Если вы настолько приучены к опрятности и аккуратности кодирования, что не можете позволить себе даже дойти до туалета, пока висит красная полоса, значит, вам предстоит серьезное испытание.</p>
<p>Консервативные скалолазы придерживаются одного важного правила. У человека есть две руки и две ноги, всего четыре конечности, которыми он может цепляться за скалу. В любой момент по крайней мере три конечности должны быть надежно сцеплены со скалой. Динамические перемещения, когда скалолаз перемещает с места на место одновременно две конечности, считаются чрезвычайно опасными. Методика TDD в чистом виде подразумевает использование похожего принципа: в любой момент времени вы должны быть не дальше одного изменения от зеленой полосы.</p>
<p>По мере того как вы заставляете тесты срабатывать, перед вами будет возникать необходимость реализации новых тестов. Заносите эти новые тесты в список задач. То же самое относится и к рефакторингу.</p>
<p>«Это выглядит ужасно &lt;вздох&gt;. Добавим это в список. Мы вернемся к этому перед тем, как завершить работу над задачей.»</p>
<p>Необходимо позаботиться о пунктах, оставшихся в списке на момент завершения сеанса программирования. Если на самом деле вы находитесь в середине процесса реализации некоторой функциональности, воспользуйтесь этим же списком позднее. Если вы обнаружили необходимость выполнения более крупномасштабного рефакторинга, выполнить который в настоящий момент не представляется возможным, внесите его в список «позднее». Я не могу припомнить ситуации, когда мне приходилось переносить реализацию теста в список «позднее». Если я могу придумать тест, который может не сработать, реализация этого теста важнее, чем выпуск кода, над которым я работаю.</p>
<subtitle><emphasis><strong>Сначала тест (Test First)</strong></emphasis></subtitle><p>Когда нужно писать тесты? Перед тем как вы приступите к написанию тестируемого кода.</p>
<p>Вы не должны выполнять тестирование после. Конечно, вашей основной целью является работающая функциональность. Однако вам необходима методика формирования дизайна, вам нужен метод контроля над объемом работ.</p>
<p>Рассмотрим обычную диаграмму взаимовлияния между стрессом и тестированием (не путать со стресс-тестированием – это совершенно другая вещь): верхний узел – это стресс; он соединяется с тестированием (нижний узел) отрицательной связью; тестирование, в свою очередь, соединяется со стрессом также отрицательной связью. Эта диаграмма представлена в первом разделе данной главы. Чем больший стресс вы испытываете, тем меньше вы выполняете тестирование. Когда вы знаете, что выполняемого тестирования недостаточно, у вас повышается уровень стресса. Замкнутый цикл с положительной обратной связью. Что можно сделать, чтобы разорвать его?</p>
<p>Что, если мы всегда будем выполнять тестирование вначале? В этом случае мы можем инвертировать диаграмму: вверху будет располагаться узел «Предварительное тестирование», который посредством отрицательной связи будет соединяться с расположенным внизу узлом «Стресс», который, в свою очередь, также посредством отрицательной связи будет соединяться с узлом «Предварительное тестирование».</p>
<p>Когда мы начинаем работу с написания тестов, мы снижаем стресс, а значит, тестирование может быть выполнено более тщательно. Конечно, уровень стресса зависит от множества других факторов, стало быть можно допустить, что возникнет ситуация, в которой из-за высокого уровня стресса нам все-таки придется отказаться от тестирования. Однако, помимо всего прочего, предварительное тестирование является мощным инструментом формирования дизайна и средством контроля над объемом работы. Значит, скорее всего, мы будем выполнять тестирование даже при среднем уровне стресса.</p>
<subtitle><emphasis><strong>Сначала оператор assert (Assert First)</strong></emphasis></subtitle><p>Когда следует писать оператор assert<a type="note" l:href="#n_13">[13]</a>? Попробуйте писать их в первую очередь. Неужели вам не нравится самоподобие?</p>
<p>• С чего следует начать построение системы? С формулировки пожеланий<a type="note" l:href="#n_14">[14]</a> о том, как должна работать система, полученная в результате вашей работы.</p>
<p>• С чего следует начать разработку некоторой функциональности? С написания тестов, которые должны выполниться успешно, когда код будет полностью завершен.</p>
<p>• С чего начать написание теста? С операторов assert, которые должны выполняться в ходе тестирования.</p>
<p>С этой методикой познакомил меня Джим Ньюкирк. Когда я начинаю разработку теста с операторов assert, я ощущаю мощный упрощающий эффект. Когда вы пишете тест, вы решаете несколько проблем одновременно, даже несмотря на то, что при этом вам не нужно думать о реализации.</p>
<p>• Частью чего является новая функциональность? Является ли она модификацией существующего метода? Является ли она новым методом существующего класса? Является ли она методом с известным именем, но реализованным в другом месте? А может быть, новая функциональность – это новый класс?</p>
<p>• Какие имена присвоить используемым элементам?</p>
<p>• Как можно проверить правильность результата работы кода?</p>
<p>• Что считать правильным результатом работы кода?</p>
<p>• Какие другие тесты можно придумать исходя из данного теста?</p>
<p>Малюсенький мозг, такой как у меня, не сможет хорошо поработать над решением всех этих проблем, если они будут решаться одновременно. Две проблемы из приведенного списка можно легко отделить от всех остальных: «Что считать правильным результатом?» и «Как можно проверить правильность результата?»</p>
<p>Например, представьте, что нам надо реализовать обмен данными с другой системой через сокет. После завершения операции сокет должен быть закрыт, а в буфер должна быть прочитана строка abc:</p>
<empty-line></empty-line><p>testCompleteTransaction() {</p>
<p>…</p>
<p>assertTrue(reader.isClosed());</p>
<p>assertEquals("abc", reply.contents());</p>
<p>}</p>
<empty-line></empty-line><p>Откуда должен быть прочитан объект reply? Конечно же, из сокета:</p>
<empty-line></empty-line><p>testCompleteTransaction() {</p>
<p>…</p>
<p>Buffer reply = reader.contents();</p>
<p>assertTrue(reader.isClosed());</p>
<p>assertEquals("abc", reply.contents());</p>
<p>}</p>
<empty-line></empty-line><p>А откуда берется сокет? Мы создаем его, подключаясь к серверу:</p>
<empty-line></empty-line><p>testCompleteTransaction() {</p>
<p>…</p>
<p>Socket reader = Socket("localhost", defaultPort());</p>
<p>Buffer reply = reader.contents();</p>
<p>assertTrue(reader.isClosed());</p>
<p>assertEquals("abc", reply.contents());</p>
<p>}</p>
<empty-line></empty-line><p>Однако перед этим мы должны установить соединение с сервером:</p>
<empty-line></empty-line><p>testCompleteTransaction() {</p>
<p>Server writer = Server(defaultPort(), "abc");</p>
<p>Socket reader = Socket("localhost", defaultPort());</p>
<p>Buffer reply = reader.contents();</p>
<p>assertTrue(reader.isClosed());</p>
<p>assertEquals("abc", reply.contents());</p>
<p>}</p>
<empty-line></empty-line><p>Теперь мы можем изменить имена в соответствии с используемым контекстом, однако в данном случае мы малюсенькими шажками сформировали набросок теста, генерируя каждое решение в течение пары секунд. Мы начали с написания оператора assert.</p>
<subtitle><emphasis><strong>Тестовые данные (Test Data)</strong></emphasis></subtitle><p>Какие данные следует использовать для предварительных тестов? Используйте данные, которые делают тест простым для чтения и понимания. Помните, что вы пишете тесты для людей. Не разбрасывайте данные в изобилии по всему тесту только потому, что вам хочется добавить в тест как можно больше разнообразных данных. Если в разных местах теста используются разные данные, разница должна быть осмысленной. Если не существует концептуальной разницы между 1 и 2, используйте 1.</p>
<p>Вместе с тем, если ваша система должна поддерживать несколько разновидностей ввода, значит, все эти разновидности должны быть отражены в тестах. Однако не следует использовать в качестве входных данных список из десяти элементов, если при использовании списка из трех элементов будет получен точно такой же дизайн и реализация.</p>
<p>Старайтесь не использовать одну и ту же константу в нескольких местах для обозначения более чем одного понятия. Например, если вы намерены тестировать операцию plus(), вам наверняка захочется в качестве теста использовать операцию 2 + 2 – ведь это классический пример сложения. Возможно, вам захочется использовать другую операцию: 1 + 1 – ведь она самая простая из всех возможных. Однако не забывайте, что в данном случае речь идет о двух разных слагаемых, которые могут быть разными объектами. При использовании выражения 2 + 2 слагаемые оказываются одинаковыми, а значит, тест не является достаточно общим. Представьте, что в ходе дальнейшей разработки вы пришли к выводу, что результат выполнения операции plus() по тем или иным причинам должен зависеть от порядка слагаемых (сложно представить себе ситуацию, в которой результат сложения зависит от порядка слагаемых, однако может случиться, что операция plus() может перестать быть просто сложением, таким образом, общая идея должна быть вам понятной). Чтобы обеспечить более полноценное тестирование, попробуйте использовать 2 в качестве первого аргумента и 3 в качестве второго аргумента (в свое время тест 3 + 4 был классическим начальным тестом при запуске новой виртуальной машины Smalltalk).</p>
<p>Альтернативой шаблону «Тестовые данные» (Test Data) является шаблон «Реалистичные данные» (Realistic Data), в рамках которого для тестирования используются данные из реального мира. Реалистичные данные удобно применять в следующих ситуациях:</p>
<p>• вы занимаетесь тестированием системы реального времени, используя цепочки внешних событий, которые возникают в реальных условиях эксплуатации;</p>
<p>• вы сравниваете вывод текущей системы с выводом предыдущей системы (параллельное тестирование);</p>
<p>• вы выполняете рефакторинг кода, имитирующего некоторый реальный процесс, и ожидаете, что после рефакторинга результирующие данные будут в точности такими же, как до рефакторинга, в особенности если речь идет о точности операций с плавающей точкой.</p>
<subtitle><emphasis><strong>Понятные данные (Evident Data)</strong></emphasis></subtitle><p>Каким образом в тесте можно отразить назначение тех или иных данных? Добавьте в тест ожидаемый и реально полученный результат и попытайтесь сделать отношение между ними понятным. Вы пишете тесты не только для компьютера, но и для читателя. Через несколько дней, месяцев или лет кто-нибудь будет смотреть на ваш код и спрашивать себя: «Что имел в виду этот шутник, когда писал этот запутанный код?» Попробуйте оставить своему читателю как можно больше подсказок, имейте в виду, что этим разочарованным читателем можете оказаться вы сами.</p>
<p>Вот пример. Если мы конвертируем одну валюту в другую, мы берем комиссию 1,5 за выполнение операции. Представьте, что мы обмениваем американские доллары (USD) на британские фунты стерлингов (GBP). Пусть курс обмена будет составлять 2:1. Если мы хотим обменять $100, в результате мы должны получить 50 GBP – 1,5 % = 49,25 GBP. Мы могли бы написать следующий тест:</p>
<empty-line></empty-line><p>Bank bank = new Bank().</p>
<p>bank.addRate("USD", "GBP", STANDARD_RATE);</p>
<p>bank.commission(STANDARD_COMMISSION);</p>
<p>Money result = bank.convert(new Note(100, "USD"), "GBP");</p>
<p>assertEquals(new Note(49.25, "GBP"), result);</p>
<empty-line></empty-line><p>Однако вместо этого мы можем сделать порядок вычислений более очевидным:</p>
<empty-line></empty-line><p>Bank bank = new Bank();</p>
<p>bank.addRate("USD", "GBP", 2);</p>
<p>bank.commission(0.015);</p>
<p>Money result = bank.convert(new Note(100, "USD"), "GBP");</p>
<p>assertEquals(new Note(100 / 2 * (1–0.015), "GBP"), result);</p>
<empty-line></empty-line><p>Прочитав этот тест, я вижу взаимосвязь между входными значениями и значениями, используемыми в составе формулы.</p>
<p>Шаблон «Понятные данные» (Evident Data) обладает побочным эффектом: он в некоторой степени облегчает программирование. После того как мы в понятной форме записали выражение assert, мы получаем представление о том, что именно нам необходимо запрограммировать. В данном случае мы видим, что тестируемый код должен содержать операции деления и умножения. Мы даже можем воспользоваться шаблоном «Поддельная реализация» (Fake It), чтобы узнать, где должна располагаться та или иная операция.</p>
<p>Шаблон «Понятные данные» (Evident Data) выглядит как исключение из правила о том, что в коде не должно быть «магических» чисел. Дело в том, что в рамках одного метода легко понять назначение того или иного числа. Однако если в программе уже имеются объявленные символьные константы, я предпочитаю использовать их вместо конкретных численных значений.</p>
</section><section><title><p>26. Шаблоны красной полосы</p>
</title><p>В данной главе речь пойдет о шаблонах, которые подскажут вам, когда писать тесты, где писать тесты и когда прекратить писать тесты.</p>
<subtitle><emphasis><strong>Тест одного шага (One Step Test)</strong></emphasis></subtitle><p>Какой следующий тест лучше всего выбрать из списка задач для реализации? Выбирайте тест, который, во-первых, научит вас чему-либо, а во-вторых, который вы сможете реализовать.</p>
<p>Каждый тест должен соответствовать одному шагу в направлении к вашей основной цели. Взгляните на этот список тестов и попробуйте определить, какой тест лучше всего выбрать в качестве следующего для реализации:</p>
<empty-line></empty-line><p>плюс;</p>
<p>минус;</p>
<p>умножение;</p>
<p>деление;</p>
<p>сложение с такой же валютой;</p>
<p>равенство;</p>
<p>равенство нулю;</p>
<p>нулевой обмен;</p>
<p>обмен одной и той же валюты;</p>
<p>обмен двух валют;</p>
<p>курс кросс-обмена.</p>
<empty-line></empty-line><p>Не существует единственно правильного ответа. То, что для меня, ни разу не занимавшегося реализацией этих объектов, будет выглядеть как один шаг, для вас, обладающих достаточным опытом, может оказаться одной десятой шага. Если вы не можете найти в списке тест, соответствующий одному шагу, добавьте в список дополнительные тесты, реализация которых поможет вам приблизиться к реализации тестов, уже присутствующих в списке.</p>
<p>Когда я смотрю на список тестов, я рассуждаю: «Это очевидно, это очевидно, об этом я не имею ни малейшего представления, это очевидно, здесь – никаких идей, о чем я думал, когда писал это? А! Вспомнил! Я думаю, что мог бы это сделать». Этот последний тест я реализую следующим. С одной стороны, он не кажется мне очевидным, с другой стороны, я уверен в том, что смогу заставить его работать.</p>
<p>Программа, выросшая из подобных тестов, может быть написана в рамках нисходящего подхода (сверху вниз), так как вы можете начать с теста, который ориентирован на вариант полного вычисления. Программа, выросшая из тестов, может быть написана и в рамках восходящего подхода (снизу вверх), так как вы начинаете с небольших кусочков и собираете их в конструкцию постепенно увеличивающегося размера.</p>
<p>И нисходящий, и восходящий подходы не представляют реального описания процесса. Во-первых, вертикальная метафора – это упрощенная визуализация процесса изменения программы в течение разработки. Для описания процесса разработки, основанной на тестировании, лучше подходит метафора <emphasis>Развития</emphasis> или <emphasis>Эволюции</emphasis>: внешняя среда влияет на программу, а программа влияет на внешнюю среду. Во-вторых, если мы хотим, чтобы в нашей метафоре присутствовало направление, лучшим описанием будет «от известного к неизвестному». Подразумевается, что мы обладаем некоторыми знаниями и опытом и ожидаем, что в процессе разработки мы будем узнавать нечто новое. Объединим эти две метафоры и получим, что программа эволюционирует от известного к неизвестному.</p>
<subtitle><emphasis><strong>Начальный тест (Starter Test)</strong></emphasis></subtitle><p>С какого теста следует начать разработку? Начните с тестирования варианта операции, который не подразумевает выполнения каких-либо осмысленных действий, то есть ничего не делает.</p>
<p>Приступая к реализации операции, вы прежде всего должны ответить на вопрос: «Где она должна располагаться?» Пока вы не ответите на этот вопрос, вы не будете знать, какой код необходимо написать, чтобы протестировать эту операцию. Как уже неоднократно рекомендовалось, не следует решать несколько проблем одновременно. Значит, вы должны выбрать такой тест, который позволит вам искать ответ только на один этот вопрос и на время забыть обо всех остальных вопросах.</p>
<p>Если вы с самого начала приступите к реализации реалистичного теста, вам придется искать ответы на несколько вопросов одновременно:</p>
<p>• Где должна располагаться операция?</p>
<p>• Какие входные данные считать корректными?</p>
<p>• Каким должен быть корректный результат выполнения операции при использовании выбранных входных данных?</p>
<p>Если вы начнете с реалистичного теста, вы слишком долгое время будете вынуждены действовать без обратной связи. Красный – зеленый – рефакторинг, красный – зеленый – рефакторинг. На выполнение этого цикла должно уходить всего несколько минут.</p>
<p>Но как сократить время цикла? Для этого вы можете воспользоваться тривиальными входными и выходными данными. Вот простой пример: если функция должна складывать многозначные вещественные числа с точностью до тысячного знака после запятой, вовсе не обязательно начинать ее реализацию с теста, проверяющего результат сложения таких огромных чисел. Вполне можно начать с тривиального теста 3 + 4 = 7. Вот еще один пример. В группе электронных новостей, посвященной экстремальному программированию, один из участников поинтересовался, как написать программу минимизации количества полигонов (многоугольников), составляющих некоторую поверхность. На вход подается набор полигонов, комбинация которых представляет собой некоторый трехмерный объект. На выходе должна получиться комбинация полигонов, которая описывает точно такой же объект (поверхность), но включает в себя минимальное возможное количество полигонов. «Как я могу разработать подобную программу, если для того, чтобы заставить тест сработать, я должен быть как минимум доктором наук?»</p>
<p>Используя шаблон «Начальный тест» (Starter Test), мы получаем ответ:</p>
<p>• Вывод должен быть точно таким же, как ввод. Некоторые комбинации полигонов изначально являются минимальными.</p>
<p>• Ввод должен быть как можно меньшего размера. Например, единственный полигон или даже пустой список полигонов.</p>
<p>Мой начальный тест выглядел следующим образом:</p>
<empty-line></empty-line><p>Reducer r = new Reducer(new Polygon());</p>
<p>assertEquals(0, reducer.result(). npoints);</p>
<empty-line></empty-line><p>Отлично! Первый тест заработал. Теперь можно перейти к остальным тестам в списке…</p>
<p>К начальному тесту следует применить рассмотренное ранее правило «Тест одного шага» (One Step Test): самый первый тест должен научить вас чему-то новому, кроме того, вы должны обладать возможностью достаточно быстро заставить его работать. Если вы реализуете подобный код уже не в первый раз, вы можете выбрать начальный тест для одной или даже двух операций. Вы должны быть уверены, что сможете быстро заставить тест работать. Если вы приступаете к реализации чего-либо достаточно сложного и делаете это впервые, начните с самого простого теста, который вы только можете представить.</p>
<p>Я часто замечаю, что мой начальный тест работает на достаточно высоком уровне и скорее напоминает тест всего приложения. Например, простой сетевой сервер. Самый первый тест выглядит следующим образом:</p>
<empty-line></empty-line><p>StartServer</p>
<p>Socket= new Socket</p>
<p>Message = "hello"</p>
<p>Socket.write(message)</p>
<p>AssertEquals(message, socket.read)</p>
<empty-line></empty-line><p>Остальные тесты пишутся только на стороне сервера: «Предположим, что мы получаем строки наподобие этой…»</p>
<subtitle><emphasis><strong>Объясняющий тест (Explanation Test)</strong></emphasis></subtitle><p>Как распространить в своей команде использование автоматического тестирования? Для любых объяснений используйте тесты и спрашивайте тесты у тех, кто пытается вам что-либо объяснить.</p>
<p>Если вы единственный член команды, работающий в стиле TDD, вы можете почувствовать себя неуютно и одиноко. Однако вскоре после того, как вы начнете работать в стиле TDD, вы обратите внимание на уменьшение количества проблем, связанных с интеграцией, и снижение количества дефектов, обнаруженных в проверенном коде. Дизайн вашего кода будет проще, и его легче будет объяснять. Может случиться так, что ваши коллеги проявят интерес к тестированию и предварительному тестированию разрабатываемого кода.</p>
<p>Опасайтесь оголтелого энтузиазма со стороны новичков. Подобный энтузиазм может оттолкнуть тех, кто еще не до конца понял преимущества и необходимость предварительного тестирования. Если внедрение TDD производить насильственными методами, это может привести к негативным результатам. Если вы руководитель или лидер, вы не должны насильно заставлять людей менять стиль, в рамках которого они работают.</p>
<p>Но что можно сделать? Лучше всего предлагать вашим коллегам объяснять работу кода в форме тестов: «Подожди-ка, если я правильно понял, объект Foo будет таким, а объект Bar будет таким, значит, в результате получится 76?» Кроме того, вы можете объяснять работу кода в виде тестов: «Вот как это работает. Если объект Foo будет таким, а объект Bar будет таким, в результате получится 76. Однако если объект Foo будет таким, а объект Bar будет таким, в результате получится 67».</p>
<p>Вы можете делать это на более высоком уровне абстракции. Если кто-то пытается объяснить вам работу кода при помощи диаграммы последовательности обмена сообщениями, вы можете предложить ему преобразовать эту диаграмму в более понятную форму. После этого вы пишете тест, содержащий в себе все видимые на диаграмме объекты и сообщения.</p>
<subtitle><emphasis><strong>Тест для изучения (Learning Test)<a type="note" l:href="#n_15">[15]</a></strong></emphasis></subtitle><p>Когда необходимо писать тесты для программного обеспечения, разработанного сторонними разработчиками? Перед тем как вы впервые воспользуетесь новыми возможностями этого программного обеспечения.</p>
<p>Предположим, что вы приступаете к разработке программы, основанной на использовании библиотеки Mobile Information Device Profile (MIDP) для языка Java. Вы собираетесь сохранить некоторые данные в объекте RecordStore и затем извлечь их оттуда. Должны ли вы просто написать код в надежде на то, что он заработает? Это один из возможных методов разработки.</p>
<p>Есть альтернативный метод. Обратите внимание на то, что вы собираетесь использовать новый метод нового класса. Вместо того чтобы просто воспользоваться им внутри разрабатываемого вами кода, вы пишете небольшой тест, который позволяет вам убедиться в том, что API работает так, как вы того ожидаете. Таким образом, вы можете написать:</p>
<empty-line></empty-line><p>RecordStore store;</p>
<empty-line></empty-line><p>public void setUp() {</p>
<p>store = RecordStore.openRecordStore("testing", true);</p>
<p>}</p>
<empty-line></empty-line><p>public void tearDown() {</p>
<p>RecordStore.deleteRecordStore("testing");</p>
<p>}</p>
<empty-line></empty-line><p>public void testStore() {</p>
<p>int id = store.addRecord(new byte[] {5, 6}, 0, 2);</p>
<p>assertEquals(2, store.getRecordSize(id));</p>
<p>byte[] buffer = new byte[2];</p>
<p>assertEquals(2, store.getRecord(id, buffer, 0));</p>
<p>assertEquals(5, buffer[0]);</p>
<p>assertEquals(6, buffer[1]);</p>
<p>}</p>
<empty-line></empty-line><p>Если ваше понимание API совпадает с действительностью, значит, тест сработает с первого раза.</p>
<p>Джим Ньюкирк рассказал мне о проекте, в котором разработка тестов для обучения выполнялась на регулярной основе. Как только от сторонних разработчиков поступала новая версия пакета, немедленно запускались имеющиеся тесты. В случае необходимости в тесты вносились исправления. Если тесты завершались неудачей, не было никакого смысла запускать приложение, так как оно определенно не заработает. Если же все тесты выполнялись успешно, значит, и приложение заработает.</p>
<subtitle><emphasis><strong>Еще один тест (Another Test)</strong></emphasis></subtitle><p>Как предотвратить уход дискуссии от основной темы? Когда возникает посторонняя, но интересная мысль, добавьте в список еще один тест и вернитесь к основной теме.</p>
<p>Я люблю пространные дискуссии (вы уже прочитали большую часть книги, поэтому, скорее всего, пришли к такому же выводу самостоятельно). Если постоянно жестко следить за соблюдением основной темы обсуждения, можно потерять множество бриллиантовых идей. Вы перескакиваете с одной темы на другую, затем на третью и, наконец, не успеваете заметить, что ушли далеко от того, с чего начали. А кого это волнует, ведь обсуждать вещи в таком стиле – это круто!</p>
<p>Иногда программирование – это прорыв, генерация гениальной идеи и вдохновение. Однако в большинстве случаев программирование – весьма рутинная работа. У меня есть десять вещей, которые я должен реализовать. Я постоянно откладываю на потом задачу номер четыре. Один из способов избежать работы (и, возможно, сопутствующего страха) – вступить в длинные пространные рассуждения на самые разные темы.</p>
<p>Потеряв огромное количество времени впустую, я пришел к выводу, что иногда лучше сосредоточиться на конкретной проблеме и не отвлекаться на побочные мысли. Когда я работаю в подобном стиле, я приветствую любые новые идеи, однако не позволяю им слишком сильно отвлекать мое внимание. Я записываю новые идеи в список и затем возвращаюсь к тому, над чем я работаю.</p>
<subtitle><emphasis><strong>Регрессионный тест (Regression Test)</strong></emphasis></subtitle><p>Что необходимо сделать в первую очередь в случае, если обнаружен дефект? Написать самый маленький из всех возможных тестов, который не работает, и восстановить его работоспособность.</p>
<p>Регрессионные тесты – это тесты, которые вы наверняка написали бы в процессе обычной разработки, если бы своевременно обнаружили проблему. Каждый раз, столкнувшись с необходимостью написать регрессионный тест, подумайте о том, как вы могли бы узнать о необходимости написать этот тест ранее, то есть тогда, когда выполняли разработку.</p>
<p>Полезным может оказаться тестирование на уровне всего приложения. Регрессионные тесты для всего приложения дают пользователям возможность сообщить вам, что неправильно и чего они на самом деле ожидают. Регрессионные тесты меньшего масштаба являются для вас способом улучшить качество тестирования. Если вы получили доклад о дефекте, в котором описывается появление большого отрицательного целого числа в отчете, значит, в будущем вам необходимо уделить дополнительное внимание тестированию граничных значений для целых чисел.</p>
<p>Возможно, для того чтобы изолировать дефект, вам потребуется выполнить рефакторинг системы. В этом случае, демонстрируя дефект, система как бы говорит вам: «Ты еще не вполне закончил проектировать меня».</p>
<subtitle><emphasis><strong>Перерыв (Break)</strong></emphasis></subtitle><p>Что делать, если вы почувствовали усталость или зашли в тупик? Прервите работу и отдохните.</p>
<p>Выпейте кофе, пройдитесь или даже вздремните. Стряхните с себя эмоциональное напряжение, связанное с решениями, которые вы принимаете, и символами, которые вы набираете на клавиатуре.</p>
<p>Иногда самого короткого перерыва достаточно, чтобы недостающая идея возникла в вашей голове. Возможно, вставая из-за компьютера, вы неожиданно нащупаете нужную нить: «Да я же не попробовал этот метод с пересмотренными параметрами!» В любом случае прервитесь. Дайте себе пару минут. Идея никуда не убежит.</p>
<p>Если, несмотря на отдых, идея не приходит вам в голову, пересмотрите цели, которые вы поставили перед собой для текущего сеанса программирования. Можно ли считать эти цели по-прежнему реалистичными, или вы должны выбрать новые цели? Является ли то, чего вы пытаетесь достичь, невозможным? Если так, то каким образом это повлияет на всю вашу команду?</p>
<p>Дэйв Унгар (Dave Ungar) называет это Методологией душа (Shower Methodology). Если вы знаете, что писать, – пишите. Если вы не знаете, что писать, примите душ и стойте под ним до тех пор, пока не поймете, что нужно писать. Очень многие команды были бы более счастливыми, более продуктивными и пахли бы существенно лучше, если бы воспользовались этим советом.</p>
<p>TDD – это усовершенствование предложенной Унгаром методологии душа. Если вы знаете, что писать, пишите очевидную реализацию. Если вы не знаете, что писать, создайте поддельную реализацию. Если правильный дизайн по-прежнему не ясен, триангулируйте. Если вы по-прежнему не знаете, что писать, можете, наконец, принять душ.</p>
<p>На рис. 26.1 показана динамика процессов, связанных с перерывом. В процессе работы вы устаете. В результате внимание рассеивается, и вам становится сложнее заметить, что вы устали. Поэтому вы продолжаете работать и устаете еще больше.</p>
<p>Чтобы разорвать этот замкнутый круг, необходимо добавить дополнительный внешний элемент.</p>
<p>• В масштабе нескольких часов держите бутылку с водой рядом с вашей клавиатурой и время от времени прихлебывайте из нее. Благодаря этому естественная физиология будет подсказывать вам, когда и зачем необходимо сделать короткий перерыв в работе.</p>
<empty-line></empty-line><image l:href="#i_011.png"></image><p><strong>Рис. 26.1.</strong> Усталость негативно влияет на рассудительность, которая негативно влияет на усталость</p>
<empty-line></empty-line><p>• В масштабе дня вы должны хорошо отдохнуть после завершения рабочего времени.</p>
<p>• В масштабе недели вы отдыхаете в выходные дни. Отдых наполнит вас силами и идеями, благодаря чему вы сможете приступать к новой рабочей неделе. (Моя жена утверждает, что самые лучшие идеи возникают у меня вечером в пятницу.)</p>
<p>• В масштабе года вы получаете отпуск, что позволяет вам полностью освежиться. Французы подходят к этому вопросу очень правильно – двух последовательных недель отпуска недостаточно. В течение первой недели вы сбрасываете с себя рабочее напряжение, а в течение второй недели подсознательно готовите себя к работе. Поэтому, чтобы хорошо отдохнуть и эффективно работать в течение всего следующего года, требуется три, а лучше четыре недели отдыха.</p>
<p>Существует обратная сторона данного шаблона. Иногда, если перед вами стоит сложная проблема, требуется, наоборот, поднажать, поднапрячься и потратить дополнительное время и усилия, чтобы решить ее. Однако большинство программистов инфицировано духом саморазрушения: «Я угроблю свое здоровье, отрекусь от своей семьи и даже выпрыгну из окна, лишь бы этот код заработал». Поэтому я не буду давать здесь каких-либо советов. Если вы чувствуете, что у вас развивается болезненное пристрастие к кофе, наверное, вам не стоит делать слишком частых перерывов. В крайнем случае, просто пройдитесь.</p>
<subtitle><emphasis><strong>Начать сначала (Do over)</strong></emphasis></subtitle><p>Что делать, если вы зашли в тупик? Выкиньте код и начните работу сначала.</p>
<p>Вы заблудились. Вы решили передохнуть. Вымыли руки. Еще раз попытались вспомнить дальнейший путь. И все равно вы заблудились. Код, который выглядел так неплохо всего час назад, теперь выглядит запутанно и непонятно, одним словом, отвратительно. Вы не можете представить себе, как заставить работать следующий тест, а впереди у вас еще 20 тестов, которые необходимо реализовать.</p>
<p>Подобное случалось со мной несколько раз, пока я писал эту книгу. Код получался слишком кривым. «Но я должен закончить книгу. Мои дети хотят есть, а сборщики налогов стучаться в мою дверь.» У меня возникает желание выпрямить код настолько, чтобы можно было продолжать двигаться вперед. Однако на самом деле в большинстве случаев продуктивнее отдохнуть немного и начать все заново. Однажды я был вынужден выкинуть 25 страниц рукописи потому, что она была основана на очевидно глупом программистском решении.</p>
<p>Хорошую историю на эту тему рассказал мне Тим Макиннон (Tim Mackinnon). Однажды он проводил собеседование с потенциальным новым сотрудником. Чтобы оценить уровень его мастерства, он предложил ему программировать в паре в течение часа. К концу этого часа они реализовали несколько новых тестов и провели несколько сеансов рефакторинга. Однако это был конец рабочего дня, они оба чувствовали себя усталыми, поэтому решили полностью убрать из системы результаты своей работы.</p>
<p>Если вы программируете в паре, смена партнера – это хороший повод отказаться от плохого кода и начать решение задачи с начала. Вы пытаетесь объяснить смысл запутанного кода, над которым работали до этого, и вдруг ваш партнер, совершенно не связанный с ошибками, которые вы допустили, берет у вас клавиатуру и говорит: «Я ужасно извиняюсь за мою тупость, но что, если мы попробуем начать по-другому?»</p>
<subtitle><emphasis><strong>Дешевый стол, хорошие кресла (Cheap Desk, Nice Chair)</strong></emphasis></subtitle><p>В какой физической обстановке следует использовать TDD? Используйте удобное, комфортное кресло. На всей остальной мебели можно сэкономить.</p>
<p>Вы не сможете хорошо программировать, если ваша спина будет болеть. К сожалению, организации, которые выкладывают по $100 000 в месяц за работу команды программистов, как правило, отказываются тратить $10 000 на покупку хороших кресел.</p>
<p>Я предлагаю использовать дешевые, самые примитивные и ужасные на вид столы для установки компьютеров, но купить самые лучшие кресла, которые я только смогу найти. Дешевых столов можно купить столько, сколько нужно, значит, я получаю в свое распоряжение достаточное количество рабочего места и могу легко его увеличить. При этом я чувствую себя комфортно за компьютером, моя спина не устает.</p>
<p>Если вы программируете в паре, позаботьтесь о том, чтобы вам было удобно. Расчистите пространство на столе, чтобы вам было удобно передавать клавиатуру из рук в руки. Когда я работаю наставником, я люблю выполнять один простой прием: незаметно подходить со спины к программирующей паре и ненавязчиво поправлять клавиатуру так, чтобы она располагалась удобно по отношению к человеку, который с ней работает.</p>
<p>Манфред Лэндж (Manfred Lange) считает, что аккуратное распределение ресурсов необходимо выполнить также в отношении компьютерного аппаратного обеспечения. Рекомендуется использовать дешевые/медленные/старые компьютеры для индивидуальной электронной почты и работы с Интернетом, но зато приобрести самые современные и самые быстрые компьютеры для разработки.</p>
</section><section><title><p>27. Шаблоны тестирования</p>
</title><p>В данной главе более подробно описываются методики разработки тестов.</p>
<subtitle><emphasis><strong>Дочерний тест (Child Test)</strong></emphasis></subtitle><p>Как заставить работать тест, который оказался слишком большим? Напишите тест меньшего размера, который представляет собой неработающую часть большого теста. Добейтесь успешного выполнения маленького теста. Заново напишите большой тест.</p>
<p>Ритм красный – зеленый – рефакторинг чрезвычайно важен для достижения успеха. Не бойтесь потратить дополнительные усилия, чтобы поддерживать этот ритм, – дополнительные усилия с лихвой окупят себя. Я достаточно часто попадаю в подобную ситуацию: сначала записываю тест, а потом оказывается, что для его реализации требуется выполнить не одно, а несколько изменений. Я неожиданно оказываюсь на большом расстоянии от зеленой полосы. Даже десять минут с красной полосой заставляют меня нервничать.</p>
<p>Когда тест оказывается слишком большим, я, прежде всего, пытаюсь усвоить урок. Почему тест оказался слишком большим? Что надо было сделать иначе, чтобы тест получился меньше по размеру?</p>
<p>Покончив с размышлениями, я удаляю изначальный тест и начинаю заново. «Похоже, заставить все эти три вещи работать одновременно – это слишком сложная задача. Однако если я вначале добьюсь успешной работы A, B и C, мне не составит труда заставить работать всю эту штуку целиком.» Иногда я действительно удаляю тест, однако в некоторых случаях я просто изменяю его имя так, чтобы оно начиналось на x, – в этом случае тестовый метод не будет выполнен. (Скажу вам по секрету, что иногда я вообще не трогаю изначальный тест. Да, да! Только т-с-с-с! Никому об этом не рассказывайте! Слава богу, в большинстве подобных случаев мне удается быстро заставить работать дочерний тест. Однако получается, что я в течение пары минут живу вместе с двумя сломанными тестами. Возможно, когда я так поступаю, я совершаю ошибку. Этот пережиток сохранился у меня с тех времен, когда я выполнял тестирование после завершения разработки или вообще не тестировал свой код.)</p>
<p>Попробуйте оба варианта. Прислушайтесь к своим ощущениям. Если у вас есть два сломанных теста, вы, как правило, начинаете программировать иначе. Делайте выводы.</p>
<subtitle><emphasis><strong>Поддельный объект (Mock Object)</strong></emphasis></subtitle><p>Как выполнять тестирование объекта, который базируется на сложном и тяжеловесном ресурсе? Создайте поддельную версию ресурса, которая будет возвращать константы.</p>
<p>Использование поддельных объектов – это тема для отдельной книги. Существует огромное количество материала, посвященного поддельным объектам<a type="note" l:href="#n_16">[16]</a>. Здесь я попытаюсь очень коротко познакомить читателей с этой концепцией.</p>
<p>Классическим примером является база данных. Чтобы запустить базу данных, требуется значительное время, поддержка чистоты базы данных требует дополнительных затрат, кроме того, если база данных располагается на удаленном сервере, ваши тесты будут связаны с конкретным физическим местоположением в сети. Наконец, база данных является емким источником ошибок разработки.</p>
<p>Чтобы уменьшить количество проблем, рекомендуется в процессе тестирования отказаться от работы непосредственно с базой данных. Большинство тестов пишется в отношении объекта, который функционирует подобно базе данных, однако располагается в оперативной памяти.</p>
<empty-line></empty-line><p>public void testOrderLookup() {</p>
<p>Database db = new MockDatabase();</p>
<p>db.expectQuery("select order_no from Order where cust_no is 123");</p>
<p>db.returnResult(new String[] {"Order 2","Order 3"});</p>
<p>.</p>
<p>}</p>
<empty-line></empty-line><p>Если объект MockDatabase не принимает ожидаемого запроса, он генерирует исключение. Если запрос корректен, объект возвращает нечто, напоминающее результирующий набор данных, состоящий из нескольких постоянных строк.</p>
<p>Помимо высокой производительности и надежности поддельные объекты обладают еще одним преимуществом: читабельностью. Если вы работаете с реальной базой данных, заполненной реальными данными, в результате обработки запроса вы можете получить ответ, состоящий из 14 строк. Возможно, вам будет нелегко понять, откуда взялось число 14 и в чем, собственно, состоит смысл теста.</p>
<p>Если вы хотите воспользоваться поддельными объектами, не следует хранить тяжеловесные ресурсы в глобальных переменных (даже если они замаскированы с использованием шаблона «Одиночка» (Singleton)). Если вы так поступите, вам придется вначале настроить глобальный поддельный объект, затем выполнить тест, а затем позаботиться о том, чтобы вернуть поддельный объект в исходное состояние.</p>
<p>В свое время я очень строго следил за выполнением этого правила. Мы вместе с Массимо Арнольди (Massimo Arnoldi) разрабатывали код, который взаимодействовал с набором курсов обмена валют, хранящимся в глобальной переменной. Для разных тестов требовалось использовать разные наборы данных, и в некоторых случаях курсы обмена валют должны были быть разными для разных тестов. Вначале мы пытались использовать для тестирования глобальную переменную, однако в конце концов нас это утомило, и однажды утром (смелые решения, как правило, приходят ко мне по утрам) мы решили передавать объект Exchange (в котором хранились курсы обмена) в качестве параметра везде, где это было необходимо. Мы думали, что нам придется модифицировать сотни методов. Однако дело кончилось тем, что мы добавили дополнительный параметр в десять или пятнадцать методов и по ходу дела подчистили другие аспекты дизайна.</p>
<p>Шаблон поддельных объектов заставляет тщательно следить за видимостью объектов, снижая взаимозависимости между ними. Поддельные объекты добавляют в проект некоторый риск, – что, если поддельный объект ведет себя не так, как реальный объект? Чтобы снизить этот риск, вы можете разработать специальный набор тестов для поддельных объектов, которые должны быть выполнены в отношении реального объекта, чтобы убедиться в том, что имитация достаточно близка к оригиналу.</p>
<subtitle><emphasis><strong>Самошунтирование (Self Shunt)</strong></emphasis></subtitle><p>Как можно убедиться в том, что один объект корректно взаимодействует с другим? Заставьте тестируемый объект взаимодействовать не с целевым объектом, а с вашим тестом.</p>
<p>Предположим, что вы хотите динамически обновлять зеленую полосу, отображаемую в рамках тестируемого пользовательского интерфейса. Если мы сможем подключить наш объект к объекту TestResult, значит, мы сможем получать оповещения о запуске теста, о том, что тест не сработал, а также о том, что весь набор тестов начал работу или, наоборот, завершил работу. Каждый раз, получив оповещение о запуске теста, мы можем выполнить обновление интерфейса. Вот соответствующий тест:</p>
<empty-line></empty-line><p><strong>ResultListenerTest</strong></p>
<p>def testNotification(self):</p>
<p>result = TestResult()</p>
<p>listener = ResultListener()</p>
<p>result.addListener(listener)</p>
<p>WasRun("testMethod"). run(result)</p>
<p>assert 1 == listener.count</p>
<empty-line></empty-line><p>Тест нуждается в объекте, который подсчитывал бы количество оповещений:</p>
<empty-line></empty-line><p><strong>ResultListener</strong></p>
<p>class ResultListener:</p>
<p>def __init__(self):</p>
<p>self.count = 0</p>
<p>def startTest(self):</p>
<p>self.count = self.count + 1</p>
<empty-line></empty-line><p>Подождите-ка! Зачем нам нужен отдельный объект Listener? Все необходимые функции мы можем возложить на объект TestCase. В этом случае объект TestCase становится подобием поддельного объекта.</p>
<empty-line></empty-line><p><strong>ResultListenerTest</strong></p>
<p>def testNotification(self):</p>
<p>self.count = 0</p>
<p>result = TestResult()</p>
<p>result.addListener(self)</p>
<p>WasRun("testMethod"). run(result)</p>
<p>assert 1 == self.count</p>
<p>def startTest(self):</p>
<p>self.count = self.count + 1</p>
<empty-line></empty-line><p>Тесты, написанные с использованием шаблона «Самошунтирование» (Self Shunt), как правило, читаются лучше, чем тесты, написанные без него. Предыдущий тест является неплохим примером. Счетчик был равен 0, а затем стал равен 1. Вы можете проследить за последовательностью действий прямо в коде теста. Почему счетчик стал равен 1? Очевидно, кто-то обратился к методу startTest(). Где произошло обращение к методу startTest()? Это произошло в начале выполнения теста. Вторая версия теста использует два разных значения переменной count в одном месте, в то время как первая версия присваивает переменной count значение 0 в одном классе и проверяет эту переменную на равенство значению 1 в другом.</p>
<p>Возможно, при использовании шаблона «Самошунтирование» (Self Shunt) вам потребуется применить шаблон рефакторинга «Выделение интерфейса» (Extract Interface), чтобы получить интерфейс, который должен быть реализован вашим тестом. Вы должны сами определить, что проще: выделение интерфейса или тестирование существующего объекта в рамках концепции «черный ящик». Однако я часто замечал, что интерфейсы, выделенные при выполнении самошунтирования, в дальнейшем, как правило, оказываются полезными для решения других задач.</p>
<p>В результате использования шаблона «Самошунтирование» (Self Shunt) вы можете наблюдать, как тесты в языке Java обрастают разнообразными причудливыми интерфейсами. В языках с оптимистической типизацией класс теста обязан реализовать только те операции интерфейса, которые действительно используются в процессе выполнения теста. Однако в Java вы обязаны реализовать абсолютно все операции интерфейса несмотря на то, что некоторые из них будут пустыми. По этой причине интерфейсы следует делать как можно менее емкими. Реализация каждой операции должна либо возвращать значение, либо генерировать исключение – это зависит от того, каким образом вы хотите быть оповещены о том, что произошло нечто неожиданное.</p>
<subtitle><emphasis><strong>Строка-журнал (Log String)</strong></emphasis></subtitle><p>Как можно убедиться в том, что обращение к методам осуществляется в правильном порядке? Создайте строку, используйте ее в качестве журнала. При каждом обращении к методу добавляйте в строку-журнал некоторое символьное сообщение.</p>
<p>Данный прием продемонстрирован ранее, в главе 20, где мы тестировали порядок обращения к методам класса TestCase. В нашем распоряжении имеется шаблонный метод, который, как мы предполагаем, обращается к методу setUp(), затем к тестовому методу, а затем к методу tearDown(). Нам хотелось бы убедиться в том, что обращение к методам осуществляется в указанном порядке. Реализуем методы так, чтобы каждый из них добавлял свое имя в строку-журнал. Исходя из этого можно написать следующий тест:</p>
<empty-line></empty-line><p>def testTemplateMethod(self):</p>
<p>test = WasRun("testMethod")</p>
<p>result = TestResult()</p>
<p>test.run(result)</p>
<p>assert("setUp testMethod tearDown " == test.log)</p>
<empty-line></empty-line><p>Реализация тоже очень проста:</p>
<empty-line></empty-line><p><strong>WasRun</strong></p>
<p>def setUp(self):</p>
<p>self.log = "setUp "</p>
<p>def testMethod(self):</p>
<p>self.log = self.log + "testMethod "</p>
<p>def tearDown(self):</p>
<p>self.log = self.log + "tearDown "</p>
<empty-line></empty-line><p>Шаблон «Строка-журнал» (Log String) особенно полезен в случае, когда вы реализуете шаблон «Наблюдатель» (Observer) и желаете протестировать порядок поступления оповещений. Если вас прежде всего интересует, какие именно оповещения генерируются, однако порядок их поступления для вас не важен, вы можете создать множество строк, добавлять строки в множество при обращении к методам и в выражении assert использовать операцию сравнения множеств.</p>
<p>Шаблон «Строка-журнал» (Log String) хорошо сочетается с шаблоном «Самошунтирование» (Self Shunt). Объект-тест реализует методы шунтируемого интерфейса так, что каждый из них добавляет запись в строку-журнал, затем проверяется корректность этих записей.</p>
<subtitle><emphasis><strong>Тестирование обработки ошибок (Crush Test Dummy)</strong></emphasis></subtitle><p>Как можно протестировать работу кода, обращение к которому происходит в случае ошибки, возникновение которой маловероятно? Создайте специальный объект, который вместо реальной работы генерирует исключение.</p>
<p>Непротестированный код считается неработающим. Но что же тогда делать с кодом обработки ошибок? Надо ли его тестировать? Только в случае, если вы хотите, чтобы он работал.</p>
<p>Предположим, что мы хотим проверить, что происходит с нашим приложением в случае, если на диске не остается свободного места. Неужели для этого необходимо вручную создавать огромное количество файлов? Есть альтернатива. Мы можем <emphasis>сымитировать</emphasis> заполнение диска, фактически использовав шаблон «Подделка» (Fake It).</p>
<p>Вот наш тест для класса File:</p>
<empty-line></empty-line><p>private class FullFile extends File {</p>
<p>public FullFile(String path) {</p>
<p>super(path);</p>
<p>}</p>
<p>public boolean createNewFile() throws IOException {</p>
<p>throw new IOException();</p>
<p>}</p>
<p>}</p>
<empty-line></empty-line><p>Теперь мы можем написать тест <emphasis>ожидаемого</emphasis> исключения:</p>
<empty-line></empty-line><p>public void testFileSystemError() {</p>
<p>File f = new FullFile("foo");</p>
<p>try {</p>
<p>saveAs(f);</p>
<p>fail();</p>
<p>} catch (IOException e) {</p>
<p>}</p>
<p>}</p>
<empty-line></empty-line><p>Тест кода обработки ошибки напоминает шаблон «Поддельный объект» (Mock Object), однако в данном случае нам не надо подделывать весь объект. Для реализации этой методики удобно использовать анонимные внутренние классы языка Java. При этом вы можете переопределить только один необходимый вам метод. Сделать это можно прямо внутри теста, благодаря чему код теста станет более понятным:</p>
<empty-line></empty-line><p>public void testFileSystemError() {</p>
<p>File f = new File("foo") {</p>
<p>public boolean createNewFile() throws IOException {</p>
<p>throw new IOException();</p>
<p>}</p>
<p>};</p>
<p>try {</p>
<p>saveAs(f);</p>
<p>fail();</p>
<p>} catch (IOException e) {</p>
<p>}</p>
<p>}</p>
<subtitle><emphasis><strong>Сломанный тест (Broken Test)</strong></emphasis></subtitle><p>Как следует завершить сеанс программирования, если вы программируете в одиночку? Оставьте последний тест неработающим.</p>
<p>Этому приему научил меня Ричард Гэбриел (Richard Gabriel). Вы заканчиваете сеанс на середине предложения. Когда вы возвращаетесь к работе, вы смотрите на начало предложения и вспоминаете, о чем вы думали, когда писали его. Вспомнив ход своих мыслей, вы завершаете предложение и продолжаете работу. Если по возвращении к работе вам не надо завершать никакого предложения, вы вынуждены потратить несколько минут, чтобы сначала просмотреть уже написанный код, изучить список задач, вспомнить, над чем вы собирались работать, затем попытаться восстановить прежнее состояние ваших мыслей и наконец приступить к работе.</p>
<p>Я использовал подобный трюк при работе над моими одиночными проектами и мне очень понравился эффект. В конце рабочего сеанса следует написать тест и запустить его, чтобы убедиться, что он не работает. Вернувшись к коду, вы сразу увидите место, откуда можно продолжить. Вы получаете хорошо заметную закладку, которая помогает вам вспомнить, о чем вы думали. Оставленный неработающим тест должен быть прост в реализации, благодаря чему вы сможете быстро выйти на прежний маршрут и продолжить движение к победе.</p>
<p>Сначала я думал, что оставленный недоделанным тест будет действовать мне на нервы. Однако нет. Ведь вся программа в целом еще далека от завершения, один сломанный тест не сделает ее менее завершенной, и я отлично знаю об этом. Возможность быстро восстановить общий ход разработки спустя несколько недель простоя стоит того, чтобы немножко поступиться принципами и оставить работу, имея перед глазами красную полосу.</p>
<subtitle><emphasis><strong>Чистый выпускаемый код (Clean Check-in)</strong></emphasis></subtitle><p>Как следует завершить сеанс программирования, если вы программируете в составе команды? Все ваши тесты должны работать.</p>
<cite><p><emphasis>Я противоречу сам себе? Да.</emphasis></p>
<text-author><emphasis>Бубба Уитман (Bubba Whitman), брат Уолта – портового грузчика</emphasis></text-author></cite><p>Когда вы работаете над кодом не один, а вместе с вашими коллегами, ситуация полностью меняется. Когда вы возвращаетесь к работе над кодом, над которым помимо вас работают еще несколько человек, вы не можете сказать точно, что именно произошло с кодом с того момента, как вы видели его последний раз. По этой причине, прежде чем выпускать разрабатываемый вами код, убедитесь, что все тесты выполняются успешно. (Это напоминает правило изоляции тестов, в соответствии с которым каждый тест гарантированно оставляет систему в хорошем известном состоянии. Это правило можно применить и в отношении программистов, которые поочередно интегрируют свой код в систему, каждый раз проверяя, остается система в хорошем состоянии или нет.)</p>
<p>Набор тестов, которые вы запускаете в ходе интеграции, может быть существенно объемнее набора тестов, который вы запускаете каждую минуту в процессе разработки функциональности. (До того времени, пока это не станет слишком утомительным, я рекомендую вам постоянно запускать полный набор тестов.) Что делать, если при попытке интеграции вы обнаружили, что один тест из полного набора завершается неудачей?</p>
<p>Самое простое правило: отбросьте проделанную работу и начните все заново. Сломанный сигнализирует, что вы не обладаете достаточным запасом знаний, чтобы запрограммировать то, над чем вы работаете. Если команда будет действовать в соответствии с этим правилом, у ее членов появится тенденция выполнять интеграцию более часто, так как тот, кто успеет приступить к интеграции раньше других, не рискует потерять проделанную работу. По всей видимости, частая интеграция и проверка – это неплохая практика.</p>
<p>Существует другой, менее строгий подход: вы можете исправить дефект и попробовать снова выполнить интеграцию. Однако не забывайте, что вы не должны слишком долго занимать интеграционные ресурсы: если вы не можете решить проблему в течение нескольких минут, откажитесь от идеи интеграции и начните работу заново. Об этом можно не говорить, но я все-таки скажу, что комментирование одного теста с целью заставить работать весь набор строго запрещается и должно приводить к самым серьезным карательным санкциям.</p>
</section><section><title><p>28. Шаблоны зеленой полосы</p>
</title><p>Когда у вас есть сломанный тест, вы должны заставить его работать. Если вы рассматриваете красную полосу как состояние, из которого следует выйти как можно быстрее, вы должны овладеть приемами быстрого получения зеленой полосы. Используйте следующие шаблоны, чтобы заставить ваш тест выполниться (даже если полученный в результате этого код не просуществует и часа).</p>
<subtitle><emphasis><strong>Подделка (Fake It)</strong></emphasis></subtitle><p>Если у вас есть тест, завершающийся неудачей, какой должна быть самая первая реализация? Сделайте так, чтобы тестируемый метод возвращал константу. После того как тест начал работать, постепенно трансформируйте константу в выражение с использованием переменных.</p>
<p>Пример использования этого подхода продемонстрирован в ходе разработки нашей реализации xUnit. Вначале мы использовали строковую константу:</p>
<empty-line></empty-line><p>return «1 run, 0 failed»</p>
<empty-line></empty-line><p>Затем эта строка была преобразована в выражение:</p>
<empty-line></empty-line><p>return «%d run, 0 failed» % self.runCount</p>
<empty-line></empty-line><p>Однако этим дело не кончилось. В конце мы получили выражение:</p>
<empty-line></empty-line><p>return «%d run, %d failed» % (self.runCount, self failureCount)</p>
<empty-line></empty-line><p>Шаблон «Подделка» (Fake It) напоминает страховочную веревку, которая соединяет вас с верхней точкой маршрута, когда вы карабкаетесь по скале. Пока что вы еще не забрались на самый верх (тест на месте и работает, но тестируемый код некорректен). Однако в любой точке маршрута вы держитесь за веревку и знаете, что когда достигнете самого верха, то будете в безопасности (тест работает в ходе рефакторинга, а также после получения окончательного кода).</p>
<p>Шаблон «Подделка» (Fake It) многим может показаться совершенно бесполезным. Зачем писать код, который абсолютно точно придется заменить другим? Дело в том, что иметь хоть какой-то работающий код – это лучше, чем вообще не иметь работающего кода, в особенности если у вас есть тесты, которые могут доказать работоспособность кода. Петер Хансен (Peter Hansen) рассказал мне следующую историю:</p>
<p><emphasis>Буквально вчера два новичка в области TDD – мой партнер и я – решили в точности следовать букве закона. То есть мы написали тест, а затем написали самый простой, но совершенно бесполезный код, который обеспечивал срабатывание теста. Пока мы писали этот код, мы обнаружили, что тест написан неправильно</emphasis>.</p>
<p>Каким образом поддельная реализация подсказала им, что написанный ими тест некорректен? Я понятия не имею, однако я счастлив, что они вовремя обнаружили это. Быть может, если они не воспользовались бы поддельной реализацией, они пошли бы по ложному пути. Возможно, исправление связанных с этим ошибок обошлось бы им дороже.</p>
<p>При использовании шаблона «Подделка» (Fake It) возникает как минимум два положительных эффекта:</p>
<p><emphasis> Психологический</emphasis>. Если перед вами зеленая полоса, вы чувствуете себя совершенно иначе, чем когда перед вами красная полоса. Когда полоса зеленая, вы знаете, на чем стоите. Вы можете смело и уверенно приступать к рефакторингу.</p>
<p><emphasis> Контроль над объемом работы</emphasis>. Программисты привыкли пытаться предвидеть появление в будущем самых разнообразных проблем. Если вы начинаете с конкретного примера и затем осуществляете обобщение кода, это помогает вам избавиться от лишних опасений. Вы можете сконцентрироваться на решении конкретной проблемы и поэтому выполнить работу лучше. При переходе к следующему тесту вы опять же концентрируетесь на нем, так как знаете, что предыдущий тест гарантированно работает.</p>
<p>Нарушает ли шаблон «Подделка» (Fake It) правило о том, что не следует писать код, который вам не потребуется? Я так не думаю, ведь на этапе рефакторинга вы удаляете дублирование данных между тестом и тестируемым кодом. Допустим, я написал<a type="note" l:href="#n_17">[17]</a>:</p>
<empty-line></empty-line><p>assertEquals(new MyDate(«28.2.02»), new MyDate(«1.3.02»). yesterday());</p>
<empty-line></empty-line><p><strong>MyDate</strong></p>
<p>public MyDate yesterday() {</p>
<p>return new MyDate("28.2.02");</p>
<p>}</p>
<empty-line></empty-line><p>Между тестом и кодом существует дублирование. Попробуем исправить ситуацию:</p>
<empty-line></empty-line><p><strong>MyDate</strong></p>
<p>public MyDate yesterday() {</p>
<p>return new MyDate(new MyDate("1.3.02"). days()-1);</p>
<p>}</p>
<empty-line></empty-line><p>Однако дублирование по-прежнему присутствует. Чтобы избавиться от него, заменяем MyDate(«1.3.02») на this (в моем тесте эти значения равны). Получается:</p>
<empty-line></empty-line><p><strong>MyDate</strong></p>
<p>public MyDate yesterday() {</p>
<p>return new MyDate(this.days()-1);</p>
<p>}</p>
<empty-line></empty-line><p>Однако увидеть возможность подобных подстановок с первого взгляда удается далеко не всегда и далеко не всем, поэтому для пущей ясности вы можете использовать триангуляцию, по крайней мере до тех пор, пока вам не надоест. Когда вам надоест, вы чаще будете пользоваться шаблоном «Подделка» (Fake It) или «Очевидная реализация» (Obvious Implementation).</p>
<subtitle><emphasis><strong>Триангуляция (Triangulate)</strong></emphasis></subtitle><p>Какой самый консервативный способ позволяет формировать абстракцию при помощи тестов? Делайте код абстрактным только в случае, если у вас есть два или более примера.</p>
<p>Рассмотрим пример. Предположим, мы хотим написать функцию, которая возвращает сумму двух целых чисел. Мы пишем:</p>
<empty-line></empty-line><p>public void testSum() {</p>
<p>assertEquals(4, plus(3, 1));</p>
<p>}</p>
<empty-line></empty-line><p>private int plus(int augend, int addend) {</p>
<p>return 4;</p>
<p>}</p>
<empty-line></empty-line><p>Чтобы получить представление о правильном дизайне, мы добавляем еще один пример:</p>
<empty-line></empty-line><p>public void testSum() {</p>
<p>assertEquals(4, plus(3, 1));</p>
<p>assertEquals(7, plus(3, 4));</p>
<p>}</p>
<empty-line></empty-line><p>Теперь, когда у нас есть еще один пример, мы можем сделать реализацию метода plus() абстрактной:</p>
<empty-line></empty-line><p>private int plus(int augend, int addend) {</p>
<p>return augend + addend;</p>
<p>}</p>
<empty-line></empty-line><p>Триангуляция выглядит привлекательно, так как правила ее выполнения вполне понятны. Правила для шаблона «Подделка» (Fake It) основаны на ощущении дублирования кода между тестом и поддельным кодом. Это ощущение может быть субъективным, поэтому правила выглядят несколько туманными. Несмотря на то, что они кажутся простыми, правила триангуляции создают замкнутый цикл. После того как мы написали два выражения assert и сформировали абстрактную корректную реализацию метода plus(), мы можем уничтожить одно из выражений assert, так как теперь оно является избыточным. А сделав это, мы сможем упростить реализацию plus(), чтобы этот метод возвращал константу. После этого нам надо будет снова добавить выражение assert.</p>
<p>Я использую триангуляцию только в случае, если я действительно не уверен, какая абстракция является корректной. В других ситуациях я предпочитаю использовать шаблон «Подделка» (Fake It) или «Очевидная реализация» (Obvious Implementation).</p>
<subtitle><emphasis><strong>Очевидная реализация (Obvious Implementation)</strong></emphasis></subtitle><p>Как реализоать простую операцию? Просто реализуйте ее.</p>
<p>Шаблоны «Подделка» (Fake It) и «Триангуляция» (Triangulate) позволяют вам двигаться маленькими шажками. Но иногда вы абсолютно уверены в том, как можно корректно реализовать операцию. Вперед! Пишите то, что вы думаете. Например, должен ли я использовать шаблон «Подделка» (Fake It) для реализации чего-либо столь же простого, как метод plus()? Как правило, нет. Обычно для таких простых методов я просто пишу очевидную реализацию. Если при этом передо мной неожиданно появляется красная полоса за красной полосой, я перехожу на более короткий шаг.</p>
<p>В шаблонах «Подделка» (Fake It) и «Триангуляция» (Triangulate) не существует никакой особенной добродетели. Если вы знаете, что писать, и если это получится достаточно быстро, то смело пишите готовый код. Однако помните, что, используя только очевидную реализацию, вы требуете от себя совершенства<a type="note" l:href="#n_18">[18]</a>. С психологической точки зрения это может быть разрушительный ход. Что, если написанное вами на самом деле не является самым простым изменением, которое заставляет тест работать? Что, если ваш партнер покажет вам еще более простой вариант кода? Вы проиграли! Ваш мир рухнул! Вы в ступоре.</p>
<p>Известный слоган гласит: «чистый код, который работает». Если вы будете решать проблему «чистый код» одновременно с проблемой «который работает», для вас это может оказаться слишком много. Как только вы поймете это, вернитесь обратно к решению проблемы «который работает» и только после этого принимайтесь за решение проблемы «чистый код».</p>
<p>При использовании шаблона «Очевидная реализация» (Obvious Implementation) следите за тем, насколько часто вы сталкиваетесь с красной полосой. Часто приходится попадать в ловушку: я записываю очевидную реализацию, но она не работает. Но теперь я точно знаю, что именно я должен написать. Поэтому я вношу в код изменения. Однако тест по-прежнему не работает. Но теперь-то я уж точно знаю… Это часто случается при возникновении ошибок типа «индекс отличается на единицу» и «положительные/отрицательные числа».</p>
<p>Прежде всего вы должны следить за соблюдением ритма красный – зеленый – рефакторинг. Очевидная реализация – это вторая передача. Будьте готовы снизить скорость, если ваш мозг начинает выписывать чеки, которые не могут быть оплачены вашими пальцами.</p>
<subtitle><emphasis><strong>От одного ко многим (One to Many)</strong></emphasis></subtitle><p>Как реализовать операцию с коллекцией объектов? Сначала реализуйте эту операцию, манипулирующую единственным объектом, затем модернизируйте ее для работы с коллекцией таких объектов.</p>
<p>Например, предположим, что мы разрабатываем функцию, которая суммирует массив чисел. Мы можем начать с одного числа:</p>
<empty-line></empty-line><p>public void testSum() {</p>
<p>assertEquals(5, sum(5));</p>
<p>}</p>
<p>private int sum(int value) {</p>
<p>return value;</p>
<p>}</p>
<empty-line></empty-line><p>(Я добавил метод sum() в класс TestCase, чтобы не создавать новый класс ради одного метода.)</p>
<p>Теперь мы хотим протестировать sum(new int[] {5, 7}). Для начала добавим в метод sum() параметр, соответствующий массиву целых чисел:</p>
<empty-line></empty-line><p>public void testSum() {</p>
<p>assertEquals(5, sum(5, new int[] {5}));</p>
<p>}</p>
<p>private int sum(int value, int[] values) {</p>
<p>return value;</p>
<p>}</p>
<empty-line></empty-line><p>Этот этап можно рассматривать как пример применения шаблона «Изоляция изменения» (Isolate Change). После того как мы добавили параметр, мы можем менять реализацию, не затрагивая код теста.</p>
<p>Теперь мы можем использовать коллекцию вместо единственного значения:</p>
<empty-line></empty-line><p>private int sum(int value, int[] values) {</p>
<p>int sum = 0;</p>
<p>for (int i = 0; i &lt; values.length; i++)</p>
<p>sum += values[i];</p>
<p>return sum;</p>
<p>}</p>
<empty-line></empty-line><p>Теперь можно удалить неиспользуемый параметр:</p>
<empty-line></empty-line><p>public void testSum() {</p>
<p>assertEquals(5, sum(new int[] {5}));</p>
<p>}</p>
<p>private int sum(int[] values) {</p>
<p>int sum = 0;</p>
<p>for (int i = 0; i &lt; values.length; i++)</p>
<p>sum += values[i];</p>
<p>return sum;</p>
<p>}</p>
<empty-line></empty-line><p>Предыдущий шаг – это тоже демонстрация шаблона «Изоляция изменения» (Isolate Change). Мы изменили код и в результате можем менять тест, не затрагивая код. Теперь мы можем расширить тест, как планировали:</p>
<empty-line></empty-line><p>public void testSum() {</p>
<p>assertEquals(12, sum(new int[] {5, 7}));</p>
<p>}</p>
</section><section><title><p>29. Шаблоны xUnit</p>
</title><p>В этой главе рассматриваются шаблоны, предназначенные для использования при работе с xUnit.</p>
<subtitle><emphasis><strong>Проверка утверждений</strong></emphasis></subtitle><p>Как убедиться в том, что тест работает правильно? Напишите логическое выражение, которое автоматически подтвердит ваше мнение о том, что код работает.</p>
<p>Если мы хотим сделать тесты полностью автоматическими, значит, абсолютно все предположения о работе тестируемого кода необходимо превратить в тесты, при этом результат выполнения этих тестов должен говорить нам, работает код корректно или нет. Проще говоря, мы должны обладать возможностью щелкнуть на кнопке и через короткое время узнать, работает код корректно или нет. Отсюда следует, что</p>
<p>• в результате выполнения теста должно получиться логическое значение: «истина» (True) указывает, что все в порядке, а «ложь» – что произошло нечто непредвиденное;</p>
<p>• проверка результата каждого теста выполняется компьютером автоматически при помощи какой-либо разновидности оператора assert().</p>
<p>Мне приходилось видеть выражения наподобие assertTrue(rectangle.area()!= 0). Чтобы тест выполнился успешно, метод area() должен вернуть любое ненулевое значение – это не очень полезный тест. Делайте тесты более конкретными. Если площадь прямоугольника должна быть равна 50, так и пишите: assertTrue(rectangle.area() == 50). Во многих реализациях xUnit присутствует специальное выражение assert() для тестирования равенства (эквивалентности). Отличительная его черта состоит в том, что вместо одного логического параметра выражение assertEquals() принимает два произвольных объекта и пытается определить, являются ли они эквивалентными. Преимущество состоит в том, что в случае неудачи выражение assertEquals() сгенерирует более информативное сообщение с указанием двух несовпадающих значений. Ожидаемое значение, как правило, указывается первым. Например, предыдущее выражение в среде JUnit можно переписать следующим образом: assertEquals(50, rectangle.area()).</p>
<p>Думать об объектах, как о черных ящиках, достаточно тяжело. Представим, что у нас есть объект Contract, состояние которого хранится в поле status и может быть экземпляром класса Offered или Running. В этом случае можно написать тест исходя из предполагаемой реализации:</p>
<empty-line></empty-line><p>Contract contract = new Contract(); // по умолчанию состояние Offered</p>
<p>contract.begin(); // состояние меняется на Running</p>
<p>assertEquals(Running.class, contract.status.class);</p>
<empty-line></empty-line><p>Этот тест слишком сильно зависит от текущей реализации объекта status. Однако тест должен завершаться успешно, даже если поле status станет логическим значением. Может быть, когда status меняется на Running, можно узнать дату начала работы над контрактом:</p>
<empty-line></empty-line><p>assertEquals(…, contract.startDate()); // генерирует исключение, если</p>
<p>// status является экземпляром Offered</p>
<empty-line></empty-line><p>Я признаю, что пытаюсь плыть против течения, когда настаиваю на том, что все тесты должны быть написаны только с использованием общедоступного (public) протокола. Существует специальный пакет JXUnit, который является расширением JUnit и позволяет тестировать значения переменных, даже тех, которые объявлены как закрытые.</p>
<p>Желание протестировать объект в рамках концепции белого ящика – это не проблема тестирования, это проблема проектирования. Каждый раз, когда у меня возникает желание протестировать значение переменной-члена, чтобы убедиться в работоспособности кода, я получаю возможность улучшить дизайн системы. Если я забываю о своих опасениях и просто проверяю значение переменной, я теряю такую возможность. Иначе говоря, если идея об улучшении дизайна не приходит мне в голову, ничего не поделаешь. Я проверяю значение переменной, смахиваю непрошеную слезу, вношу соответствующую отметку в список задач и продолжаю двигаться вперед, надеясь, что наступит день, когда смогу найти подходящее решение.</p>
<p>Самая первая версия xUnit для Smalltalk (под названием SUnit) обладала очень простыми выражениями assert. Если одно из выражений терпело неудачу, автоматически открывалось окно отладчика, вы исправляли код и продолжали работу. Среда разработки Java не настолько совершенна, к тому же построение приложений на Java часто выполняется в пакетном режиме, поэтому имеет смысл добавлять в выражение assert() дополнительную информацию о проверяемом условии. Чтобы в случае неудачи выражения assert() можно было вывести на экран дополнительную информацию.</p>
<p>В JUnit это реализуется при помощи необязательного первого параметра<a type="note" l:href="#n_19">[19]</a>. Например, если вы напишете assertTrue(«Должно быть True», false) и тест не сработает, то вы увидите на экране приблизительно следующее сообщение: Assertion failed: Должно быть True. Обычно подобного сообщения достаточно, чтобы направить вас напрямую к источнику ошибки в коде. В некоторых группах разработчиков действует жесткое правило, что все выражения assert() должны снабжаться подобными информационными сообщениями. Попробуйте оба варианта и самостоятельно определите, окупаются ли для вас затраты, связанные с информационными сообщениями.</p>
<subtitle><emphasis><strong>Фикстура<a type="note" l:href="#n_20">[20]</a> (Fixture)</strong></emphasis></subtitle><p>Как создаются общие объекты, которые используются в нескольких тестах? Конвертируйте локальные переменные из тестов в переменные-члены класса TestCase. Переопределите метод setUp() и инициализируйте в нем эти переменные (то есть выполните создание всех необходимых объектов).</p>
<p>Если мы привыкли удалять дублирование из функционального (тестируемого) кода, должны ли мы удалять его из тестирующего кода? Может быть.</p>
<p>Существует проблема: зачастую вам приходится писать больше кода для того, чтобы установить объекты, используемые тестируемым методом, в интересующее вас состояние. Код, инициализирующий объекты, часто оказывается одинаковым для нескольких тестов. Такие объекты называются <emphasis>фикстурой</emphasis> теста (используется также английский термин <emphasis>scaffolding – строительные леса, подмостки</emphasis>). Дублирование подобного кода – это плохо. Вот две основные причины:</p>
<p>• написание подобного кода требует дополнительного времени, даже если мы просто копируем блоки текста через буфер обмена. Но наша задача – добиться того, чтобы написание тестов занимало как можно меньше времени;</p>
<p>• если приходится вручную менять интерфейс, перед нами встает необходимость изменять его в нескольких разных тестах (именно этого всегда следует ожидать от дублирования).</p>
<p>Однако дублирование кода инициализации объектов обладает также некоторыми преимуществами. Если код инициализации располагается непосредственно рядом с тестирующими выражениями assert(), весь код теста можно прочитать от начала и до конца. Если мы выделили код инициализации в отдельный метод, нам приходится помнить о том, что этот метод вызывается, нам приходится вспоминать, как именно выглядят объекты, и только вспомнив все это, мы можем написать остальную часть теста.</p>
<p>Среда xUnit поддерживает оба стиля написания тестов. Если вы думаете, что читателям будет сложно вспомнить объекты фикстуры, вы можете разместить код создания фикстуры непосредственно в теле теста. Однако вы также можете переместить этот код в метод с названием setUp(). В этом методе вы можете создать все объекты, которые будут использоваться в тестовых методах.</p>
<p>Далее приводится пример, который слишком прост, чтобы мотивировать выделение общего кода фикстуры, но зато достаточно короток, чтобы поместиться в данной книге. Мы можем написать:</p>
<empty-line></empty-line><p><strong>EmptyRectangleTest</strong></p>
<p>public void testEmpty() {</p>
<p>Rectangle empty = new Rectangle(0,0,0,0);</p>
<p>assertTrue(empty.isEmpty());</p>
<p>}</p>
<empty-line></empty-line><p>public void testWidth() {</p>
<p>Rectangle empty = new Rectangle(0,0,0,0);</p>
<p>assertEquals(0.0, empty.getWidth(), 0.0);</p>
<p>}</p>
<empty-line></empty-line><p>(Помимо прочего здесь также демонстрируется версия assertEquals() для чисел с плавающей точкой, которая принимает третий параметр – точность сравнения.) Мы можем избавиться от дублирования, написав:</p>
<empty-line></empty-line><p><strong>EmptyRectangleTest</strong></p>
<p>private Rectangle empty;</p>
<empty-line></empty-line><p>public void setUp() {</p>
<p>empty = new Rectangle(0,0,0,0);</p>
<p>}</p>
<empty-line></empty-line><p>public void testEmpty() {</p>
<p>assertTrue(empty.isEmpty());</p>
<p>}</p>
<p>public void testWidth() {</p>
<p>assertEquals(0.0, empty.getWidth(), 0.0);</p>
<p>}</p>
<empty-line></empty-line><p>Общий код выделен в виде отдельного метода. Среда xUnit гарантирует, что метод setUp() объекта TestCase будет обязательно вызван перед обращением к любому тестовому методу этого объекта. Теперь тестовые методы выглядят проще, однако, прежде чем понять их смысл, мы должны вспомнить о существовании метода setUp() и уточнить, что происходит внутри этого метода.</p>
<p>Какой из этих двух стилей предпочтительней? Попробуйте использовать каждый из них. Я фактически всегда выделяю общий код фикстуры и перемещаю его в метод setUp(), однако у меня хорошая память. Те, кто читает мои тесты, часто жалуются, что им приходится вспоминать слишком о многом. Значит, возможно, мне следует выделять меньшей объем кода, чтобы сделать тесты более понятными.</p>
<p>Взаимоотношения между подклассами класса TestCase и экземплярами этих подклассов являются наиболее запутанной стороной инфраструктуры xUnit. Каждый новый тип фикстуры требует создания нового подкласса класса TestCase. Каждая новая фикстура создается внутри экземпляра подкласса, используется один раз, а затем уничтожается.</p>
<p>В предыдущем примере, если мы хотим написать тесты для непустого прямоугольника (Rectangle), нам придется создать новый класс, который можно назвать, например, NormalRectangleTest. У этого класса будет свой собственный метод setUp(), в котором будет создан новый экземпляр Rectangle, необходимый ему для тестирования. Этот экземпляр Rectangle будет соответствовать непустому прямоугольнику. В общем случае, если я хочу использовать несколько отличающуюся фикстуру, я создаю новый подкласс класса TestCase.</p>
<p>Это означает, что не существует прямого простого соответствия между классами тестов и функциональными (тестируемыми) классами. Иногда одна фикстура используется для тестирования нескольких классов (подобное случается нечасто). Иногда для тестирования единственного функционального класса требуется создать две или три фикстуры. На практике в большинстве случаев получается, что количество классов тестов приблизительно совпадает с количеством функциональных классов. Однако это происходит вовсе не потому, что для каждого функционального класса вы создаете один-единственный класс теста.</p>
<subtitle><emphasis><strong>Внешняя фикстура (External Fixture)</strong></emphasis></subtitle><p>Как осуществляется освобождение внешних ресурсов в фикстуре? Переопределите метод tearDown() и освободите в нем ресурсы, выделенные в ходе создания фикстуры.</p>
<p>Помните, что каждый тест должен оставить рабочую среду в том же состоянии, в котором она была до того, как тест начал работу. Например, если внутри теста вы открываете файл, вы должны позаботиться о том, чтобы закрыть его перед тем, как тест завершит работу. Вы можете написать:</p>
<empty-line></empty-line><p>testMethod(self):</p>
<p>file = File("foobar"). open()</p>
<p>try:</p>
<p>…âûïîëíèòü òåñò…</p>
<p>finally:</p>
<p>file.close()</p>
<empty-line></empty-line><p>Если файл используется в нескольких тестах, вы можете сделать его частью общей фикстуры:</p>
<empty-line></empty-line><p>setUp(self):</p>
<p>self.file = File("foobar"). open()</p>
<p>testMethod(self):</p>
<p>try:</p>
<p>…выполнить тест…</p>
<p>finally:</p>
<p>self.file.close()</p>
<empty-line></empty-line><p>Во-первых, возникает неприятное дублирование выражений finally – это означает, что мы упустили что-то в дизайне. Во-вторых, при написании подобного метода можно легко допустить ошибку, например забыть добавить ключевое слово finally или вообще забыть о необходимости закрытия файла. Наконец, в этом тесте существует три сбивающих с толку строки – try, finally и сама команда close, – эти выражения не относятся непосредственно к процедуре тестирования.</p>
<p>Инфраструктура xUnit гарантирует вызов метода под названием tearDown() после выполнения тестового метода. Метод tearDown() будет вызван вне зависимости от того, что случится внутри тестового метода (однако следует иметь в виду, что, если сбой произойдет в ходе выполнения метода setUp(), метод tearDown() вызываться не будет). Мы можем преобразовать предыдущий тест следующим образом:</p>
<empty-line></empty-line><p>setUp(self):</p>
<p>self.file = File("foobar"). open()</p>
<p>testMethod(self):</p>
<p>…выполнить тест…</p>
<p>tearDown(self):</p>
<p>self.file.close()</p>
<subtitle><emphasis><strong>Тестовый метод (Test Method)</strong></emphasis></subtitle><p>Что такое единичный тест? Это метод, имя которого начинается с префикса test.</p>
<p>В процессе разработки вам придется иметь дело с сотнями, а может быть, и тысячами тестов, как можно уследить за всеми этими тестами?</p>
<p>Языки объектно-ориентированного программирования обеспечивают трехуровневую организацию исходного кода:</p>
<p>• модуль (в языке Java – <emphasis>пакет</emphasis>, по-английски, <emphasis>package</emphasis>);</p>
<p>• класс;</p>
<p>• метод.</p>
<p>Если мы пишем тесты как обычный исходный код, мы должны найти способ организации тестов с использованием элементов этой структуры. Если мы используем классы для представления фикстур, значит, методы этих классов являются естественным местом размещения тестирующего кода. Все тесты, использующие некоторую фикстуру, должны быть методами одного класса. Тесты, работающие с другой фикстурой, должны располагаться в другом классе.</p>
<p>В xUnit используется соглашение, в соответствии с которым имя тестового метода должно начинаться с префикса test. Специальные инструменты могут автоматически производить поиск таких методов и создавать из них наборы тестов (TestSuite). Остальная часть имени теста должна информировать будущего, ни о чем не ведающего читателя, зачем написан данный тест. Например, в наборе тестов, созданных при разработке инфраструктуры JUnit, можно обнаружить тест с именем testAssertPosInfinityNotEqualsNeglnfinity. Я не помню, чтобы я писал этот тест, однако, исходя из имени, могу предположить, что в какой то момент разработки было обнаружено, что код метода assert() инфраструктуры JUnit для чисел с плавающей точкой не делал различия между положительной и отрицательной бесконечностью. Использовав тест, я могу быстро найти код JUnit, осуществляющий сравнение чисел с плавающей точкой, и посмотреть, как осуществляется обработка положительной и отрицательной бесконечности. (На самом деле код выглядит не идеально – для поддержки бесконечности используется условный оператор).</p>
<p>Код тестового метода должен легко читаться и быть максимально прямолинейным. Если вы разрабатываете тест и видите, что его код становится слишком длинным, попробуйте поиграть в «детские шажки». Цель игры – написать самый маленький тестовый метод, который представляет собой реальный прогресс в направлении вашей конечной цели. Размер в три строки, судя по всему, является минимальным размером (если, конечно, вы не хотите делать тест намеренно бессмысленным). И постоянно помните о том, что вы пишете тесты для людей, а не только для компьютера и себя самого.</p>
<p>Патрик Логан (Patrick Logan) рассказал об идее, с которой я намерен поэкспериментировать. Эта идея также описана Макконнеллом (McConnell)<a type="note" l:href="#n_21">[21]</a>, а также Кэйном (Caine) и Гордоном (Gordon)<a type="note" l:href="#n_22">[22]</a>:</p>
<p>В <emphasis>последнее время я фактически постоянно применяю методику «основных тезисов» в любой моей работе. Тестирование не является исключением. Когда я пишу тесты, я прежде всего записываю план из нескольких пунктов – тезисов, – которые я хотел бы реализовать в этом тесте. Например</emphasis>:</p>
<empty-line></empty-line><p>/* Добавить в пространство кортежей<a type="note" l:href="#n_23">[23]</a> */</p>
<p>/* Извлечь из пространства кортежей */</p>
<p>/* Читать из пространства кортежей */</p>
<empty-line></empty-line><p><emphasis>Это самые основные тезисы, однако я добавляю в каждую из этих категорий конкретные тесты. Когда я добавляю тесты, я добавляю в мой список тезисов еще один уровень комментариев:</emphasis></p>
<empty-line></empty-line><p>/* Добавить в пространство кортежей */</p>
<p>/* Извлечь из пространства кортежей */</p>
<p>/** Извлечение несуществующего элемента **/</p>
<p>/** Извлечение существующего элемента **/</p>
<p>/** Извлечение нескольких элементов **/</p>
<p>/* Читать из пространства кортежей */</p>
<empty-line></empty-line><p><emphasis>Как правило, мне хватает двух-трех уровней комментариев. Я не могу представить ситуацию, в которой мне могло бы потребоваться больше уровней. Список тезисов становится документацией контракта для тестируемого класса. Приведенные здесь примеры, конечно же, сокращены, однако в языках программирования, поддерживающих контракты, тезисы могли бы быть более конкретными. (Я не использую какие-либо добавления к Java, обеспечивающие автоматизацию в стиле Eiffel.)</emphasis></p>
<p><emphasis>Сразу же после самого низкого уровня комментариев располагается исходный код теста.</emphasis></p>
<subtitle><emphasis><strong>Тест исключения (Exception Test)</strong></emphasis></subtitle><p>Как можно протестировать ожидаемое исключение? Перехватите исключение и игнорируйте его, тест должен терпеть неудачу только в случае, если исключение не сгенерировано.</p>
<p>Предположим, что мы пишем код, осуществляющий поиск значения. Если значение не обнаружено, мы хотим сгенерировать исключение. Тестирование механизма поиска выполняется относительно просто:</p>
<empty-line></empty-line><p>public void testRate() {</p>
<p>exchange.addRate("USD", "GBP", 2);</p>
<p>int rate = exchange.findRate("USD", "GBP");</p>
<p>assertEquals(2, rate);</p>
<p>}</p>
<empty-line></empty-line><p>Тестирование исключения может оказаться неочевидным. Вот как мы это делаем:</p>
<empty-line></empty-line><p>public void testMissingRate() {</p>
<p>try {</p>
<p>exchange.findRate("USD", "GBP");</p>
<p>fail();</p>
<p>} catch (IllegalArgumentException expected) {</p>
<p>}</p>
<p>}</p>
<empty-line></empty-line><p>Если метод findRate() не генерирует исключения, произойдет обращение к методу fail() – это метод xUnit, который докладывает о том, что тест потерпел неудачу. Обратите внимание, что мы перехватываем только то исключение, которое должно быть сгенерировано методом findRate(). Благодаря этому, если будет сгенерировано какое-либо другое (неожиданное для нас) исключение (включая сбой метода assert), мы узнаем об этом.</p>
<subtitle><emphasis><strong>Все тесты (All Tests)</strong></emphasis></subtitle><p>Как можно запустить все тесты вместе? Создайте тестовый набор, включающий в себя все имеющиеся тестовые наборы, – один для каждого пакета (package) и один, объединяющий в себе все тесты пакетов для всего приложения.</p>
<p>Предположим, вы добавили подкласс класса TestCase и в этот подкласс вы добавили тестовый метод. В следующий раз, когда будут выполняться все тесты, добавленный вами тестовый метод также должен быть выполнен. (Во мне опять проснулась привычка действовать в стиле TDD – должно быть, вы заметили, что предыдущее предложение – это эскиз теста, который я, наверное, написал бы, если бы не был занят работой над данной книгой.) К сожалению, в большинстве реализаций xUnit, равно как и в большинстве IDE, не поддерживается стандартный механизм запуска абсолютно всех тестов, поэтому в каждом пакете необходимо определить класс AllTests, который реализует статический метод suite(), возвращающий объект класса TestSuite. Вот класс AllTests для «денежного» примера:</p>
<empty-line></empty-line><p>public class AllTests {</p>
<p>public static void main(String[] args) {</p>
<p>junit.swingui.TestRunner.run(AllTests.class);</p>
<p>}</p>
<p>public static Test suite() {</p>
<p>TestSuite result = new TestSuite("TFD tests");</p>
<p>result.addTestSuite(MoneyTest.class);</p>
<p>result.addTestSuite(ExchangeTest.class);</p>
<p>result.addTestSuite(IdentityRateTest.class);</p>
<p>return result;</p>
<p>}</p>
<p>}</p>
<empty-line></empty-line><p>Вы также должны включить в класс AllTests() метод main(), благодаря чему класс можно будет запустить напрямую из IDE или из командной строки.</p>
</section><section><title><p>30. Шаблоны проектирования</p>
</title><p>В чем заключается основная идея шаблонов? Нам кажется, что мы постоянно сталкиваемся с разнообразными, неповторяющимися проблемами, однако на деле оказывается, что большая часть проблем, которые нам приходится решать, обусловлена используемыми нами инструментами, но не основной задачей, которая перед нами стоит<a type="note" l:href="#n_24">[24]</a>. Если исходить из этого предположения, то можно найти (и мы действительно находим) общие проблемы со стандартными решениями, несмотря на все разнообразие контекстов, в рамках которых нам приходится работать.</p>
<p>Использование объектов для организации вычислений – это один из лучших примеров стандартного решения, направленного на устранение множества общих проблем, с которыми программистам приходится сталкиваться при разработке самого разнообразного программного обеспечения. Колоссальный успех шаблонов проектирования (design patterns) является доказательством общности проблем, с которыми сталкиваются программисты, использующие объектно-ориентированные языки программирования<a type="note" l:href="#n_25">[25]</a>. Книга <emphasis>Design Patterns</emphasis> («Паттерны проектирования») имела большой успех, однако ее популярность стала причиной сужения взгляда на шаблоны проектирования. Что я имею в виду? Книга рассматривает дизайн как фазу разработки программы, однако авторы совершенно не учитывают, что рефакторинг – это мощный инструмент формирования дизайна. Дизайн в рамках TDD требует несколько иного взгляда на шаблоны проектирования.</p>
<p>В данной главе я расскажу о нескольких полезных шаблонах проектирования. Безусловно, мое изложение не претендует на полноту. Представленная здесь информация может оказаться полезной при изучении рассматриваемых в книге примеров. Вот краткое перечисление рассмотренных здесь шаблонов:</p>
<p>• «Команда» (Command) – обращение к некоторому коду представляется в виде объекта, а не в виде простого сообщения;</p>
<p>• «Объект-значение» (Value Object) – после создания объекта его значение никогда не меняется, благодаря этому удается избежать проблем, связанных с наложением имен (aliasing);</p>
<p>• «Нуль-объект» (Null Object) – соответствует базовому случаю вычислений объекта;</p>
<p>• «Шаблонный метод» (Template Method) – представляет собой инвариантную последовательность операций, определяемую при помощи абстрактных методов, которые можно переопределить с помощью наследования;</p>
<p>• «Встраиваемый объект» (Pluggable Object) – представляет собой вариацию в виде объекта с двумя реализациями или большим их количеством;</p>
<p>• «Встраиваемый переключатель» (Pluggable Selector) – позволяет избежать создания многочисленных подклассов путем динамического обращения к различным методам для различных экземпляров класса;</p>
<p>• «Фабричный метод» (Factory Method) – вместо конструктора для создания объекта используется специальный метод;</p>
<p>• «Самозванец» (Imposter) – представляет собой вариацию путем создания новой реализации существующего протокола;</p>
<p>• «Компоновщик» (Composite) – композиция объектов ведет себя так же, как один объект;</p>
<p>• «Накапливающий параметр» (Collecting Parameter) – результаты вычислений, выполняемых в разных объектах, накапливаются в специальном объекте, который передается объектам, выполняющим вычисления, в качестве параметра.</p>
<p>В табл. 30.1 описывается, на каких этапах TDD используется тот или иной шаблон проектирования.</p>
<empty-line></empty-line><p><strong>Таблица 30.1.</strong> Использование шаблонов проектирования при разработке через тестирование (TDD)</p>
<image l:href="#i_012.png"></image><empty-line></empty-line><image l:href="#i_013.png"></image><empty-line></empty-line><subtitle><emphasis><strong>Команда (Command)</strong></emphasis></subtitle><p>Что делать, если выполнение некоторой операции представляет собой нечто более сложное, чем простое обращение к методу? Создайте объект, соответствующий этой операции, и обратитесь к этому объекту.</p>
<p>Передача сообщений – это отличный механизм. Языки программирования делают передачу сообщений синтаксически простым действием, а среды разработки позволяют с легкостью манипулировать сообщениями (например, автоматическое выполнение рефакторинга по переименованию метода). Однако в некоторых случаях простой передачи сообщения недостаточно.</p>
<p>Например, представьте, что вы хотели бы занести в журнал запись о том, что сообщение было передано. Для этой цели можно воспользоваться средствами языка (например, методы-обертки), однако простые операции журналирования – это далеко не все, в чем вы можете нуждаться. Представьте, что мы хотим вызвать некоторую процедуру, но несколько позднее. Для этой цели можно создать новый программный поток, сразу же приостановить его работу, а затем, когда это потребуется, запустить его. Однако в подобной ситуации нам придется иметь дело с параллельными потоками, а это может оказаться слишком тяжеловесным подходом.</p>
<p>Для выполнения операций с подобными дополнительными условиями зачастую требуются сложные затратные механизмы. Однако в большинстве случаев мы можем избежать излишней сложности и лишних затрат. Проблему вызова можно решить с помощью более конкретной и гибкой формы, чем сообщение. Для этого достаточно создать специальный объект. Создайте объект, представляющий собой вызов операции. Занесите в этот объект все необходимые параметры операции. Когда операция готова к выполнению, используйте для этого универсальный протокол, например метод run().</p>
<p>Отличным примером использования данного подхода является интерфейс Runnable языка Java:</p>
<empty-line></empty-line><p><strong>Runnable</strong></p>
<p>interface Runnable</p>
<p>public abstract void run();</p>
<empty-line></empty-line><p>В рамках реализации метода run() вы можете делать все, что вам нравится. К сожалению, Java не поддерживает синтаксически легковесного способа создания объектов Runnable и обращения к этим объектам, поэтому они не используются так часто, как их эквиваленты в других языках (блоки или лямбда-выражения в Smalltalk/Ruby или LISP).</p>
<subtitle><emphasis><strong>Объект-значение (Value Object)</strong></emphasis></subtitle><p>Как следует спроектировать объект, который будет широко использоваться, но для которого идентификация не имеет особого значения? Настройте состояние объекта в момент его создания и никогда не меняйте его. В результате выполнения любых операций с данным объектом должен получаться новый объект.</p>
<p>Объектно-ориентированный подход – это великолепная вещь. Надеюсь, я имею право написать эту фразу в данной книге. Объекты являются отличным способом организации логики для последующего понимания и роста. Однако существует одна маленькая проблема (хорошо, хорошо, вообще-то проблем больше, однако сейчас мы коснемся только одной из них).</p>
<p>Представьте, что я – объект и у меня есть прямоугольник (Rectangle). Я вычисляю некоторое значение, зависящее от этого прямоугольника, например его площадь. Чуть позже некто (например, другой объект) вежливо просит меня предоставить ему мой прямоугольник для выполнения некоторой операции. Чтобы не показаться невежливым, я предоставляю ему мой прямоугольник. А через пару мгновений, вы только посмотрите, прямоугольник был модифицирован у меня за спиной! Значение площади, которое я вычислил ранее, теперь не соответствует действительности, и не существует способа известить меня об этом.</p>
<p>Это классический пример проблемы наложения имен (aliasing). Если два объекта ссылаются на один и тот же третий объект и если один из первых двух тем или иным образом изменяет третий, общий для них, объект, второму объекту лучше не полагаться на текущее состояние общего объекта.</p>
<p>Существует несколько способов решения проблемы наложения имен. Во-первых, вы можете никому не отдавать объект, от состояния которого вы зависите. Вместо этого в случае необходимости вы можете создавать копии этого объекта. Такой подход может потребовать слишком много времени и слишком много пространства, кроме того, игнорируется ситуация, когда вы хотите сделать изменения некоторого объекта общими для нескольких других объектов, зависящих от его состояния. Еще одно решение – шаблон «Наблюдатель» (Observer). В этом случае, если вы зависите от состояния некоторого объекта, вы должны предварительно сообщить ему об этом, иначе говоря, зарегистрироваться. Объект, за состоянием которого следят, оповещает все зарегистрированные им объекты-наблюдатели о своем изменении. Шаблон «Наблюдатель» (Observer) может затруднить понимание последовательности выполнения операций, кроме того, логика формирования и удаления зависимостей между объектами выглядит далеко не идеальной.</p>
<p>Еще одно решение предлагает несколько ограничить возможности, которыми обладает типичный объект в рамках ООП. Образно говоря, объект становится «менее чем объектом». Что это значит? Обычные объекты обладают состоянием, которое изменяется с течением времени. Если мы захотим, мы можем запретить им меняться. Если у меня есть объект и я знаю, что он не может измениться, я могу передавать ссылки на этот объект любому другому объекту, не беспокоясь при этом о проблеме наложения имен. Если объект не поддерживает возможности своего изменения, никаких модификаций у меня за спиной не может произойти.</p>
<p>Я помню, как похожая ситуация возникла с целыми числами, когда я впервые изучал язык Smalltalk. Если я изменяю бит 2 на 1, почему все двойки не становятся шестерками?</p>
<empty-line></empty-line><p>a:= 2.</p>
<p>b:= a.</p>
<p>a:= a bitAt: 2 put: 1.</p>
<p><strong>a</strong> =&gt; 6</p>
<p><strong>b</strong> =&gt; 2</p>
<empty-line></empty-line><p>Целые числа – это значения, которые маскируются под объекты. В языке Small-talk это утверждение является истиной для небольших целых чисел и имитируется в случае, если целое число не умещается в машинное слово. Когда я устанавливаю бит, то получаю в свое распоряжение новый объект с установленным битом. Старый объект остается неизменным.</p>
<p>В рамках шаблона «Объект-значение» (Value Object) каждая операция должна возвращать новый объект, а первоначальный объект должен оставаться неизменным. Пользователи должны знать, что они используют объект-значение. В этом случае полученный объект следует сохранить (как в предыдущем примере). Конечно же, из-за необходимости создания новых объектов полученный в результате код может оказаться медленным. Однако в данном случае любые проблемы с производительностью должны решаться в точности так же, как и любые другие проблемы с производительностью: вы должны оценить производительность при помощи тестов с реальными данными, определить, насколько часто производится обращение к медленному коду, выполнить профилирование и определить, какой именно код должен быть оптимизирован и как лучше всего этого достичь.</p>
<p>Я предпочитаю использовать «Объект-значение» (Value Object) в ситуациях, когда операции, выполняемые над объектами, напоминают алгебру. Например, пересечение и объединение геометрических фигур, операции над значениями, с каждым из которых хранится единица измерения, а также операции символьной арифметики. Каждый раз, когда использование «Объект-значение» (Value Object) имеет хоть какой-то смысл, я пытаюсь его использовать, так как результирующий код проще читать и отлаживать.</p>
<p>Все объекты-значения должны реализовать операцию сравнения (а во многих языках подразумевается, что они должны реализовать также операцию хеширования). Если я имею один контракт и другой контракт и они не являются одним и тем же объектом, значит, они не равны. Однако если у меня есть одни пять франков и другие пять франков, для меня не имеет значения тот факт, что это два разных объекта – пять франков и в Африке пять франков – они равны.</p>
<subtitle><emphasis><strong>Нуль-объект (Null Object)</strong></emphasis></subtitle><p>Как реализовать специальные случаи использования объектов? Создать специальный объект, представляющий собой специальный случай. Специальный объект должен обладать точно таким же протоколом, что и обычный объект, но он должен вести себя специальным образом.</p>
<p>В качестве примера рассмотрим код, который я позаимствовал из java.io.File:</p>
<empty-line></empty-line><p><strong>java.io.File</strong></p>
<p>public boolean setReadOnly() {</p>
<p>SecurityManager guard = System.getSecurityManager();</p>
<p>if (guard!= null) {</p>
<p>guard.canWrite(path);</p>
<p>}</p>
<p>return fileSystem.setReadOnly(this);</p>
<p>}</p>
<empty-line></empty-line><p>В классе java.io.File можно обнаружить 18 проверок guard!= null. Я преклоняюсь перед усердием, с которым разработчики библиотек Java стараются сделать файлы безопасными для всего остального мира, однако я также начинаю немножко нервничать. Будут ли программисты Oracle и в будущем столь же аккуратны, чтобы не забыть проверить результат выполнения метода getSecurityManager() на равенство значению null?</p>
<p>В рамках альтернативного решения можно создать новый класс LaxSecurity, который вообще не генерирует исключений:</p>
<empty-line></empty-line><p><strong>LaxSecurity</strong></p>
<p>public void canWrite(String path) {</p>
<p>}</p>
<empty-line></empty-line><p>Если кто-то пытается получить SecurityManager, однако предоставить такой объект нет возможности, вместо него мы возвращаем LaxSecurity:</p>
<empty-line></empty-line><p><strong>SecurityManager</strong></p>
<p>public static SecurityManager getSecurityManager() {</p>
<p>return security == null? new LaxSecurity(): security;</p>
<p>}</p>
<p>Теперь мы можем не беспокоиться о том, что кто-то забудет проверить результат выполнения метода на равенство значению null. Изначальный код становится существенно более чистым:</p>
<empty-line></empty-line><p><strong>File</strong></p>
<p>public boolean setReadOnly() {</p>
<p>SecurityManager security = System.getSecurityManager();</p>
<p>security.canWrite(path);</p>
<p>return fileSystem.setReadOnly(this);</p>
<p>}</p>
<p>Однажды во время выступления на конференции OOPSLA нас с Эр</p>
<p>ихом Гаммой (Erich Gamma) спросили, можно ли использовать «Нуль-объект» (Null Object) в рамках одного из классов JHotDraw. Я принялся рассуждать о преимуществах такой модернизации, в то время как Эрих посчитал, что для этого нам придется увеличить код на десять строк, при этом мы избавимся от одного условного оператора – преимущество сомнительно. (К тому же аудитория была весьма недовольна нашей несогласованностью.)</p>
<subtitle><emphasis><strong>Шаблонный метод (Template Method)</strong></emphasis></subtitle><p>Как можно запрограммировать инвариантную последовательность операций, обеспечив при этом возможность модификации или замены отдельных действий в будущем? Напишите реализацию метода исключительно в терминах других методов.</p>
<p>В программировании существует огромное количество классических последовательностей:</p>
<p>• ввод – обработка – вывод;</p>
<p>• отправить сообщение – принять ответ;</p>
<p>• прочитать команду – вернуть результат.</p>
<p>Нам хотелось бы четко и понятно обозначить универсальность этих последовательностей и при этом обеспечить возможность варьирования реализаций каждого из отдельных этапов.</p>
<p>Поддерживаемый любым объектно-ориентированным языком механизм наследования обеспечивает простой способ определения универсальных последовательностей. В суперклассе создается метод, целиком и полностью написанный в терминах других методов. Каждый из подклассов может реализовать эти методы так, как ему удобнее. Например, базовая последовательность выполнения теста определяется в инфраструктуре JUnit следующим образом:</p>
<empty-line></empty-line><p><strong>TestCase</strong></p>
<p>public void runBare() throws Throwable {</p>
<p>setUp();</p>
<p>try {</p>
<p>runTest();</p>
<p>}</p>
<p>finally {</p>
<p>tearDown();</p>
<p>}</p>
<p>}</p>
<empty-line></empty-line><p>Классы, производные от TestCase, могут реализовать setUp(), runTest() и tearDown() так, как им этого хочется.</p>
<p>При использовании шаблона «Шаблонный метод» (Template Method) возникает вопрос: надо ли создавать для подметодов реализации по умолчанию? В TestCase.runBare() все три подметода обладают реализациями по умолчанию:</p>
<p>• методы setUp() и tearDown() не выполняют никаких операций;</p>
<p>• метод runTest() динамически обнаруживает и запускает все тестовые методы, исходя из имени класса-теста.</p>
<p>Если общая последовательность не имеет смысла, когда не определен один из ее этапов, вы должны отметить это, воспользовавшись любой подходящей возможностью используемого вами языка программирования:</p>
<p>• в Java можно объявить подметод абстрактным;</p>
<p>• в Smalltalk создайте реализацию метода, которая генерирует ошибку SubclassResponsibility.</p>
<p>Я не рекомендую изначально проектировать код так, чтобы в нем использовался шаблонный метод. Лучше всего формировать шаблонные методы исходя из накопленного опыта. Каждый раз, когда я говорю себе: «Ага, вот последовательность, а вот – детали реализации», – позднее я всегда обнаруживаю, что мне приходится переделывать созданный мною шаблонный метод, заново перетасовывая код между общим и частным.</p>
<p>Если вы обнаружили два варианта последовательности в двух подклассах, вы должны попытаться постепенно приблизить их друг к другу. После того как вы отделите различающиеся части и выделите общую часть, то, что останется, и есть шаблонный метод. После этого вы можете переместить шаблонный метод в суперкласс и избавиться от дублирования.</p>
<subtitle><emphasis><strong>Встраиваемый объект (Pluggable Object)</strong></emphasis></subtitle><p>Как можно выразить несколько разных вариантов поведения кода? Проще всего использовать явный условный оператор:</p>
<empty-line></empty-line><p>if(circle) then {</p>
<p>… код, относящийся к circle.</p>
<p>} else {</p>
<p>… код, не относящийся к circle</p>
<p>}</p>
<empty-line></empty-line><p>Однако подобный корявый код имеет тенденцию распространяться по всей программе. Если для определения разницы между окружностями и не окружностями вы будете использовать условный оператор хотя бы в одном месте вашего кода, с большой долей уверенности можно сказать, что позднее подобный оператор придется добавить также в другом месте, затем в третьем и т. д.</p>
<p>Вторая по важности задача TDD – устранение дублирования, поэтому вы должны подавить угрозу распространения явных условных операторов в зародыше. Если вы видите, что одно и то же условие проверяется в двух разных местах вашего кода, значит, настало время выполнить базовое объектно-ориентированное преобразование: «Встраиваемый объект» (PluggableObject).</p>
<p>Иногда обнаружить необходимость применения этого шаблона не так просто. Один из самых любимых мною примеров использования встраиваемого объекта был придуман мною и Эрихом Гаммой. Представьте, что мы занимаемся разработкой графического редактора. Если вы когда-нибудь занимались чем-либо подобным, должно быть, вы знаете, что операция выделения объектов обладает несколько усложненной логикой. Если указатель мыши находится над графической фигурой и пользователь нажимает кнопку мыши, значит, последующие перемещения мыши приводят к перемещению фигуры, а при отпускании кнопки мыши выбранная фигура остается на новом месте. Если указатель мыши не находится над какой-либо фигурой, значит, нажав кнопку, пользователь выделяет несколько фигур, последующие перемещения мыши приводят к изменению размера прямоугольника выделения, а при отпускании кнопки мыши фигуры внутри прямоугольника выделения становятся выделенными. Изначальный код выглядит примерно так:</p>
<empty-line></empty-line><p><strong>SelectionTool</strong></p>
<p>Figure selected;</p>
<p>public void mouseDown() {</p>
<p>selected = findFigure();</p>
<p>if (selected!= null)</p>
<p>select(selected);</p>
<p>}</p>
<p>public void mouseMove() {</p>
<p>if (selected!= null)</p>
<p>move(selected);</p>
<p>else</p>
<p>moveSelectionRectangle();</p>
<p>}</p>
<p>public void mouseUp() {</p>
<p>if (selected == null)</p>
<p>selectAll();</p>
<p>}</p>
<empty-line></empty-line><p>В глаза бросаются три похожих условных оператора (я же говорил, что они плодятся, как мухи). Что делать, чтобы избавиться от них? Создаем встраиваемый объект, SelectionMode, обладающий двумя реализациями: SingleSelection и MultipleSelection.</p>
<empty-line></empty-line><p><strong>SelectionTool</strong></p>
<p>SelectionMode mode;</p>
<p>public void mouseDown() {</p>
<p>selected = findFigure();</p>
<p>if (selected!= null)</p>
<p>mode = SingleSelection(selected);</p>
<p>else</p>
<p>mode = MultipleSelection();</p>
<p>}</p>
<p>public void mouseMove() {</p>
<p>mode.mouseMove();</p>
<p>}</p>
<p>public void mouseUp() {</p>
<p>mode.mouseUp();</p>
<p>}</p>
<empty-line></empty-line><p>В языках с явными интерфейсами вы обязаны реализовать интерфейс с двумя (или больше) встраиваемыми объектами.</p>
<subtitle><emphasis><strong>Встраиваемый переключатель (Pluggable Selector)<a type="note" l:href="#n_26">[26]</a></strong></emphasis></subtitle><p>Как обеспечить различающееся поведение разных экземпляров одного и того же класса? Сохраните имя метода в переменной и динамически обращайтесь к этому методу.</p>
<p>Что делать, если у вас есть десять подклассов одного базового класса и в каждом из них реализован только один метод? Может оказаться, что создание подклассов – это слишком тяжеловесный механизм для реализации столь небольших различий в поведении объектов.</p>
<empty-line></empty-line><p>abstract class Report {</p>
<p>abstract void print();</p>
<p>}</p>
<p>class HTMLReport extends Report {</p>
<p>void print() {…</p>
<p>}</p>
<p>}</p>
<p>class XMLReport extends Report {</p>
<p>void print() {…</p>
<p>}</p>
<p>}</p>
<empty-line></empty-line><p>Альтернативное решение: создать единственный класс с оператором switch. В зависимости от значения поля происходит обращение к разным методам. Однако в этом случае имя метода упоминается в трех местах:</p>
<p>• при создании экземпляра;</p>
<p>• в операторе switch;</p>
<p>• в самом методе.</p>
<empty-line></empty-line><p>abstract class Report {</p>
<p>String printMessage;</p>
<empty-line></empty-line><p>Report(String printMessage) {</p>
<p>this.printMessage = printMessage;</p>
<p>}</p>
<p>void print() {</p>
<p>switch (printMessage) {</p>
<p>case "printHTML":</p>
<p>printHTML();</p>
<p>break;</p>
<p>case "printXML":</p>
<p>printXML():</p>
<p>break;</p>
<p>}</p>
<p>};</p>
<empty-line></empty-line><p>void printHTML() {</p>
<p>}</p>
<empty-line></empty-line><p>void printXML() {</p>
<p>}</p>
<p>}</p>
<empty-line></empty-line><p>Каждый раз, когда вы добавляете новую разновидность печати, вы должны позаботиться о добавлении нового метода печати и редактировании оператора switch.</p>
<p>Шаблон «Встраиваемый переключатель» (Pluggable Selector) предлагает динамически обращаться к методу с использованием механизма рефлексии:</p>
<empty-line></empty-line><p>void print() {</p>
<p>Method runMethod = getClass(). getMethod(printMessage, null);</p>
<p>runMethod.invoke(this, new Class[0]);</p>
<p>}</p>
<empty-line></empty-line><p>По-прежнему существует весьма неприятная зависимость между создателями отчетов и именами методов печати, однако, по крайней мере, мы избавились от оператора switch.</p>
<p>Естественно, этим шаблоном не следует злоупотреблять. Самая большая связанная с ним проблема состоит в отслеживании вызываемого кода. Используйте встраиваемый переключатель только в случае, когда вы оказались в стандартной ситуации: каждый из подклассов обладает всего одним методом, и у вас есть желание сделать этот код более чистым.</p>
<subtitle><emphasis><strong>Фабричный метод (Factory Method)</strong></emphasis></subtitle><p>Как лучше всего создавать объекты в случае, если вы хотите обеспечить гибкость при создании объектов? Вместо того чтобы использовать конструктор, создайте объект внутри специального метода.</p>
<p>Безусловно, конструкторы являются выразительным инструментом. Если вы используете конструктор, всем, кто читает код, однозначно становится ясно, что вы создаете объект. Однако конструкторы, в особенности в Java, не обеспечивают достаточной гибкости.</p>
<p>В рассмотренном ранее «денежном» примере при создании объекта мы хотели бы возвращать объект иного класса. У нас есть следующий тест:</p>
<empty-line></empty-line><p>public void testMultiplication() {</p>
<p>Dollar five = new Dollar(5);</p>
<p>assertEquals(new Dollar(10), five.times(2));</p>
<p>assertEquals(new Dollar(15), five.times(3));</p>
<p>}</p>
<empty-line></empty-line><p>Мы хотели бы добавить в программу новый класс Money, однако мы не можем этого сделать, так как для тестирования нам нужен экземпляр класса Dollar. Чтобы решить проблему, достаточно добавить в программу дополнительный уровень перенаправления – метод, который будет возвращать объект иного класса. В этом случае мы сможем оставить выражения assert без изменений:</p>
<empty-line></empty-line><p>public void testMultiplication() {</p>
<p>Dollar five = <strong>Money.dollar(5)</strong>;</p>
<p>assertEquals(new Dollar(10), five.times(2));</p>
<p>assertEquals(new Dollar(15), five.times(3));</p>
<p>}</p>
<empty-line></empty-line><p><strong>Money</strong></p>
<p>static Dollar dollar(int amount) {</p>
<p>return new Dollar(amount);</p>
<p>}</p>
<empty-line></empty-line><p>Такой метод называется <emphasis>фабричным методом</emphasis> (Factory Method), так как он предназначен для создания объектов.</p>
<p>Недостаток этого шаблона заключается в том, что предназначение фабричного метода не очевидно: вы должны помнить о том, что этот метод создает объекты, вместе с тем это обычный метод, а не конструктор. Фабричный метод следует использовать только тогда, когда вы действительно нуждаетесь в гибкости, которую он обеспечивает. В противном случае для создания объектов вполне можно использовать обычные конструкторы.</p>
<subtitle><emphasis><strong>Самозванец (Imposter)</strong></emphasis></subtitle><p>Как можно добавить в программу новую вариацию некоторой функциональности? Создайте новый объект с точно таким же протоколом, как и существующий объект, но с отличающейся реализацией.</p>
<p>При использовании процедурно-ориентированного подхода для решения подобной задачи в программу требуется добавить как минимум один условный оператор. Как было продемонстрировано ранее, при обсуждении шаблона «Встраиваемый переключатель» (Pluggable Selector), такие условные операторы имеют тенденцию плодиться подобно саранче. Чтобы избавиться от дублирования, требуется полиморфизм.</p>
<p>Представьте, что у вас уже есть необходимая инфраструктура. У вас уже есть объект, который реализует необходимую функциональность. Теперь вы хотите, чтобы ваша система делала нечто отличающееся. Если вы обнаружили очевидное место для добавления оператора if и при этом не возникает дублирования какой-либо существующей логики, действуйте смело и решительно. Однако зачастую для добавления вариации требуется внести изменения в код нескольких методов.</p>
<p>Если вы работаете в стиле TDD, решение об использовании самозванца может возникнуть исходя из разных предпосылок. Иногда вы пишете тест и у вас возникает желание реализовать новый сценарий. Однако ни один из существующих объектов не выражает того, что вы хотите выразить. Представьте, что мы тестируем графический редактор и нам уже удалось реализовать корректное рисование прямоугольников:</p>
<empty-line></empty-line><p>testRectangle() {</p>
<p>Drawing d = new Drawing();</p>
<p>d. addFigure(new RectangleFigure(0, 10, 50, 100));</p>
<p>RecordingMedium brush = new RecordingMedium();</p>
<p>d. display(brush);</p>
<p>assertEquals("rectangle 0 10 50 100\n", brush.log());</p>
<p>}</p>
<empty-line></empty-line><p>Теперь мы хотим реализовать рисование овалов. В данном случае необходимость применения шаблона «Самозванец» (Imposter) очевидна: заменяем RectangleFigure на OvalFigure.</p>
<empty-line></empty-line><p>testOval() {</p>
<p>Drawing d = new Drawing();</p>
<p>d. addFigure(new <strong>OvalFigure</strong>(0, 10, 50, 100));</p>
<p>RecordingMedium brush = new RecordingMedium();</p>
<p>d. display(brush);</p>
<p>assertEquals("<strong>oval</strong> 0 10 50 100\n", brush.log());</p>
<p>}</p>
<empty-line></empty-line><p>Как правило, чтобы увидеть необходимость использования этого шаблона еще до начала разработки кода, требуется озарение. Именно озарением можно назвать момент, когда Уорд Каннингэм решил, что вектор объектов Money может вести себя так же, как одиночный объект Money. Сначала можно подумать, что они различаются, однако после вы понимаете, что они одинаковы.</p>
<p>Вот два примера использования «Самозванец» (Imposter) в процессе рефакторинга:</p>
<p>• «Нуль-объект» (Null Object) – вы можете рассматривать отсутствие данных в точности так же, как и присутствие данных;</p>
<p>• «Компоновщик» (Composite) – вы можете рассматривать коллекцию объектов как одиночный объект.</p>
<p>Решение об использовании «Самозванец» (Imposter) в процессе рефакторинга принимается для устранения дублирования, впрочем, целью любого рефакторинга является устранение дублирования.</p>
<subtitle><emphasis><strong>Компоновщик (Composite)</strong></emphasis></subtitle><p>Как лучше всего реализовать объект, чье поведение является композицией функций некоторого набора других объектов? Примените шаблон «Самозванец» (Imposter) – заставьте этот объект вести себя подобно тому, как ведут себя отдельные объекты, входящие в набор.</p>
<p>Мой любимый пример основан на двух объектах: Account (счет) и Transaction (транзакция). Этот пример помимо прочего демонстрирует некоторую противоречивость шаблона «Компоновщик» (Composite), но об этом позже. В объекте Transaction хранится изменение величины счета (безусловно, транзакция – это более сложный и интересный объект, однако на данный момент мы ограничимся лишь мизерной долей его возможностей):</p>
<empty-line></empty-line><p><strong>Transaction</strong></p>
<p>Transaction(Money value) {</p>
<p>this.value = value;</p>
<p>}</p>
<empty-line></empty-line><p>Объект Accout вычисляет баланс счета путем суммирования значений относящихся к нему объектов Transaction:</p>
<empty-line></empty-line><p><strong>Account</strong></p>
<p>Transaction transactions[];</p>
<p>Money balance() {</p>
<p>Money sum = Money.zero();</p>
<p>for (int i = 0; i &lt; transactions.length; i++)</p>
<p>sum = sum.plus(transactions[i].value);</p>
<p>return sum;</p>
<p>}</p>
<empty-line></empty-line><p>Все выглядит достаточно просто:</p>
<p>• в объектах Transaction хранятся значения;</p>
<p>• в объекте Account хранится баланс.</p>
<p>Теперь самое интересное. У клиента есть несколько счетов, и он хочет узнать общий баланс по всем этим счетам. Первая мысль, которая приходит в голову: создать новый класс OverallAccount, который суммирует балансы для некоторого набора объектов Account. Дублирование! Дублирование!</p>
<p>А что, если классы Account и Transaction будут поддерживать один и тот же интерфейс? Давайте назовем его Holding (сбережения), потому что сейчас мне не удается придумать что-либо лучшее:</p>
<empty-line></empty-line><p><strong>Holding</strong></p>
<p>interface Holding</p>
<p>Money balance();</p>
<empty-line></empty-line><p>Чтобы реализовать метод balance() в классе Transaction, достаточно вернуть хранящееся в этом классе значение:</p>
<empty-line></empty-line><p><strong>Transaction</strong></p>
<p>Money balance() {</p>
<p>return value;</p>
<p>}</p>
<empty-line></empty-line><p>Теперь в классе Account можно хранить не транзации, а объекты Holding:</p>
<empty-line></empty-line><p><strong>Account</strong></p>
<p>Holding holdings[];</p>
<p>Money balance() {</p>
<p>Money sum = Money.zero();</p>
<p>for (int i = 0; i &lt; holdings.length; i++)</p>
<p>sum = sum.plus(holdings[i].balance());</p>
<p>return sum;</p>
<p>}</p>
<empty-line></empty-line><p>Проблема, связанная с созданием класса OverallAccount, испарилась в воздухе. Объект OverallAccount – это просто еще один объект Account, в котором хранятся не транзакции, а другие объекты Account.</p>
<p>Теперь о противоречивости. В приведенном примере хорошо чувствуется запах шаблона «Компоновщик» (Composite). В реальном мире транзакция не может содержать в себе баланс. В данном случае программист идет на уловку, которая совершенно не логична с точки зрения всего остального мира. Вместе с тем преимущества подобного дизайна неоспоримы, и ради этих преимуществ можно пожертвовать некоторым концептуальным несоответствием. Если присмотреться, подобные несоответствия встречаются нам на каждом шагу: папки (Folders), в которых содержатся другие папки (Folders), наборы тестов (TestSuites), в которых содержатся другие наборы тестов (TestSuites), рисунки (Drawings), в которых содержатся другие рисунки (Drawings). Любая из этих метафор недостаточно хорошо соответствует взаимосвязи между вещами в реальном мире, однако все они существенно упрощают код.</p>
<p>Я вынужден был длительное время экспериментировать с шаблоном «Компоновщик» (Composite), прежде чем научился понимать, когда его следует использовать, а когда – нет. Наверное, вы уже поняли, что я не могу предоставить вам однозначных рекомендаций относительно решения проблемы, в каких ситуациях коллекция объектов является просто коллекцией объектов, а в каких это – объект-компоновщик. Хорошая новость состоит в том, что, когда вы достаточно хорошо освоите рефакторинг, вы наверняка сможете обнаружить возникновение дублирования, воспользоваться шаблоном «Компоновщик» (Composite) и обнаружить, что код существенно упростился.</p>
<subtitle><emphasis><strong>Накапливающий параметр (Collecting Parameter)</strong></emphasis></subtitle><p>Как можно сформировать результат операции, если она распределена между несколькими объектами? Используйте параметр, в котором будут накапливаться результаты операции.</p>
<p>Простым примером является интерфейс java.io.Externalizable. Метод writeExternal этого интерфейса осуществляет запись объекта и всех объектов, на которые ссылается данный объект. Чтобы обеспечить общую запись, все записываемые объекты должны взаимодействовать друг с другом, поэтому методу передается параметр – объект класса ObjectOutput, – в котором осуществляется накопление:</p>
<empty-line></empty-line><p><strong>java.io.Externalizable</strong></p>
<p>public interface Externalizable extends java.io.Serializable {</p>
<p>void writeExternal(ObjectOutput out) throws IOException;</p>
<p>}</p>
<empty-line></empty-line><p>Добавление параметра-накопителя зачастую является последствием использования шаблона «Компоновщик» (Composite). В начале разработки JUnit не было необходимости накапливать результаты выполнения нескольких тестов в объекте TestResult до тех пор, пока в инфраструктуру не была добавлена возможность создания и запуска нескольких тестов.</p>
<p>Необходимость использования параметра-накопителя возникает в ситуации, когда возрастает сложность объекта, получаемого в результате комплексной операции. Например, представьте, что нам необходимо реализовать вывод объекта Expression на экран в виде строки символов. Если обычная, не структурированная строка – это все, что нам нужно, значит, конкатенации будет вполне достаточно:</p>
<empty-line></empty-line><p>testSumPrinting() {</p>
<p>Sum sum = new Sum(Money.dollar(5), Money.franc(7));</p>
<p>assertEquals("5 USD + 7 CHF", sum.toString());</p>
<p>}</p>
<p>String toString() {</p>
<p>return augend + " + " + addend;</p>
<p>}</p>
<empty-line></empty-line><p>Однако если мы хотим отобразить объект Expression в виде древовидной структуры, код может выглядеть следующим образом:</p>
<empty-line></empty-line><p>testSumPrinting() {</p>
<p>Sum sum = new Sum(Money.dollar(5), Money.franc(7));</p>
<p>assertEquals("+\n\t5 USD\n\t7 CHF", sum.toString());</p>
<p>}</p>
<empty-line></empty-line><p>В этом случае придется воспользоваться параметром-накопителем:</p>
<empty-line></empty-line><p>String toString() {</p>
<p>IndentingStream writer = new IndentingStream();</p>
<p>toString(writer);</p>
<p>return writer.contents();</p>
<p>}</p>
<empty-line></empty-line><p>void toString(IndentingWriter writer) {</p>
<p>writer.println("+");</p>
<p>writer.indent();</p>
<p>augend.toString(writer);</p>
<p>writer.println();</p>
<p>addend.toString(writer);</p>
<p>writer.exdent();</p>
<p>}</p>
<subtitle><emphasis><strong>Одиночка (Singleton)</strong></emphasis></subtitle><p>Как можно реализовать глобальную переменную в языке, в котором не поддерживаются глобальные переменные? Не следует этим заниматься. Ваша программа скажет вам большое спасибо, если вместо этого вы еще раз хорошенько обдумаете дизайн и откажетесь от мысли использовать глобальные переменные.</p>
</section><section><title><p>31. Рефакторинг</p>
</title><p>Рассматриваемые здесь шаблоны помогут изменить дизайн системы маленькими шажками.</p>
<p>В рамках TDD рефакторинг<a type="note" l:href="#n_27">[27]</a> используется интересным образом. Обычно рефакторинг не может изменить семантику программы ни при каких условиях. В рамках TDD условия семантики формулируются при помощи тестов, которые уже выполняются успешно. Таким образом, в рамках TDD мы можем, например, заменить константы переменными и с чистой совестью назвать эту процедуру рефакторингом, потому что набор успешных тестов при этом не изменился. Однако набор успешных тестов может состоять всего из одного теста. Возможно, семантика программы должна описываться большим количеством тестов. Возможно также, что некоторые из этих потенциальных тестов в результате выполнения рефакторинга перестали бы срабатывать, если бы они существовали. Однако их нет, поэтому мы о них не беспокоимся.</p>
<p>Отсюда следует, что на программиста, работающего в стиле TDD, возлагается важная обязанность: он должен иметь достаточное количество тестов, описывающих семантику программы. Достаточное настолько, насколько он может судить на момент завершения работы над кодом. Необходимо понимать, что рефакторинг выполняется не с учетом всех существующих тестов, а с учетом всех возможных тестов. Фраза: «Я знаю, что там была проблема, но все тесты выполнились успешно, поэтому я посчитал код завершенным и интегрировал его в систему», – не может считаться оправданием. Пишите больше тестов.</p>
<subtitle><emphasis><strong>Согласование различий (Reconcile Differences)</strong></emphasis></subtitle><p>Как можно унифицировать два схожих фрагмента кода? Постепенно делайте их все более похожими друг на друга. Унифицируйте их только в случае, если они абсолютно идентичны.</p>
<p>Подчас рефакторинг – это весьма нервная работа. Простые изменения в коде очевидны. Если я извлекаю метод и делаю это механически корректно, вероятность того, что поведение системы изменится, чрезвычайно мала. Однако некоторые из изменений заставляют внимательно анализировать последовательность выполнения операций и порядок модификации данных. Построив длинную цепочку умозаключений, вы приходите к выводу, что запланированное вами изменение кода, скорее всего, не приведет к изменению поведения системы. Однако любой подобный рефакторинг уменьшает количество волос на вашей голове.</p>
<p>Сложные изменения – это именно то, чего мы пытаемся избежать, когда придерживаемся стратегии маленьких шажков и конкретной обратной связи. Полностью избежать сложных изменений невозможно, однако можно уменьшить их влияние на остальной код.</p>
<p>Подобные изменения возникают на разных уровнях:</p>
<p>• Два цикла выглядят похоже. Если вы сделаете их идентичными, вы сможете объединить их в единый цикл.</p>
<p>• Две ветви условного оператора выглядят похоже. Сделав их идентичными, вы сможете избавиться от условного оператора.</p>
<p>• Два метода выглядят похоже. Сделав их идентичными, вы сможете избавиться от одного из них.</p>
<p>• Два класса выглядят похоже. Сделав их идентичными, вы сможете избавиться от одного из них.</p>
<p>Иногда задачу согласования различий удобнее решать в обратном порядке. Иными словами, вы представляете себе самый тривиальный последний этап этой процедуры, а затем двигаетесь в обратном направлении. Например, если вы хотите избавиться от нескольких подклассов, наиболее тривиальный последний шаг можно будет выполнить в случае, если подкласс ничего не содержит. Тогда везде, где используется подкласс, можно будет использовать суперкласс, при этом поведение системы не изменится. Что надо сделать, чтобы очистить подкласс от методов и данных? Для начала метод можно сделать полностью идентичным одному из методов суперкласса. Постепенно переместив все методы и все данные в суперкласс, вы сможете заменить ссылки на подкласс ссылками на суперкласс. После этого подкласс можно уничтожить.</p>
<subtitle><emphasis><strong>Изоляция изменений (Isolate Change)</strong></emphasis></subtitle><p>Как можно модифицировать одну часть метода или объекта, состоящего из нескольких частей? Сначала изолируйте изменяемую часть.</p>
<p>Мне приходит в голову аналогия с хирургической операцией: фактически все тело оперируемого пациента покрыто специальной простыней за исключением места, на котором, собственно, осуществляется операция. Благодаря такому покрытию хирург имеет дело с фиксированным набором переменных. Перед выполнением операции врачи сколь угодно долго могут обсуждать, какое влияние на здоровье пациента оказывает тот или иной орган, однако во время операции внимание хирурга должно быть сфокусировано.</p>
<p>Вы можете обнаружить, что после того, как вы изолировали изменение, а затем внесли это изменение в код, результат получился настолько тривиальным, что вы можете отменить изоляцию. Например, если мы обнаружили, что внутри метода findRate() должно присутствовать всего одно действие – возврат значения поля, мы можем вместо обращений к методу findRate() напрямую обратиться к полю. В результате метод findRate() можно будет удалить. Однако подобные изменения не следует выполнять автоматически. Постарайтесь найти баланс между затратами, связанными с использованием дополнительного метода, и пользой, которую приносит дополнительная концепция, добавленная в код.</p>
<p>Для изоляции изменений можно использовать несколько разных способов. Наиболее часто используется шаблон «Выделение метода» (Extract Method), помимо него также используются «Выделение объекта» (Extract Object) и «Метод в объект» (Method Object).</p>
<subtitle><emphasis><strong>Миграция данных (Migrate Data)</strong></emphasis></subtitle><p>Как можно перейти от одного представления к другому? Временно дублируйте данные.</p>
<empty-line></empty-line><p><strong>Как</strong></p>
<p>Вначале рассмотрим версию «от внутреннего к внешнему». В рамках этого подхода вы изменяете вначале внутреннее представление, а затем внешний интерфейс.</p>
<p>1. Создайте переменную экземпляра в новом формате.</p>
<p>2. Инициализируйте переменную нового формата везде, где инициализируется переменная старого формата.</p>
<p>3. Используйте переменную нового формата везде, где используется переменная старого формата.</p>
<p>4. Удалите старый формат.</p>
<p>5. Измените внешний интерфейс так, чтобы использовать новый формат.</p>
<p>Однако в некоторых ситуациях удобнее сначала изменить API. В этом случае рефакторинг выполняется следующим образом.</p>
<p>1. Добавьте параметр в новом формате.</p>
<p>2. Обеспечьте преобразование параметра в новом формате во внутреннее представление, обладающее старым форматом.</p>
<p>3. Удалите параметр в старом формате.</p>
<p>4. Замените использование старого формата на использование нового формата.</p>
<p>5. Удалите старый формат.</p>
<empty-line></empty-line><p><strong>Зачем</strong></p>
<p>Проблема миграции данных возникает каждый раз, когда используется шаблон «От одного ко многим» (One to Many). Предположим, что мы хотим реализовать объект TestSuite, используя шаблон «От одного ко многим» (One to Many). Мы можем начать так:</p>
<empty-line></empty-line><p>def testSuite(self):</p>
<p>suite = TestSuite()</p>
<p>suite.add(WasRun("testMethod"))</p>
<p>suite.run(self.result)</p>
<p>assert("1 run, 0 failed" == self.result.summary())</p>
<empty-line></empty-line><p>Чтобы реализовать этот тест, начнем с одного элемента test:</p>
<empty-line></empty-line><p>class TestSuite:</p>
<p>def add(self, test):</p>
<p>self.test = test</p>
<p>def run(self, result):</p>
<p>self.test.run(result)</p>
<empty-line></empty-line><p>Теперь мы приступаем к дублированию данных. Вначале инициализируем коллекцию тестов:</p>
<empty-line></empty-line><p><strong>TestSuite</strong></p>
<p>def __init__(self):</p>
<p>self.tests = []</p>
<empty-line></empty-line><p>В каждом месте, где инициализируется поле test, добавляем новый тест в коллекцию:</p>
<empty-line></empty-line><p><strong>TestSuite</strong></p>
<p>def add(self, test):</p>
<p>self.test = test</p>
<p>self.tests.append(test)</p>
<empty-line></empty-line><p>Теперь мы используем коллекцию тестов вместо единичного теста. Исходя из существующего набора тестов данное преобразование можно считать рефакторингом (оно не нарушает семантику), так как в составе коллекции присутствует только один элемент.</p>
<empty-line></empty-line><p><strong>TestSuite</strong></p>
<p>def run(self, result):</p>
<p>for test in self.tests:</p>
<p>test.run(result)</p>
<empty-line></empty-line><p>Теперь можно удалить не используемую переменную экземпляра test:</p>
<empty-line></empty-line><p><strong>TestSuite</strong></p>
<p>def add(self, test):</p>
<p>self.tests.append(test)</p>
<empty-line></empty-line><p>Поэтапную миграцию данных можно использовать также при переходе между эквивалентными форматами, использующими различные протоколы, например, если речь идет о Java, при переходе от Vector/Enumerator к Collection/Iterator.</p>
<subtitle><emphasis><strong>Выделение метода (Extract Method)</strong></emphasis></subtitle><p>Как длинный сложный метод можно сделать простым для чтения? Выделите небольшую часть длинного метода в отдельный метод и обратитесь к этому методу из длинного метода.</p>
<empty-line></empty-line><p><strong>Как</strong></p>
<p>Выделение метода на самом деле является несколько более сложным атомарным рефакторингом. Здесь я опишу самый типичный случай. К счастью, многие среды разработки поддерживают автоматическое выполнение этого рефакторинга. Итак, чтобы выделить метод:</p>
<p>1. Определите фрагмент кода, который можно выделить в отдельный метод. Хорошими кандидатами являются тела циклов, сами циклы, а также ветви условных операторов.</p>
<p>2. Убедитесь, что внутри этого фрагмента не происходит присваивания значений временным переменным, объявленным вне области видимости, соответствующей этому фрагменту.</p>
<p>3. Скопируйте код из старого метода в новый. Скомпилируйте его.</p>
<p>4. Для каждой временной переменной или параметра первоначального метода, используемого в новом методе, добавьте параметр в новый метод.</p>
<p>5. Сделайте так, чтобы в нужном месте старый метод обращался к новому методу.</p>
<empty-line></empty-line><p><strong>Зачем</strong></p>
<p>Я использую «Выделение метода» (Extract Method), когда пытаюсь понять сложный код. «Значит так, этот кусок кода делает вот это. А этот кусок делает это. К чему мы там дальше обращаемся?» Через полчаса код будет выглядеть гораздо лучше, ваш партнер начнет понимать, что вы действительно оказываете ему помощь, а вы – существенно лучше понимать, что же все-таки происходит внутри кода.</p>
<p>Я использую выделение метода, чтобы избавиться от дублирования, когда вижу, что два метода обладают сходными участками кода. В этом случае я выделяю схожие участки в отдельный метод. (Браузер рефакторинга для Smalltalk – Refactoring Browser – выполняет еще более полезную задачу: он просматривает код в поисках метода, аналогичного коду, который вы намерены выделить, и в случае, если такой метод уже есть, предлагает использовать уже существующий метод вместо того, чтобы создавать новый.)</p>
<p>Разделение методов на множество мелких кусочков может зайти слишком далеко. Если я не вижу, куда идти дальше, я часто использую шаблон «Встраивание метода» (Inline Method), чтобы собрать код в одном месте и увидеть новый, более удобный способ разделения.</p>
<subtitle><emphasis><strong>Встраивание метода (Inline Method)</strong></emphasis></subtitle><p>Как можно упростить код, если становится сложно уследить за последовательностью передачи управления от метода к методу? Замените обращение к методу кодом этого метода.</p>
<empty-line></empty-line><p><strong>Как</strong></p>
<p>1. Скопируйте код метода в буфер обмена.</p>
<p>2. Вставьте код метода вместо обращения к методу.</p>
<p>3. Замените все формальные параметры фактическими. Если, например, вы передаете reader.getNext(), то есть выражение, обладающее побочным эффектом, будьте осторожны и присвойте полученное значение временной переменной.</p>
<empty-line></empty-line><p><strong>Зачем</strong></p>
<p>Один из моих рецензентов пожаловался на сложность кода в первой части книги, который требует от объекта Bank преобразовать объект Expression в объект Money.</p>
<empty-line></empty-line><p>public void testSimpleAddition() {</p>
<p>Money five = Money.dollar(5);</p>
<p>Expression sum = five.plus(five);</p>
<p>Bank bank = new Bank();</p>
<p>Money reduced = bank.reduce(sum, "USD");</p>
<p>assertEquals(Money.dollar(10), reduced);</p>
<p>}</p>
<empty-line></empty-line><p>«Это слишком сложно. Почему бы не реализовать преобразование в самом объекте Money?» Ну что же, поставим эксперимент. Как это сделать? Давайте встроим метод Bank.reduce() и посмотрим, как это будет выглядеть:</p>
<empty-line></empty-line><p>public void testSimpleAddition() {</p>
<p>Money five = Money.dollar(5);</p>
<p>Expression sum = five.plus(five);</p>
<p>Bank bank = new Bank();</p>
<p>Money reduced = <strong>sum.reduce(bank, «USD»);</strong></p>
<p>assertEquals(Money.dollar(10), reduced);</p>
<p>}</p>
<empty-line></empty-line><p>Возможно, вторая версия понравится вам больше, возможно, нет. Важно понимать, что при помощи шаблона «Встраивание метода» (Inline Method) вы можете экспериментировать с последовательностью выполнения действий. Когда я выполняю рефакторинг, я формирую у себя в голове мысленную картину системы с кусками логики и потоком выполнения программы, перетекающим от одного объекта к другому объекту. Когда мне кажется, что я вижу нечто многообещающее, я использую рефакторинг, чтобы попробовать это и увидеть результат.</p>
<p>В разгаре битвы я могу вдруг обнаружить, что попался в ловушку собственной гениальности. (Не буду говорить, насколько часто это происходит.) Когда это происходит, я использую «Встраивание метода» (Inline Method), чтобы разобраться в той путанице, которую я создал: «Так, этот объект обращается к этому, этот к этому… не могу понять, что же здесь происходит?» Я встраиваю несколько уровней абстракции и смотрю, что же на самом деле происходит. После этого я могу заново выделить абстракцию, использовав более удобный способ.</p>
<subtitle><emphasis><strong>Выделение интерфейса (Extract Interface)</strong></emphasis></subtitle><p>Как создать альтернативные реализации операций в языке Java? Создайте интерфейс, в котором будут содержаться общие операции.</p>
<empty-line></empty-line><p><strong>Как</strong></p>
<p>1. Напишите объявление интерфейса. Иногда в качестве имени интерфейса используется имя существующего класса. В этом случае вы должны предварительно переименовать класс.</p>
<p>2. Сделайте так, чтобы существующий класс реализовывал объявленный вами интерфейс.</p>
<p>3. Добавьте в интерфейс все обязательные методы. В случае необходимости измените режим видимости методов класса.</p>
<p>4. Там, где это возможно, измените объявления с класса на интерфейс.</p>
<empty-line></empty-line><p><strong>Зачем</strong></p>
<p>Иногда необходимость выделения интерфейса возникает в случае, когда вы переходите от одной реализации к другой. Например, у вас есть класс Rectangle (прямоугольник), и вы хотите создать класс Oval (овал) – в этом случае вы создаете интерфейс Shape (фигура). В подобных ситуациях подобрать имя для интерфейса, как правило, несложно. Однако иногда приходится изрядно помучиться, прежде чем обнаружится подходящая метафора.</p>
<p>Иногда, когда нужно выделить интерфейс, вы используете шаблон «Тестирование обработки ошибок» (Crash Test Dummy) или «Поддельный объект» (Mock Object). В этом случае подбор подходящего имени выполняется сложнее, так как в вашем распоряжении лишь один пример использования интерфейса. В подобных случаях у меня возникает соблазн наплевать на информативность и назвать интерфейс IFile, а реализующий его класс – File. Однако я приучил себя останавливаться на мгновение и размышлять о том, достаточно ли хорошо я понимаю то, над чем работаю? Возможно, интерфейс лучше назвать File, а реализующий его класс – DiskFile, так как соответствующая реализация основана на том, что данные, содержащиеся в файле, хранятся на жестком диске.</p>
<subtitle><emphasis><strong>Перемещение метода (Move Method)</strong></emphasis></subtitle><p>Как можно переместить метод в новое место, где он должен находиться? Добавьте его в класс, которому он должен принадлежать, затем обратитесь к нему.</p>
<empty-line></empty-line><p><strong>Как</strong></p>
<p>1. Скопируйте метод в буфер обмена.</p>
<p>2. Вставьте метод в целевой класс. Присвойте ему подобающее имя. Скомпилируйте его.</p>
<p>3. Если внутри метода происходит обращение к первоначальному объекту, добавьте параметр, при помощи которого методу будет передаваться этот объект. Если внутри метода происходит обращение к переменным-членам первоначального объекта, передавайте их в виде параметров. Если внутри метода переменным-членам первоначального объекта присваиваются значения, вы должны отказаться от идеи переноса метода в новый объект.</p>
<p>4. Замените тело первоначального метода обращением к новому методу.</p>
<empty-line></empty-line><p><strong>Зачем</strong></p>
<p>Это один из моих самых любимых шаблонов рефакторинга, выполняемых в процессе консультирования. Дело в том, что он наиболее эффективно демонстрирует неправильные предположения относительно дизайна кода. Вычисление площади – это обязанность объекта Shape (фигура):</p>
<empty-line></empty-line><p><strong>Shape</strong></p>
<p>…</p>
<p>int width = bounds.right() – bounds.left();</p>
<p>int height = bounds.bottom() – bounds.top();</p>
<p>int area = width * height;</p>
<p>…</p>
<empty-line></empty-line><p>Каждый раз, когда я вижу, что внутри метода, принадлежащего одному объекту, происходит обращение к нескольким методам другого объекта, я начинаю смотреть на код с подозрением. В данном случае я вижу, что в методе, принадлежащем объекту Shape, происходит обращение к четырем методам объекта bounds (класс Rectangle). Пришло время переместить эту часть метода в класс Rectangle:</p>
<empty-line></empty-line><p><strong>Rectangle</strong></p>
<p>public int area() {</p>
<p>int width = this.right() – this.left();</p>
<p>int height = this.bottom() – this.top();</p>
<p>return width * height;</p>
<p>}</p>
<empty-line></empty-line><p><strong>Shape</strong></p>
<p>…</p>
<p>int area = bounds.area();</p>
<p>…</p>
<empty-line></empty-line><p>Шаблон рефакторинга «Перемещение метода» (Move Method) обладает тремя важными преимуществами:</p>
<p>• Очень легко увидеть необходимость применения этого вида рефакторинга, при этом не требуется глубокое понимание смысла кода. Как только вы увидите два или больше сообщения, адресованные другому объекту, значит, можно смело приступать.</p>
<p>• Механика выполнения рефакторинга быстра и безопасна.</p>
<p>• Результаты зачастую приводят к просветлению. «Но класс Rectangle не выполняет никаких вычислений… О! Теперь я вижу. Так действительно лучше.»</p>
<p>Иногда возникает желание переместить только часть метода. Вы можете вначале выделить метод, переместить весь метод, а затем встроить метод в первоначальный класс. Или вы можете придумать способ сделать все это за один шаг.</p>
<subtitle><emphasis><strong>Метод в объект (Method Object)</strong></emphasis></subtitle><p>Как лучше всего реализовать сложный метод, использующий несколько параметров и локальных переменных? Преобразуйте метод в отдельный объект.</p>
<empty-line></empty-line><p><strong>Как</strong></p>
<p>1. Создайте класс с таким же количеством параметров, как и оригинальный метод.</p>
<p>2. Сделайте локальные переменные метода переменными экземпляра нового класса.</p>
<p>3. Определите в новом классе метод с именем run(). Тело этого метода будет таким же, как и тело оригинального метода.</p>
<p>4. В оригинальном методе создайте новый объект и обратитесь к методу run() этого объекта.</p>
<empty-line></empty-line><p><strong>Зачем</strong></p>
<p>Объекты-методы полезны в качестве подготовительного этапа перед добавлением в систему абсолютно нового вида внутренней логики. Например, представьте, что для вычисления общего денежного потока используется несколько разных методов, позволяющих учесть в вычислениях несколько разных компонентов общего денежного потока. Вначале можно создать объект-метод, вычисляющий общий денежный поток первым способом. Затем можно описать следующий способ вычислений при помощи тестов меньшего масштаба. После этого добавление в программу нового способа вычислений будет несложным делом.</p>
<p>Объекты-методы также позволяют упростить код, в отношении которого неудобно использовать шаблон «Выделение метода» (Extract Method). В некоторых ситуациях вы вынуждены иметь дело с блоком кода, который работает с обширным набором временных переменных и параметров, и каждый раз, когда вы пытаетесь выделить хотя бы часть этого кода в отдельный метод, вы вынуждены переносить в новый метод пять или шесть временных переменных и параметров. Получившийся выделенный метод выглядит ничем не лучше, чем первоначальный код, так как его сигнатура слишком длинна. В результате создания объекта-метода вы получаете новое пространство имен, в рамках которого можете извлекать методы, без необходимости передачи в них каких-либо параметров.</p>
<subtitle><emphasis><strong>Добавление параметра (Add Parameter)</strong></emphasis></subtitle><p>Как можно добавить в метод новый параметр?</p>
<empty-line></empty-line><p><strong>Как</strong></p>
<p>1. Если метод входит в состав интерфейса, сначала добавьте параметр в интерфейс.</p>
<p>2. Воспользуйтесь сообщениями компилятора, чтобы узнать, в каких местах происходит обращение к данному методу. В каждом из этих мест внесите необходимые изменения в вызывающий код.</p>
<empty-line></empty-line><p><strong>Зачем</strong></p>
<p>Добавление параметра зачастую связано с расширением функциональности. Чтобы обеспечить успешное выполнение первого теста, вы написали код без параметра, однако далее условия изменились, и для корректного выполнения вычислений необходимо принять во внимание дополнительные данные.</p>
<p>Добавление параметра также может быть вызвано необходимостью миграции от одного представления данных к другому. Вначале вы добавляете параметр, затем удаляете из кода все ссылки на старый параметр, затем удаляете сам старый параметр.</p>
<subtitle><emphasis><strong>Параметр метода в параметр конструктора (Method Parameter to Constructor Parameter)</strong></emphasis></subtitle><p>Как переместить параметр из метода или методов в конструктор?</p>
<empty-line></empty-line><p><strong>Как</strong></p>
<p>1. Добавьте параметр в конструктор.</p>
<p>2. Добавьте в класс переменную экземпляра с тем же именем, что и параметр.</p>
<p>3. Установите значение переменной в конструкторе.</p>
<p>4. Одну за другой преобразуйте ссылки parameter в ссылки this.parameter.</p>
<p>5. Когда в коде не останется ни одной ссылки на параметр, удалите параметр из метода.</p>
<p>6. После этого удалите ненужный теперь префикс this.</p>
<p>7. Присвойте переменной подходящее имя.</p>
<empty-line></empty-line><p><strong>Зачем</strong></p>
<p>Если вы передаете один и тот же параметр нескольким разным методам одного и того же объекта, вы можете упростить API, передав параметр только один раз (устранив дублирование). Напротив, если вы обнаружили, что некоторая переменная экземпляра используется только в одном методе объекта, вы можете выполнить обратный рефакторинг.</p>
<p>27 Fowler, Martin. <emphasis>Refactoring: Improving the Design of Existing Code.</emphasis> Boston: Addison-Wesley, 1999. Русское издание: Фаулер. М. <emphasis>Рефакторинг: улучшение существующего кода.</emphasis> СПб.: Символ-Плюс, 2003</p>
</section><section><title><p>32. Развитие навыков TDD</p>
</title><p>В данной главе я намерен сформулировать несколько вопросов, над которыми полезно подумать, если вы намерены интегрировать TDD в свой процесс разработки. Некоторые из вопросов просты, другие требуют тщательного обдумывания. Ответы на некоторые из этих вопросов вы найдете здесь же, однако иногда, чтобы ответить на некоторый вопрос, вам придется провести собственные исследования.</p>
<subtitle><emphasis><strong>Насколько большими должны быть шаги?</strong></emphasis></subtitle><p>В этом вопросе на самом деле скрыто два вопроса:</p>
<p>• Какой объем функциональности должен охватывать каждый тест?</p>
<p>• Как много промежуточных стадий должно быть преодолено в процессе каждого сеанса рефакторинга?</p>
<p>Вы можете писать тесты так, что каждый из них будет требовать добавления в функциональный код единственной строки и выполнения небольшого рефакторинга. Вы также можете писать тесты так, что каждый из них будет требовать добавления в функциональный код сотен строк, при этом у вас будут уходить часы на рефакторинг. Какой из этих путей лучше?</p>
<p>Часть ответа состоит в том, что вы должны уметь работать и так и этак. Общая тенденция TDD очевидна – чем меньше шаги, тем лучше. В данной книге мы занимались разработкой маленьких тестов на уровне отдельных фрагментов программы. Однако некоторые программисты экспериментируют в области разработки программ, исходя из тестов на уровне всего приложения.</p>
<p>Если вы только приступаете к освоению рефакторинга, вы должны двигаться маленькими шажками. Процесс ручного рефакторинга чреват ошибками. Чем больше ошибок вы наделаете, тем меньшим будет ваше желание выполнять рефакторинг в дальнейшем. После того как вы 20 раз проделаете рефакторинг малюсенькими шажками, можете приступать к экспериментам по удлинению этих шажков.</p>
<p>Автоматизация существенно ускоряет процессы, связанные с рефакторингом. То, что раньше требовало выполнения 20 маленьких шагов вручную, теперь становится единственным пунктом в меню. Количество изменений, выполняемых в ходе сеанса рефакторинга увеличивается на порядок, и это неизменно сказывается на качестве. Когда вы знаете, что в вашем распоряжении великолепный инструмент, вы становитесь более агрессивным при выполнении рефакторинга. Вы пытаетесь ставить больше экспериментов и смотреть, какой способ структурирования кода лучше.</p>
<p>На момент написания данной книги браузер рефакторинга Refactoring Browser for Smalltalk по-прежнему является наилучшим инструментом в этой категории. В настоящее время многие среды разработки для Java поддерживают развитые средства рефакторинга. Кроме того, поддержка рефакторинга появилась и в других языках и средах разработки.</p>
<subtitle><emphasis><strong>Что не подлежит тестированию?</strong></emphasis></subtitle><p>Флип предложил высказывание, которое может служить ответом на этот вопрос: «Пишите тесты до тех пор, пока страх не превратится в скуку». Высказывание подразумевает, что вы должны найти ответ сами. Однако вы читаете эту книгу для того, чтобы найти в ней ответы на вопросы, поэтому попробуйте воспользоваться следующим списком. Тестировать следует:</p>
<p>• условные операторы;</p>
<p>• циклы;</p>
<p>• операции;</p>
<p>• полиморфизм.</p>
<p>Однако только те из них, которые вы написали сами. Не тестируйте чужой код, если только у вас нет причин не доверять ему. В некоторых ситуациях недостатки (можно сказать жестче: «ошибки») во внешнем коде заставляют добавлять дополнительную логику в разрабатываемый вами код. Надо ли тестировать подобное поведение внешнего кода? Иногда я документирую непредсказуемое поведение (ошибку) внешнего кода при помощи теста, который перестанет выполняться, если в следующей версии внешнего кода ошибка будет исправлена.</p>
<subtitle><emphasis><strong>Как определить качество тестов?</strong></emphasis></subtitle><p>Тесты – это канарейка, которую берут в угольную шахту, чтобы по ее поведению определить присутствие запаха плохого дизайна. Далее перечисляются некоторые атрибуты тестов, которые указывают на то, что дизайн тестируемого кода начинает плохо пахнуть:</p>
<p>• Длинный код инициализации. Если вы вынуждены написать сотни строк кода, создавая объекты для одного простого оператора assert(), значит, что-то не так, значит, ваши объекты слишком большие и их требуется разделить.</p>
<p>• Дублирование кода инициализации. Если вы не можете быстро найти общее место для общего кода инициализации, значит, у вас слишком много объектов, которые слишком тесно взаимодействуют друг с другом.</p>
<p>• Тесты выполняются слишком медленно. Если тесты TDD работают слишком медленно, значит, они не будут запускаться достаточно часто. Значит, программист будет в течение некоторого времени работать, вообще не запуская тестов. Значит, когда он их все-таки запустит, скорее всего, многие из них не сработают. На самом деле здесь кроется серьезная проблема: если тесты работают медленно, значит, тестирование частей и компонентов разрабатываемого приложения связано с проблемами. Сложности при тестировании частей и фрагментов приложения указывают на существование недостатков дизайна. Иными словами, улучшив дизайн, вы можете увеличить скорость работы тестов. (Продолжительность работы набора тестов не должна превышать десяти минут, по аналогии с ускорением свободного падения в 9,8 м/с2. Если для выполнения набора тестов требуется более 10 минут, этот набор обязательно надо сократить или тестируемое приложение должно быть оптимизировано так, чтобы для выполнения набора тестов требовалось не более 10 минут.)</p>
<p>• Хрупкие тесты. Если ваши тесты неожиданно начинают ломаться в самых непредсказуемых местах, это означает, что одна часть разрабатываемого приложения непредсказуемым образом влияет на работу другой части. В этом случае необходимо улучшить дизайн так, чтобы данный эффект исчез. Для этого можно либо устранить связь между частями приложения, либо объединить две части воедино.</p>
<subtitle><emphasis><strong>Как TDD способствует созданию инфраструктур?</strong></emphasis></subtitle><p>Инфраструктура (framework) – набор обобщенного кода, который можно использовать в качестве базы при разработке разнообразных прикладных программ. На самом деле TDD является неплохим инструментом разработки инфраструктур. Парадокс: если вы перестаете думать о будущем вашего кода, вы делаете код значительно более адаптируемым для повторного использования в будущем.</p>
<p>Очень многие умные книги говорят об обратном: «кодируйте для сегодняшнего дня, но проектируйте для завтрашнего» (code for today, design for tomorrow). Похоже, что TDD переворачивает этот совет с ног на голову: «кодируйте для завтрашнего дня, проектируйте для сегодняшнего» (code for tomorrow, design for today). Вот что происходит на практике:</p>
<p>• В программу добавляется первая функциональность. Она реализуется просто и прямолинейно, поэтому реализация выполняется быстро и с наименьшим количеством дефектов.</p>
<p>• В программу добавляется вторая функциональность, которая является вариацией первой. Дублирование между двумя функциональностями объединяется и размещается в одном месте. Различия оказываются в разных местах (как правило, в разных методах или в разных классах).</p>
<p>• В программу добавляется третья функциональность, которая является вариацией первых двух. Уже имеющаяся общая логика, как правило, может использоваться в том виде, в котором она уже присутствует в программе, возможно, потребуется внести незначительные изменения. Отличающаяся логика должна располагаться в отдельном месте – в другом методе или в другом классе.</p>
<p>В процессе разработки мы постепенно приводим код в соответствие с принципом открытости/закрытости (Open/Closed Principle<a type="note" l:href="#n_28">[28]</a>), утверждающим, что объекты должны быть открыты для использования, но закрыты для модификации. Самое интересное, что при использовании TDD этот принцип выполняется именно для тех вариаций, с которыми действительно приходится иметь дело на практике. То есть TDD позволяет формировать инфраструктуры, удобные для представления таких вариаций, с необходимостью реализации которых программист сталкивается на практике. Однако эти инфраструктуры могут оказаться неэффективными в случае, если потребуется реализовать вариацию, которая редко встречается в реальности (или которая не была еще реализована ранее).</p>
<p>Что же произойдет, если необходимость реализации непредвиденной вариации возникнет спустя три года после разработки инфраструктуры? Дизайн быстро эволюционирует так, чтобы сделать вариацию возможной. Принцип открытости/закрытости на короткое время будет нарушен, однако это нарушение обойдется относительно недорого, так как имеющиеся тесты дадут вам уверенность в том, что, изменив код, вы ничего не поломаете.</p>
<p>В пределе, когда вариации возникают достаточно быстро, стиль TDD невозможно отличить от заблаговременного проектирования. Однажды я всего за несколько часов с нуля разработал инфраструктуру составления отчетов. Те, кто следил за этим, были абсолютно уверены, что это трюк. Они думали, что я сел за разработку, уже имея в голове готовую инфраструктуру. Однако это не так. Просто я долгое время практиковал TDD, благодаря этому я исправляю допущенные мною многочисленные ошибки быстрее, чем вы успеваете заметить, что я их допустил.</p>
<subtitle><emphasis><strong>Сколько должно быть тестов?</strong></emphasis></subtitle><p>Насколько емкой должна быть обратная связь? Рассмотрим простую задачу: дано три целых числа, обозначающих длины сторон треугольника. Метод должен возвращать:</p>
<p>• 1 – в случае, если треугольник равносторонний;</p>
<p>• 2 – в случае, если треугольник равнобедренный;</p>
<p>• 3 – в случае, если треугольник не равносторонний и не равнобедренный.</p>
<p>Если длины сторон заданы некорректно (невозможно построить треугольник со сторонами заданной длины), метод должен генерировать исключение.</p>
<p>Вперед! Попробуйте решить задачу (мое решение, написанное на языке Smalltalk, приведено в конце данного подраздела).</p>
<p>Это отчасти напоминает игру «Угадай мелодию» («Я могу закодировать задачу за четыре теста!» – «А я – за три!» – «О’кей попробуйте».) Для решения задачи я написал шесть тестов, а Боб Биндер в своей книге <emphasis>Testing Object-Oriented Systems<a type="note" l:href="#n_29">[29]</a></emphasis> («Тестирование объектно-ориентированных систем») для этой же самой задачи написал 65 тестов. Сколько на самом деле нужно тестов? Вы должны решить это сами, исходя из собственного опыта и рассуждений.</p>
<p>Когда я думаю о необходимом количестве тестов, я пытаюсь оценить приемлемое <emphasis>среднее время между сбоями</emphasis> (MTBF, Mean Time Between Failures). Например, в языке Smalltalk целые числа ведут себя как целые числа, а не как 32-битные значения. Иными словами, максимально возможное значение целого числа ограничивается не тридцатью двумя битами, а объемом памяти. Это означает, что вы можете обойтись без тестирования MAXINT. Безусловно, определенный предел существует, ведь теоретически можно создать целое число, для хранения которого не хватит имеющейся памяти. Но должен ли я тратить время на написание и реализацию теста, пытающегося заполнить память невероятно огромным целым числом? Как это повлияет на MTBF моей программы? Если я в обозримом будущем не собираюсь иметь дело с треугольниками, размер сторон которых измеряется такими числами, значит, моя программа не станет существенно менее надежной, если я не реализую такой тест.</p>
<p>Имеет ли смысл писать тот или иной тест? Это зависит от того, насколько аккуратно вы оцените MTBF. Если обстоятельства требуют, чтобы вы увеличили MTBF от 10 лет до 100 лет, значит, имеет смысл уделить время для разработки самых маловероятных и чрезвычайно редко возникающих ситуаций (если, конечно, вы не можете каким-либо иным образом доказать, что подобные ситуации никогда не могут возникнуть).</p>
<p>Взгляд на тестирование в рамках TDD прагматичен. В TDD тесты являются средством достижения цели. Целью является код, в корректности которого мы в достаточной степени уверены. Если знание особенностей реализации без какого-либо теста дает нам уверенность в том, что код работает правильно, мы не будем писать тест. Тестирование черного ящика (когда мы намеренно игнорируем реализацию) обладает рядом преимуществ. Если мы игнорируем код, мы наблюдаем другую систему ценностей: тесты сами по себе представляют для нас ценность. В некоторых ситуациях это вполне оправданный подход, однако он отличается от TDD.</p>
<empty-line></empty-line><p><strong>TriangleTest</strong></p>
<p>testEquilateral</p>
<p>self assert: (self evaluate: 2 side: 2 side: 2) = 1</p>
<empty-line></empty-line><p>testIsosceles</p>
<p>self assert: (self evaluate: 1 side: 2 side: 2) = 2</p>
<empty-line></empty-line><p>testScalene</p>
<p>self assert: (self evaluate: 2 side: 3 side: 4) = 3</p>
<empty-line></empty-line><p>testIrrational</p>
<p>[self evaluate: 1 side: 2 side: 3]</p>
<p>on: Exception</p>
<p>do: [: ex | ^self].</p>
<p>self fail</p>
<empty-line></empty-line><p>testNegative</p>
<p>[self evaluate: -1 side: 2 side: 2]</p>
<p>on: Exception</p>
<p>do: [: ex | ^self].</p>
<p>self fail</p>
<empty-line></empty-line><p>testStrings</p>
<p>[self evaluate: ‘a’ side: ‘b’ side: ‘c’]</p>
<p>on: Exception</p>
<p>do: [: ex | ^self].</p>
<p>self fail</p>
<empty-line></empty-line><p>evaluate: aNumber1 side: aNumber2 side: aNumber3</p>
<p>| sides |</p>
<p>sides:= SortedCollection</p>
<p>with: aNumber1</p>
<p>with: aNumber2</p>
<p>with: aNumber3.</p>
<p>sides first &lt;= 0 ifTrue: [self fail].</p>
<p>(sides at: 1) + (sides at: 2) &lt;= (sides at: 3) ifTrue: [self fail].</p>
<p>^sides asSet size</p>
<subtitle><emphasis><strong>Когда следует удалять тесты?</strong></emphasis></subtitle><p>Чем больше тестов, тем лучше, однако если два теста являются избыточными по отношению друг к другу, должны ли вы сохранить оба этих теста в наборе? Это зависит от двух критериев.</p>
<p>• Первый критерий – это уверенность. Никогда не удаляйте тест, если в результате этого снизится ваша уверенность в поведении системы.</p>
<p>• Второй критерий – это коммуникация. Если у вас есть два теста, которые тестируют один и тот же участок кода, однако читателем эти тесты рассматриваются как два различных сценария, сохраните оба теста.</p>
<p>Отсюда следует, что, если у вас есть два теста, которые можно считать избыточными как в отношении уверенности, так и в отношении коммуникации, удалите наименее полезный из этих тестов.</p>
<subtitle><emphasis><strong>Как язык программирования и среда разработки влияют на TDD?</strong></emphasis></subtitle><p>Попробуйте использовать подход TDD в среде Smalltalk с браузером Refactoring Browser. Теперь попробуйте работать в среде C++ с редактором vi. Почувствуйте разницу.</p>
<p>В языках программирования и средах разработки, в которых цикл TDD выполняется сложнее (тест – компиляция – запуск – рефакторинг), возникает тенденция двигаться вперед более длинными шагами:</p>
<p>• каждый тест охватывает больший объем кода;</p>
<p>• рефакторинг выполняется с меньшим количеством промежуточных шагов.</p>
<p>Приводит ли это к замедлению разработки, или, наоборот, разработка ускоряется?</p>
<p>В языках программирования и средах, в которых проще выполнить цикл TDD, у вас будет возникать желание больше экспериментировать с кодом. Позволит ли это двигаться быстрее и формировать лучшие решения, или вам кажется, что лучше тратить время на дополнительные размышления о дизайне?</p>
<subtitle><emphasis><strong>Можно ли использовать TDD для разработки крупномасштабных систем?</strong></emphasis></subtitle><p>Позволяет ли методика TDD разрабатывать крупномасштабные программные проекты? Какие новые типы тестов вам потребуется написать? Какие новые шаблоны рефакторинга могут потребоваться?</p>
<p>Самой крупной программной системой, целиком и полностью разработанной в стиле TDD, в создании которой я принимал участие, является система LifeWare (www.lifeware.ch). Работа над системой велась в течение 4 лет. Объем работ оценивается в 40 человеко-лет. На текущий момент система включает в себя 250 000 строк функционального и 250 000 строк тестирующего кода (на языке Smalltalk). Набор тестов системы включает в себя 4000 тестов, для выполнения которых требуется 20 минут. Полный набор тестов запускается несколько раз каждый день. Реализованный в системе огромный объем функциональности, похоже, никак не снижает эффективности TDD. Избавляясь от дублирования, вы стараетесь создать большое количество маленьких объектов, которые можно тестировать изолированно друг от друга вне зависимости от размера приложения.</p>
<subtitle><emphasis><strong>Можно ли осуществлять разработку через тестирование на уровне приложения?</strong></emphasis></subtitle><p>Если мы будем выполнять разработку, используя только внутренние программистские тесты (их называют тестами модулей – <emphasis>unit tests</emphasis>, – хотя они не вполне соответствуют этому определению), мы рискуем столкнуться с проблемой: полученная в результате этого система может оказаться не совсем тем или, что хуже, совсем не тем, что хочет получить пользователь. Программист будет работать над программой, которая, <emphasis>по его мнению</emphasis>, должна быть полезна, однако у пользователя может оказаться совершенно другое мнение. Чтобы решить проблему, можно разработать набор тестов на уровне приложения. Разработкой этих тестов должны заниматься сами пользователи (при поддержке программистов). Написанные пользователями тесты должны точно определять, что именно должна делать разрабатываемая система. Такой стиль можно назвать разработкой через тестирование на уровне приложения (ATDD, Application Test-Driven Development).</p>
<p>Встает техническая проблема: как написать и запустить тест для функциональности, которая еще не существует? Мне кажется, что всегда можно найти способ решения этой проблемы. Например, можно разработать интерпретатор, который будет вежливо сигнализировать о том, что обнаружен тест, выполнить который на данный момент невозможно по причине отсутствия в системе необходимых возможностей.</p>
<p>Существует также социальная проблема. У пользователей (на самом деле я имею в виду команду, в состав которой входят пользователи) появляется новая обязанность: разработка тестов. Процедура разработки тестов уровня приложения требует добавления дополнительного этапа в цикл работы над продуктом, – а именно, разработка пользовательских тестов выполняется перед началом реализации очередного объема функциональности. Организации часто сопротивляются подобному сдвигу ответственности. Новый этап требует координированных усилий множества членов команды, то есть перед тем, как приступить непосредственно к разработке кода, члены команды вынуждены потратить время на разработку пользовательских тестов.</p>
<p>Описанная в данной книге методика TDD целиком и полностью находится под вашим контролем. Иначе говоря, выполнение TDD зависит только от одного человека – от вас. Если у вас возникло желание, вы можете начать использовать ее с сегодняшнего дня. Однако если вы будете смешивать ритм красный – зеленый – рефакторинг с техническими, социальными и организационными проблемами разработки пользовательских тестов, вы вряд ли сможете добиться успеха. В данном случае следует воспользоваться правилом «Тест одного шага» (One Step Test). Сначала добейтесь равномерности ритма красный – зеленый – рефакторинг в собственной практике, затем расширьте область применения TDD.</p>
<p>Еще один аспект ATDD: определение длины цикла между разработкой теста и получением результатов его работы. Если заказчик написал тест, а потом в течение десяти дней ждет его срабатывания, это значит, что он большую часть времени смотрит на красную полосу. Если я работаю в стиле TDD на уровне программиста, я</p>
<p>• немедленно получаю зеленую полосу;</p>
<p>• упрощаю внутренний дизайн.</p>
<subtitle><emphasis><strong>Как перейти к использованию TDD в середине работы над проектом?</strong></emphasis></subtitle><p>У вас есть некоторый объем кода, про который можно сказать, что он корректно работает в большей или меньшей степени. Теперь вы хотите разрабатывать весь новый код в рамках концепции TDD. Что делать?</p>
<p>О проблеме перехода на использование TDD в середине работы над проектом можно написать целую книгу (или даже несколько книг). В данном небольшом разделе я очень поверхностно затрону несколько связанных с этим вопросов.</p>
<p>Самая большая проблема заключается в том, что код, изначально написанный без тестов, как правило, сложен в тестировании. Интерфейсы и взаимосвязи между объектами недостаточно хорошо спроектированы, поэтому сложно изолировать некоторый кусок логики, запустить его и проверить результаты.</p>
<p>«Надо это исправить», – скажете вы. Да, однако любой рефакторинг (без применения средств автоматизации), скорее всего, приведет к возникновению ошибок, и эти ошибки сложно будет обнаружить, так как у вас нет тестов. Проблема яйца и курицы. Змея кусает себя за хвост. Замкнутый цикл саморазрушения. Что же делать?</p>
<p>Прежде всего скажу, чего делать не надо: не надо писать тесты для всего кода и выполнять рефакторинг всего кода. Для этого может потребоваться несколько месяцев, в течение которых у вас не будет времени добавить в систему новой функциональности. Если вы тратите имеющиеся у вас деньги и при этом не зарабатываете новых, долго вы не протянете.</p>
<p>Поэтому прежде всего мы должны ограничить область планируемых нами изменений. Если мы видим часть системы, которую можно существенно улучшить, но которая вполне может быть оставлена без изменений на текущий момент, мы оставляем их без изменений. Возможно, взглянув на код и вспомнив грехи прошлого, вы не сможете удержаться от слез, однако возьмите себя в руки, – если код не требует немедленного вмешательства, лучше не изменять его.</p>
<p>Во-вторых, мы должны разорвать замкнутый круг между тестами и рефакторингом. Мы можем использовать в качестве обратной связи не только тесты, но и другие способы, например чрезвычайно осторожная работа в паре с партнером. Мы можем использовать обратную связь более высокого уровня, например тесты на уровне всей системы. Мы знаем, что такие тесты не являются адекватными, однако они прибавляют нам уверенности. Благодаря такой обратной связи мы можем сделать части кода, нуждающиеся в изменении, более удобными для внесения изменений.</p>
<p>Через некоторое время части системы, которые постоянно меняются, станут выглядеть так, как будто их разработали с использованием TDD. Мы медленно углубимся в дремучий лес наших старых ошибок.</p>
<subtitle><emphasis><strong>Для кого предназначена методика TDD?</strong></emphasis></subtitle><p>Каждая практика программирования явно или не явно базируется на системе ценностей. TDD не исключение. Если вам нравится лепить вместе куски кода, которые более-менее работают, и вы счастливы думать, что вам не придется возвращаться к полученному в результате этого коду в дальнейшем, значит, TDD – не для вас. Методика TDD базируется на очаровательно-наивном предположении программиста о том, что чем красивее код, тем вероятнее успех. TDD помогает вам обращать внимание на правильные вопросы в подходящие для этого моменты времени. Благодаря этому вы можете делать дизайн чище и модифицировать его по мере того, как перед вами встают новые обстоятельства.</p>
<p>Я сказал, что предположение наивное, однако, скорее всего, я преувеличил. На самом деле наивно предполагать, что чистый код – это все, что необходимо для успеха. Мне кажется, что хорошее проектирование – это лишь 20 % успеха. Безусловно, если проектирование будет выполнено из рук вон плохо, вы можете быть на 100 % уверены, что проект провалится. Однако приемлемый дизайн сможет обеспечить успех проекта только в случае, если остальные 80 % будут там, где им полагается быть.</p>
<p>С этой точки зрения TDD – чрезвычайно мощный инструмент. Если сравнивать со средним уровнем индустрии разработки программного обеспечения, методика TDD позволяет писать код, содержащий значительно меньше дефектов, и формировать значительно более чистый дизайн. Те, кто стремится к изяществу, могут найти в TDD средство для достижения цели.</p>
<p>Методика TDD также подходит для тех, у кого формируется эмоциональная привязанность к коду. Когда я был молодым программистом, самым большим разочарованием для меня была ситуация, когда проект начинался с огромным воодушевлением, а затем, с течением времени, код становился все более отвратительным. Год спустя у меня, как правило, формировалось устойчивое желание уйти из проекта, чтобы никогда в жизни не иметь дела с этим гнусно пахнущим кодом. TDD позволяет с течением времени поддерживать уверенность в коде. По мере того как тестов становится все больше (а ваше мастерство тестирования улучшается), вы обретаете все большую уверенность в том, что система ведет себя именно так, как вам надо. По мере того как вы улучшаете дизайн, становится возможным все большее количество изменений. Моя цель заключается в том, чтобы через год работы мне было бы интереснее и приятнее работать над проектом, чем в самом начале проекта, и TDD помогает мне достигнуть этой цели.</p>
<subtitle><emphasis><strong>Зависит ли эффективность TDD от начальных условий?</strong></emphasis></subtitle><p>Складывается впечатление, что разработка идет гладко только в случае, если тесты выполняются в определенном порядке. Тогда мы можем наблюдать классическую последовательность красный – зеленый – рефакторинг – красный – зеленый – рефакторинг. Вы можете попробовать взять те же самые тесты, но реализовать их в другом порядке, и у вас возникнет ощущение, что вы не сможете, как прежде, выполнять разработку маленькими шажками. Действительно ли одна последовательность тестов на порядок быстрее/проще в реализации, чем другая последовательность? Существуют ли какие-либо признаки тестов, которые могут подсказать, в какой последовательности их следует реализовать? Если методика TDD чувствительна к начальным условиям в малом масштабе, можно ли считать ее предсказуемой в более крупном масштабе? (Вот аналогия: отдельные потоки реки Миссисипи непредсказуемы, однако вы можете с уверенностью сказать, что через устье реки протекает приблизительно 2 000 000 кубических футов воды в секунду.)</p>
<subtitle><emphasis><strong>Как методика TDD связана с шаблонами?</strong></emphasis></subtitle><p>Все мои технические публикации – это поиск фундаментальных правил, которые позволяют обычным людям действовать так, как действуют эксперты. Это связано с тем, как я сам осваиваю то или иное ремесло, – я нахожу эксперта, которому можно подражать, и постепенно выясняю, что, собственно, он делает. Определенно, я не предполагаю, что сформулированные мною правила должны использоваться автоматически, однако именно так и происходит.</p>
<p>Моя старшая дочь (привет, Бетани! Я же говорил тебе, что ты попадешь в мою книгу, – не беспокойся, это не слишком обременительно) в течение семи лет пыталась научиться быстро перемножать числа. Как я, так и моя жена, когда были маленькими, научились этому за значительно более короткий срок. В чем дело? Оказывается каждый раз, когда перед Бетани вставала задача умножить, например, 6 на 9, она складывала число 6 девять раз (или число 9 шесть раз). Таким образом, можно сказать, что Бетани вообще не умела умножать числа так, как это делают другие люди, однако при этом она необычайно быстро складывала числа.</p>
<p>Я обратил внимание на один важный эффект, который, я надеюсь, смогут принять во внимание и другие. Если на основе постоянно повторяющихся действий формулируются правила, дальнейшее применение этих правил становится неосознанным и автоматическим. Естественно, ведь это проще, чем обдумывать все «за» и все «против» того или иного действия с самого начала. Благодаря этому повышается скорость работы, и, если в дальнейшем вы сталкиваетесь с исключением или проблемой, которая не вписывается ни в какие правила, у вас появляется дополнительное время и энергия для того, чтобы в полной мере применить свои творческие способности.</p>
<p>Именно это произошло со мной, когда я писал книгу <emphasis>Smalltalk Best Practice Patterns</emphasis>. В какой-то момент я решил просто следовать правилам, описываемым в ней. В начале это несколько замедлило скорость моей работы – мне требовалось дополнительное время, чтобы вспомнить то или иное правило или написать новое. Однако по прошествии недели я заметил, что с моих пальцев почти мгновенно слетает код, над разработкой которого ранее мне приходилось некоторое время размышлять. Благодаря этому у меня появилось дополнительное время для анализа и важных размышлений о дизайне.</p>
<p>Существует еще одна связь между TDD и шаблонами: TDD является методом реализации дизайна, основанного на шаблонах. Предположим, что в определенном месте разрабатываемой системы мы хотим реализовать шаблон «Стратегия» (Strategy). Мы пишем тест для первого варианта и реализуем его, создав метод. После этого мы намеренно пишем тест для второго варианта, ожидая, что на стадии рефакторинга мы придем к шаблону «Стратегия» (Strategy). Мы с Робертом Мартином занимались исследованием подобного стиля TDD. Проблема состоит в том, что дизайн продолжает вас удивлять. Идеи, которые на первый взгляд кажутся вам вполне уместными, позже оказываются неправильными. Поэтому я не рекомендую целиком и полностью доверять своим предчувствиям относительно шаблонов. Лучше думайте о том, что, по-вашему, должна делать система, позвольте дизайну оформиться так, как это необходимо.</p>
<subtitle><emphasis><strong>Почему TDD работает?</strong></emphasis></subtitle><p>Приготовьтесь покинуть галактику. Предположите на секунду, что TDD помогает командам разработчиков создавать хорошо спроектированные, удобные в сопровождении системы с чрезвычайно низким уровнем дефектов. (Я не утверждаю, что это происходит на каждом шагу, я просто хочу, чтобы вы немножко помечтали.) Как такое может происходить?</p>
<p>Отчасти этот эффект связан с уменьшением количества дефектов. Чем раньше вы найдете и устраните дефект, тем дешевле это вам обойдется. Иногда разница в затратах огромна (спросите у «Марс-лендера»<a type="note" l:href="#n_30">[30]</a>). Снижение количества дефектов вызывает множество вторичных психологических и социальных эффектов. После того как я начал работать в стиле TDD, программирование стало для меня значительно менее нервным занятием. Когда я работаю в стиле TDD, мне не надо беспокоиться о множестве вещей. Вначале я могу заставить работать только один тест, потом – все остальные. Уровень стресса существенно снизился. Взаимоотношения с партнерами по команде стали более позитивными. Разработанный мною код перестал быть причиной сбоев, люди стали в большей степени рассчитывать на него. У заказчиков тоже повысилось настроение. Теперь выпуск очередной версии системы означает новую функциональность, а не набор новых дефектов, которые добавляются к уже существующим.</p>
<p>Уменьшение количества дефектов. Имею ли я право утверждать, что подобное возможно? Есть ли у меня научное доказательство?</p>
<p>Нет. На текущий момент не проводилось никаких исследований, подтверждающих преимущества TDD по сравнению с альтернативными подходами в смысле качества, эффективности или удовольствия. Однако эпизодические подтверждения преимуществ TDD многочисленны, а вторичные эффекты очевидны. При использовании TDD у программистов действительно снижается стресс, в командах действительно повышается доверие, а заказчики действительно начинают смотреть на каждую новую версию продукта с энтузиазмом. Лично мне не приходилось сталкиваться с обратными эффектами. Однако ваши наблюдения могут оказаться иными, вы должны попробовать для того, чтобы оценить TDD самостоятельно.</p>
<p>Еще одним преимуществом методики TDD, объясняющим ее положительные эффекты, является сокращение времени, которое проходит между принятием проектного решения и проверкой результата его реализации. В рамках TDD это достаточно короткий промежуток времени – несколько секунд или минут. Вы принимаете решение, реализуете его в коде, запускаете тесты и анализируете полученный результат. В начале у вас возникает мысль – возможно, API должен выглядеть так, или, возможно, метафора должна быть такой, – затем вы создаете самый первый пример – тест, который воплощает вашу мысль в реальность. Вместо того чтобы сначала проектировать, а затем в течение нескольких недель или месяцев ожидать, окажется ваше решение правильным или нет, вы получаете результат уже через несколько секунд или минут.</p>
<p>Причудливый ответ на вопрос, «Почему TDD работает?», основан на бредовом видении из области комплексных систем. Неподражаемый Флип пишет:</p>
<p><emphasis>Следует использовать программистские практики, которые «притягивают» корректный код как предельную функцию, но не как абсолютную величину. Если вы пишете тесты для каждой присутствующей в системе функциональности, если вы добавляете в систему новые функции по одной, и только после того, как выполнятся все тесты, вы создадите то, что математики обозначают термином «точка притяжения (аттрактор)». Точка притяжения – это точка в пространстве состояний, к которой сходятся все потоки. Со временем код с большей вероятностью изменяется в лучшую сторону, а не в худшую; точка притяжения приближается к корректности, как предельная функция</emphasis>.</p>
<p><emphasis>Это «корректность», которая устраивает всех программистов (за исключением, конечно же, тех, кто работает над медицинским или аэрокосмическим программным обеспечением). Я считаю, что важно быть знакомым с концепцией точки притяжения – ее не следует отвергать, ею не следует пренебрегать</emphasis>.</p>
<subtitle><emphasis><strong>Что означает название?</strong></emphasis></subtitle><p>Название методики: Test-Driven Development – <emphasis>разработка через тестирование</emphasis>. Буквально можно перевести как «разработка, ведомая тестами» или «разработка исходя из тестов».</p>
<p><emphasis> Development</emphasis> (разработка) – старый поэтапный подход к разработке программного обеспечения обладает рядом недостатков, так как оценить результат проектного решения очень сложно, если решение и оценка результатов удалены друг от друга по времени. В названии TDD термин «разработка» означает сложную комбинацию анализа, логического проектирования, физического проектирования, реализации, тестирования, пересмотра, интеграции и выпуска.</p>
<p><emphasis> Driven</emphasis> (исходя из, через) – в свое время я называл TDD термином <emphasis>test-first programming</emphasis> (программирование «вначале тесты»). Однако антонимом слова <emphasis>fist</emphasis> (вначале) является слово <emphasis>last</emphasis> (в конце). Огромное количество людей осуществляют тестирование уже после того, как они запрограммировали функциональный код. Этот подход считается вполне приемлемым. Существует любопытное правило именования, согласно которому противоположность придуманного вами имени должна быть, по крайней мере отчасти, неприятной или неудовлетворительной. (Термин «структурное программирование» звучит привлекательно, так как никто не хочет писать бесструктурный, то есть неорганизованный код.) Если в ходе разработки я исхожу не из тестов, то из чего? Из предположений? Домыслов? Спецификаций? (Обратите внимание, что слово «спецификация» немножко похоже на слово «спекуляция».)</p>
<p><emphasis> Test</emphasis> (тест) – автоматическая процедура, позволяющая убедиться в работоспособности кода. Нажмите кнопку, и он будет выполнен. Ирония TDD состоит в том, что это вовсе не методика тестирования. Это методика анализа, методика проектирования, фактически методика структурирования всей деятельности, связанной с разработкой программного кода.</p>
<subtitle><emphasis><strong>Как методика TDD связана с практиками экстремального программирования?</strong></emphasis></subtitle><p>Некоторые из рецензетов данной книги, были обеспокоены тем, что книга целиком и полностью посвящена TDD, в результате читатели могут подумать, что остальными практиками XP (eXtreme Programming – экстремальное программирование) можно пренебречь. Например, если вы работаете в стиле TDD, должны ли вы при этом работать в паре? Далее я привожу перечень соображений относительно того, как остальные практики XP улучшают эффективность TDD и, наоборот, как TDD повышает эффективность использования других практик XP.</p>
<p>Программирование в паре. Тесты, разрабатываемые в рамках TDD, являются превосходным инструментом общения, когда вы программируете в паре. Зачастую, работая в паре, партнеры не могут договориться – какую именно проблему они решают, несмотря на то что работают с одним и тем же кодом. Это звучит бредово, однако подобное происходит постоянно, в особенности когда вы только осваиваете работу в паре. Именно этой проблемы удается избежать благодаря TDD. Существует и обратное влияние: когда вы работаете в паре, у вас есть помощник, который может взять на себя нагрузку в случае, если вы устали. Ритм TDD может исчерпать ваши силы, и тогда вы будете вынуждены программировать, несмотря на усталость. Однако если вы работаете в паре, ваш партнер готов взять у вас клавиатуру и тем самым дать вам возможность немного расслабиться.</p>
<p>Работа на свежую голову. XP рекомендует работать, когда вы полны сил, и останавливать работу, когда вы устали. Если вы не можете заставить следующий тест сработать или заставить работать те два теста одновременно, значит, настало время прерваться. Однажды мы с дядей Бобом Мартином (Bob Martin<a type="note" l:href="#n_31">[31]</a>) работали над алгоритмом разбиения линии, и нам никак не удавалось заставить его работать. Несколько минут мы безуспешно бились над кодом, однако нам стало очевидно, что прогресса нет, поэтому мы просто остановили работу.</p>
<p>Частая интеграция. Тесты – это великолепный ресурс, который позволяет выполнять интеграцию значительно чаще. Вы добились успешного выполнения очередного теста, избавились от дублирования, значит, вы можете интегрировать код. Этот цикл может повторяться каждые 15–30 минут. Возможность частой интеграции позволяет более многочисленным командам разработчиков иметь дело с одной и той же базой исходного кода. Как сказал Билл Уэйк (Bill Wake): «Проблема <emphasis>n2</emphasis> не является проблемой, если <emphasis>n</emphasis> всегда равно 1».</p>
<p>Простой дизайн. В рамках TDD вы пишете только тот код, который необходим для успешного выполнения тестов, вы удаляете из него любое дублирование, значит, вы автоматически получаете код, который идеально адаптирован к текущим требованиям и подготовлен к любым будущим пожеланиям. Общая доктрина требует, чтобы дизайна было достаточно для получения идеальной архитектуры для текущей системы. Эта доктрина также облегчает разработку тестов.</p>
<p>Рефакторинг. Устранение дублирования – это основная цель рефакторинга. Тесты дают вам уверенность в том, что поведение системы не изменится даже в случае, если в ходе рефакторинга вы вносите достаточно крупномасштабные изменения. Чем выше ваша уверенность, тем более агрессивно вы выполняете рефакторинг. Рефакторинг продлевает жизнь вашей системе. Благодаря рефакторингу вы упрощаете дальнейшую разработку тестов.</p>
<p>Частые выпуски версий. Если тесты TDD действительно улучшают MTBF вашей системы (в этом вы можете убедиться сами), значит, вы можете чаще внедрять разрабатываемый код в реальные производственные условия и при этом не наносить ущерба вашим заказчикам. Гарет Ривс (Gareth Reeves) приводит аналогию с куплей-продажей ценных бумаг на бирже в течение дня. Если вы занимаетесь краткосрочной спекуляцией ценными бумагами, в конце торгового дня вы должны продать все имеющиеся у вас ценные бумаги, так как вы не хотите принимать риск, связанный с сохранением некоторых ценных бумаг до следующего торгового дня, – этот риск вам не подконтролен. Разрабатывая систему, вы хотите, чтобы вносимые вами изменения как можно быстрее были опробованы в реальных производственных условиях, так как не хотите тратить время на разработку кода, в полезности которого не уверены.</p>
<subtitle><emphasis><strong>Нерешенные проблемы TDD</strong></emphasis></subtitle><p>Дарач Эннис (Darach Ennis) бросил вызов поклонникам TDD, размышляющим о возможностях расширения области применения TDD. Он сказал:</p>
<p><emphasis>Множество различных организаций сталкивается с многочисленными проблемами TDD, и эти проблемы никак не затронуты в книге. Возможно, эти проблемы вообще никак не решить в рамках TDD. Вот некоторые из них</emphasis>:</p>
<p>• не существует способа автоматического тестирования GUI (например, Swing, CGI, JSP/Servlets/Struts);</p>
<p>• не существует способа автоматического тестирования распределенных объектов (например, RPC, Messaging, CORBA/EJB и JMS);</p>
<p>• TDD нельзя использовать для разработки схемы базы данных (например, JDBC);</p>
<p>• нет необходимости тестировать код, разработанный сторонними разработчиками, или код, генерируемый внешними инструментами автоматизации разработки;</p>
<p>• TDD нельзя использовать для разработки компилятора/интерпретатора языка программирования.</p>
<p>Я не уверен, что он прав, но я также не уверен, что он не прав. В любом случае это почва для размышлений о дальнейшем развитии TDD.</p>
</section></section><section><title><p>Приложение I</p>
<p>Диаграммы взаимовлияния</p>
</title><p>В данной книге можно встретить несколько примеров диаграмм взаимовлияния. Идея диаграмм взаимовлияния позаимствована из серии книг <emphasis>Quality Software Management</emphasis> Джеральда Вейнберга (Gerald Weinberg), точнее говоря, из книги 1: <emphasis>Systems Thinking<a type="note" l:href="#n_32">[32]</a></emphasis>. Цель диаграммы взаимовлияния – продемонстрировать, каким образом элементы системы влияют друг на друга.</p>
<p>Диаграмма взаимовлияния включает элементы трех типов:</p>
<p>• Действие или деятельность<a type="note" l:href="#n_33">[33]</a> – обозначается словом или короткой фразой.</p>
<p>• Положительное соединение – обозначается стрелкой, указывающей от одного действия к другому действию. Положительное соединение сообщает, что усиление интенсивности исходного действия приводит к усилению интенсивности целевого действия, а снижение интенсивности исходного действия приводит к снижению интенсивности целевого действия.</p>
<p>• Отрицательное соединение – обозначается стрелкой между двумя действиями, поверх которой нарисован кружочек. Отрицательное соединение сообщает, что усиление интенсивности исходного действия ведет к снижению интенсивности целевого действия, и, наоборот, снижение интенсивности исходного действия приводит к усилению интенсивности целевого действия.</p>
<p>Слишком много слов для очень простой концепции. На рис. П1.1–П1.3 приводится несколько примеров диаграмм взаимовлияния.</p>
<empty-line></empty-line><image l:href="#i_014.png"></image><p><strong>Рис. П1.1.</strong> Два действия, которые, по всей видимости, не влияют друг на друга</p>
<empty-line></empty-line><image l:href="#i_015.png"></image><p><strong>Рис. П1.2.</strong> Два действия, связанные положительным соединением</p>
<empty-line></empty-line><image l:href="#i_016.png"></image><p><strong>Рис. П1.3.</strong> Два действия, связанные отрицательным соединением</p>
<empty-line></empty-line><p>Чем больше я ем, тем больше моя масса тела. Чем меньше я ем, тем меньше моя масса тела. Конечно же, масса человеческого тела – это значительно более сложная система. Диаграммы взаимовлияния – это модели, которые помогают понять некоторые аспекты системы, однако они вовсе не предназначены для того, чтобы понимать и контролировать систему в полной мере.</p>
<subtitle>Обратная связь</subtitle><p>Влияние распространяется не только в одном направлении. Действие может быть связано обратной связью само с собой. Иначе говоря, в некоторых случаях изменение интенсивности действия влияет на само это действие. Иногда это влияние положительно, а иногда – отрицательно. Пример подобной обратной связи продемонстрирован на рис. П1.4.</p>
<p>Существует два типа обратной связи – положительная и отрицательная. Положительная обратная связь приводит к тому, что интенсивность действия в системе</p>
<empty-line></empty-line><image l:href="#i_017.png"></image><p><strong>Рис. П1.4.</strong> Обратная связь</p>
<empty-line></empty-line><p>постоянно увеличивается. Чтобы обнаружить положительную обратную связь, достаточно посчитать количество отрицательных соединений в цикле. Если в цикле четное количество отрицательных соединений, значит, этот цикл является циклом положительной обратной связи. На рис. П1.4 изображен цикл положительной обратной связи: попав в этот цикл, вы продолжаете набирать вес, пока в составе цикла не появится какое-либо дополнительное действие.</p>
<p>Отрицательная обратная связь снижает интенсивность действия. Если в цикле присутствует нечетное количество отрицательных соединений, значит, цикл является циклом отрицательной обратной связи.</p>
<p>Вот три ключа хорошего системного дизайна:</p>
<p>• создание благоприятных циклов, в которых положительная обратная связь приводит к увеличению интенсивности полезных действий;</p>
<p>• устранение вредных циклов, в которых положительная обратная связь приводит к увеличению интенсивности бесполезных, вредных и деструктивных действий;</p>
<p>• создание циклов негативной обратной связи, которые предотвращают чрезмерное использование благоприятных действий.</p>
<subtitle>Контроль над системой</subtitle><p>Выбирая систему практик разработки программного обеспечения, добивайтесь, чтобы каждая практика способствовала применению других практик, благодаря этому вы сможете использовать каждую из практик в достаточном объеме даже в состоянии стресса. На рис. П1.5 показан пример системы практик, которая приводит к недостаточному тестированию.</p>
<p>Когда время начинает поджимать, вы снижаете интенсивность тестирования, что приводит к увеличению количества ошибок, что, в свою очередь, приводит к еще большему недостатку времени. Со временем на сцене появляется некоторое внешнее действие (например, недостаток денег), которое заставляет вас завершить работу над проектом, несмотря ни на что.</p>
<empty-line></empty-line><image l:href="#i_018.png"></image><p><strong>Рис. П1.5.</strong> Недостаток времени для тестирования приводит к общему недостатку времени</p>
<empty-line></empty-line><p>Если вы имеете дело с системой, которая ведет себя не так, как вам того хотелось бы, у вас есть несколько вариантов исправить ситуацию:</p>
<p>• Сформируйте цикл положительной обратной связи в обратном направлении. Если у вас цикл между тестами и уверенностью и тесты все время терпят неудачу, снижая тем самым уверенность, тогда вы сможете сделать больше успешных тестов, повысив тем самым уверенность в вашей способности увеличить количество работающих тестов.</p>
<p>• Сформируйте цикл отрицательной обратной связи, который позволит вам контролировать действие, интенсивность которого стала слишком большой.</p>
<p>• Создайте или разорвите соединения, чтобы устранить циклы, не являющиеся полезными.</p>
</section><section><title><p>Приложение II</p>
<p>Фибоначчи</p>
</title><p>В ответ на просьбу одного из моих рецензентов я включил в книгу описание разработки функции вычисления последовательности Фибоначчи в стиле TDD. Некоторые утверждают, что именно этот пример раскрыл им глаза на механику работы TDD. Однако этот пример очень короток, к тому же в нем не используются многие важные приемы, применяемые в рамках TDD. По этой причине его невозможно использовать в качестве замены примеров, рассмотренных ранее в данной книге. Если, ознакомившись с рассмотренными ранее примерами, вы до сих пор не можете понять, как осуществляется разработка в стиле TDD, ознакомьтесь с данным материалом, возможно, он поможет вам прояснить ситуацию.</p>
<p>Первый тест показывает, что fib(0) = 0. Реализация возвращает константу.</p>
<empty-line></empty-line><p>public void testFibonacci() {</p>
<p>assertEquals(0, fib(0));</p>
<p>}</p>
<p>int fib(int n) {</p>
<p>return 0;</p>
<p>}</p>
<empty-line></empty-line><p>(Я использую класс TestCase как вместилище кода, так как мы разрабатываем всего одну функцию.)</p>
<empty-line></empty-line><p>Второй тест показывает, что fib(1) = 1.</p>
<empty-line></empty-line><p>public void testFibonacci() {</p>
<p>assertEquals(0, fib(0));</p>
<p>assertEquals(1, fib(1));</p>
<p>}</p>
<empty-line></empty-line><p>Я просто добавил еще один оператор assert() в тот же самый тестовый метод, так как не вижу особого смысла создавать новый метод с именем testFibonacciOfOneIsOne.</p>
<p>Чтобы заставить тест работать, можно воспользоваться одним из нескольких методов. Я решаю использовать значение 0 как специальный случай:</p>
<empty-line></empty-line><p>int fib(int n) {</p>
<p>if <strong>(n == 0)</strong> return 0;</p>
<p><strong>return 1</strong>;</p>
<p>}</p>
<empty-line></empty-line><p>Дублирование в тестирующем методе начинает действовать мне на нервы. По мере добавления новых тестов, дублирование будет только усугубляться. Давайте попробуем выделить общую структуру операторов assert(), для этого добавим в тест таблицу входных и ожидаемых значений функции fib():</p>
<empty-line></empty-line><p>public void testFibonacci() {</p>
<p>int cases[][] = {{0,0},{1,1}};</p>
<p>for (int i = 0; i &lt; cases.length; i++)</p>
<p>assertEquals(cases[i][1], fib(cases[i][0]));</p>
<p>}</p>
<empty-line></empty-line><p>Теперь добавление нового теста требует всего шесть нажатий на клавиши и никаких дополнительных строк:</p>
<p>public void testFibonacci() {</p>
<empty-line></empty-line><p>int cases[][] = {{0,0},{1,1},<strong>{2,1}</strong>};</p>
<p>for (int i = 0; i &lt; cases.length; i++)</p>
<p>assertEquals(cases[i][1], fib(cases[i][0]));</p>
<p>}</p>
<empty-line></empty-line><p>Как это ни удивительно, но новый тест работает. Это происходит потому, что константа 1 также подходит и для входного значения 2. Переходим к следующему тесту:</p>
<empty-line></empty-line><p>public void testFibonacci() {</p>
<p>int cases[][] = {{0,0},{1,1},{2,1},<strong>{3,2}</strong>};</p>
<p>for (int i = 0; i &lt; cases.length; i++)</p>
<p>assertEquals(cases[i][1], fib(cases[i][0]));</p>
<p>}</p>
<empty-line></empty-line><p>Ура! Наконец-то тест не сработал. Воспользуемся прежней стратегией (рассматриваем меньшие входные значения как специальные случаи):</p>
<empty-line></empty-line><p>int fib(int n) {</p>
<p>if (n == 0) return 0;</p>
<p>if <strong>(n &lt;= 2)</strong> return 1;</p>
<p>return <strong>2</strong>;</p>
<p>}</p>
<empty-line></empty-line><p>Теперь мы готовы обобщить код. Мы написали 2, однако на самом деле мы имели в виду 1 + 1.</p>
<empty-line></empty-line><p>int fib(int n) {</p>
<p>if (n == 0) return 0;</p>
<p>if (n &lt;= 2) return 1;</p>
<p>return <strong>1 + 1</strong>;</p>
<p>}</p>
<empty-line></empty-line><p>Первая единица в сумме – на самом деле fib(n-1):</p>
<empty-line></empty-line><p>int fib(int n) {</p>
<p>if (n == 0) return 0;</p>
<p>if (n &lt;= 2) return 1;</p>
<p>return <strong>fib(n-1)</strong> + 1;</p>
<p>}</p>
<empty-line></empty-line><p>Вторая единица в сумме – на самом деле fib(n-2):</p>
<p>int fib(int n) {</p>
<p>if (n == 0) return 0;</p>
<p>if (n &lt;= 2) return 1;</p>
<p>return fib(n-1) + <strong>fib(n-2)</strong>;</p>
<p>}</p>
<empty-line></empty-line><p>Теперь окончательно чистим код. Та же самая структура должна работать для fib(2), поэтому мы можем преобразовать второй условный оператор:</p>
<empty-line></empty-line><p>int fib(int n) {</p>
<p>if (n == 0) return 0;</p>
<p>if <strong>(n == 1)</strong> return 1;</p>
<p>return fib(n-1) + fib(n-2);</p>
<p>}</p>
<empty-line></empty-line><p>Это и есть функция вычисления последовательности Фибоначчи, целиком и полностью разработанная в рамках методики TDD.</p>
</section><section><title><p>Послесловие</p>
</title><p><emphasis>Мартин Фаулер (Martin Fowler)</emphasis></p>
<empty-line></empty-line><p>Когда рассказываешь о разработке, основанной на тестировании, сложнее всего передать то психическое состояние, в котором находишься, работая в стиле TDD. Я помню, как в ходе проекта C3 мы с Ральфом Битти (Ralph Beattie) работали над реализацией сложного набора условий выплаты. Ральф сформулировал набор соответствующих тестов, после чего мы приступили к реализации этих тестов одного за другим. Процесс был равномерным и неторопливым, из-за этого казалось, что мы работаем медленно. Однако, взглянув назад на проделанную работу, можно было понять, что, несмотря на кажущуюся неторопливость, мы работали очень даже быстро.</p>
<p>Несмотря на множество появившихся в последнее время мощных инструментов, программирование по-прежнему остается сложной работой. Я часто ощущаю себя в ситуации, когда мне кажется, что я жонглирую шариками и мне приходится следить сразу за несколькими шариками в воздухе: малейшая потеря внимания, и все сыпется на пол. Методика TDD позволяет избавиться от этого ощущения.</p>
<p>Когда вы работаете в стиле TDD, в воздухе постоянно находится лишь один шарик. Вы можете сконцентрироваться на нем, а значит, хорошо справиться со своей работой. Когда я добавляю в программу новую функциональность, я не думаю о том, какой дизайн должен быть реализован в данной функции. Я просто пытаюсь добиться успешного выполнения тестов самым простым из доступных мне способов. Когда я переключаюсь в режим рефакторинга, я не беспокоюсь о добавлении в программу новых функций, я думаю только о правильном дизайне. На каждом из этих этапов я концентрируюсь на единственной задаче, благодаря этому мое внимание не распыляется.</p>
<p>Добавление новой функциональности при помощи тестов и рефакторинг – это две монологические разновидности программирования. Совсем недавно я открыл еще одну разновидность: копирование шаблона. Я занимался разработкой сценария на языке Ruby, извлекающего информацию из базы данных. Я начал с создания класса, являющегося оболочкой таблицы базы данных, а затем сказал себе, что, раз я только что закончил книгу о шаблонах работы с базами данных, я должен использовать шаблон. Примеры программ в книге были написаны на Java, поэтому нужный мне код легко можно было перенести на Ruby. Когда я программировал, я не думал о решении проблемы, я думал лишь о том, как лучше всего адаптировать шаблон для условий, в рамках которых я работал.</p>
<p>Копирование шаблонов само по себе не является хорошим программированием, – я всегда подчеркиваю этот факт, когда говорю о шаблонах. Любой шаблон – это полуфабрикат, – вы должны адаптировать его для условий своего проекта. Однако чтобы сделать это, лучше всего вначале, особо не задумываясь, скопировать шаблон, а затем, воспользовавшись смесью рефакторинга и TDD, выполнить адаптацию. В этом случае в процессе копирования шаблона вы также концентрируетесь только на одной вещи – на шаблоне.</p>
<p>Сообщество XP активно работает над добавлением шаблонов в общую картину. Со всей очевидностью можно сказать, что сообщество XP любит шаблоны. В конце концов, между множеством приверженцев XP и множеством приверженцев шаблонов существует значительное пересечение: Уорд и Кент являются лидерами обоих направлений. Наверное, копирование шаблона – это третий монологический режим программирования наряду с разработкой в стиле «сначала тесты» и рефакторингом. Как и первые два режима, копирование шаблона – опасная штука, если ее использовать отдельно от двух других режимов. Все три вида программирования проявляют свою мощь только тогда, когда используются совместно друг с другом.</p>
<p>Если вы хотите сделать некоторый процесс эффективным, вы должны идентифицировать основные действия, из которых состоит процесс, а затем добиться, чтобы в каждый момент времени внимание концентрировалось только на одном таком действии. Примером такого подхода является сборочная линия, где каждый рабочий выполняет только одну из множества необходимых процедур. Внимание каждого рабочего сконцентрировано только на одном действии. Методика разработки через тестирование (TDD) подразумевает разделение процесса программирования на элементарные режимы, однако при этом она избавляет от монотонности, позволяя быстро переключаться между этими режимами. Комбинация монологических режимов и переключения между ними обеспечивает должную концентрацию внимания, снижает стресс и избавляет от монотонности сборочной линии.</p>
<p>Я признаю, что все эти мысли несколько сыроваты. Когда я пишу это, я по-прежнему не уверен в том, о чем рассказываю. Я знаю, что буду обдумывать все эти идеи еще в течение нескольких, а может быть, и многих месяцев. Однако я полагаю, что эти идеи должны вам понравиться. Прежде всего, они стимулируют размышления о более крупной картине, в которую вписывается разработка через тестирование. Мы еще не видим эту картину достаточно четко, однако мне кажется, что она постепенно становится все яснее и яснее.</p>
</section></body><body name="notes"><title><p>Примечания</p>
</title><section id="n_1"><title><p>1</p>
</title><p>Бек К. <emphasis>Экстремальное программирование</emphasis>. СПб.: Питер, 2002. ISBN 5-94723-032-1.</p>
</section><section id="n_2"><title><p>2</p>
</title><p>Подробнее о подсистеме отчетов рассказано на с2.com/doc/oopsla91.html.</p>
</section><section id="n_3"><title><p>3</p>
</title><p>USD – доллары США, CHF – швейцарские франки. – <emphasis>Примеч. пер</emphasis>.</p>
</section><section id="n_4"><title><p>4</p>
</title><p>Название метода times() можно перевести на русский как «умножить на». – <emphasis>Примеч. пер</emphasis>.</p>
</section><section id="n_5"><title><p>5</p>
</title><p>Код с душком (code that smells) – распространенная в XP метафора, означающая плохой код (содержащий дублирование). – <emphasis>Примеч. пер</emphasis>.</p>
</section><section id="n_6"><title><p>6</p>
</title><p>Имеется в виду индикатор успешного выполнения тестов в среде JUnit, имеющий форму полосы. Если все тесты выполнились успешно, полоса становится зеленой. Если хотя бы один тест потерпел неудачу, полоса становится красной. – <emphasis>Примеч. пер</emphasis>.</p>
</section><section id="n_7"><title><p>7</p>
</title><p>В переводе на русский язык <emphasis>sum </emphasis>– это сумма. – <emphasis>Примеч. пер</emphasis>.</p>
</section><section id="n_8"><title><p>8</p>
</title><p>Используя игру слов (английское change означает как «изменение», так и «обмен»), автор намекает на свою знаменитую книгу-бестселлер <emphasis>Extreme Programming Explained: Embrace Change</emphasis>. Русский перевод: Бек К. Экстремальное программирование. СПб.: Питер, 2002. 224 с. – <emphasis>Примеч. ред</emphasis>.</p>
</section><section id="n_9"><title><p>9</p>
</title><p><emphasis>Fractals and Scaling in Finance </emphasis>/ Benoit Mandelbrot, editor. SpringerVerlag, 1997. ISBN: 0387983635</p>
</section><section id="n_10"><title><p>10</p>
</title><p>В переводе с английского языка <emphasis>was run </emphasis>означает <emphasis>был выполнен</emphasis>. – <emphasis>Примеч. пер</emphasis>.</p>
</section><section id="n_11"><title><p>11</p>
</title><p>В языке Python заголовок определения метода (функции) начинается со служебного слова def, а завершается двоеточием. Операторы тела метода записываются ниже, в отдельных строчках. Группировка операторов тела определяется отступами (вместо фигурных скобок). – <emphasis>Примеч. ред</emphasis>.</p>
</section><section id="n_12"><title><p>12</p>
</title><p>Спасибо Дункану Бусу (Duncan Booth) за то, что он исправил допущенную мной ошибку, типичную для малоопытных программистов на Python, и подсказавшему мне решение, в большей степени соответствующее этому языку.</p>
</section><section id="n_13"><title><p>13</p>
</title><p>В переводе с английского языка <emphasis>assert </emphasis>означает утверждать, предполагать. Иначе говоря, оператор assert фиксирует предположение о прогнозируемом результате теста. – <emphasis>Примеч. науч. ред.</emphasis></p>
</section><section id="n_14"><title><p>14</p>
</title><p>Имеются в виду <emphasis>пожелания пользователей </emphasis>(user stories). Другой вариант перевода: <emphasis>пользовательские истории</emphasis>. – <emphasis>Примеч. пер.</emphasis></p>
</section><section id="n_15"><title><p>15</p>
</title><p>Спасибо Джиму Ньюкирку (Jim Newkirk) и Лорану Боссави (Laurent Bossavit) за то, что независимо друг от друга предложили мне этот шаблон.</p>
</section><section id="n_16"><title><p>16</p>
</title><p>Например, www.mockobjects.com.</p>
</section><section id="n_17"><title><p>17</p>
</title><p>Спасибо Дирку Кенигу (Dierk König) за пример.</p>
</section><section id="n_18"><title><p>18</p>
</title><p>Спасибо Лорану Боссави за дискуссию.</p>
</section><section id="n_19"><title><p>19</p>
</title><p>Обычно необязательные параметры располагаются в конце списка аргументов, однако в данном случае необязательная информационная строка размещается в начале списка, так как благодаря этому тесты удобнее читать.</p>
</section><section id="n_20"><title><p>20</p>
</title><p>В переводе с английского <emphasis>fixture </emphasis>означает арматура, оснастка, зафиксированная деталь некоторого движущегося механизма. – <emphasis>Примеч. пер.</emphasis></p>
</section><section id="n_21"><title><p>21</p>
</title><p>McConnell, Steve. <emphasis>Code Complete</emphasis>, chapter 4. Seattle, Washington: Microsoft Press. 1993.</p>
</section><section id="n_22"><title><p>22</p>
</title><p>Caine, S. H., Gordon, E. K. 1975. PDL: <emphasis>A Tool for Software Design, AFIPS Proceedings of the 1975 National Computer Conference.</emphasis></p>
</section><section id="n_23"><title><p>23</p>
</title><p>В среде англоязычных программистов запись в базе данных иногда обозначается термином <emphasis>tuple – кортеж</emphasis>. – <emphasis>Примеч. пер.</emphasis></p>
</section><section id="n_24"><title><p>24</p>
</title><p>Alexander Christopher. <emphasis>Noteson the Synthesis of Form. </emphasis>Cambridge, MA: Harvard University Press, 1970.</p>
</section><section id="n_25"><title><p>25</p>
</title><p>Gamma, Erich; Helm, Richard; Johnson, Ralph; Vlissides, John. <emphasis>Design Patterns: Elements of Reusable Object Oriented Software. </emphasis>Boston: Addisoh-Wesley, 1995. Русское издание: Гамма Э., Хелм Р., Джонсон Р., Влиссидес Дж. <emphasis>Приемы объектно-ориентированного проектирования. Паттерны проектирования. </emphasis>СПб.: Питер, 2001.</p>
</section><section id="n_26"><title><p>26</p>
</title><p>Подробнее об этом шаблоне рассказывается в книге Beck, К. <emphasis>The Smalltalk Best Practice Patterns</emphasis>. Pp. 70–73. Englewood-Cliffs, NJ: Prentice-Hall, 1997. Ссылаться на свои собственные работы – это не самая лучшая идея, однако, как говорил философ Филлис Диллер (Phyllis Diller): «Конечно же, я смеюсь над собственными шутками, просто я не доверяю никому, кроме себя».</p>
</section><section id="n_27"><title><p>27</p>
</title><p>Fowler, Martin. <emphasis>Refactoring: Improving the Design of Existing Code. </emphasis>Boston: Addison-Wesley, 1999. Русское издание: Фаулер. М. <emphasis>Рефакторинг: улучшение существующего кода. </emphasis>СПб.: Символ-Плюс, 2003</p>
</section><section id="n_28"><title><p>28</p>
</title><p>Один из основных принципов объектно-ориентированного программирования, утверждающий, что разрабатываемый код должен быть достаточно гибким, чтобы его можно было повторно использовать без дополнительных модификаций (то есть он должен быть открыт для использования, но закрыт для модификаций). – <emphasis>Примеч. пер.</emphasis></p>
</section><section id="n_29"><title><p>29</p>
</title><p>Binder, Bob. <emphasis>Testing Object-Oiiented Systems: Models, Patterns, and Tools. </emphasis>Boston: Addison-Wesley, 1999. Это действительно исчерпывающее руководство по тестированию.</p>
</section><section id="n_30"><title><p>30</p>
</title><p>Mars Lander – американский космический аппарат, был запущен в сторону Марса 3 января 1999 г. 3 декабря 1999 г. аппарат должен был осуществить посадку на Марс, однако в этот день связь с ним была потеряна, предположительно из-за ошибки в программном обеспечении. Стоимость миссии составила приблизительно 120 млн долларов, не считая стоимости ракеты-носителя и некоторого дополнительного оборудования. – <emphasis>Примеч. пер.</emphasis></p>
</section><section id="n_31"><title><p>31</p>
</title><p>Боб Мартин – известный деятель движения Agile Development (гибкая разработка), которого часто с уважением называют дядей. – <emphasis>Примеч. пер.</emphasis></p>
</section><section id="n_32"><title><p>32</p>
</title><p>Weinberg, Gerald. <emphasis>Systems Thinking. Quality Software Management. </emphasis>New York: Dorset House, 1992.</p>
</section><section id="n_33"><title><p>33</p>
</title><p>Если исходить из примеров диаграмм взаимовлияния, приводимых автором книги, элемент этого типа может также называться «характеристика». – <emphasis>Примеч. пер.</emphasis></p>
</section></body><binary content-type="image/png" id="i_001.png">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</binary><binary content-type="image/png" id="i_002.png">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</binary><binary content-type="image/png" id="i_003.png">iVBORw0KGgoAAAANSUhEUgAAAj0AAAA9CAIAAADJbE9/AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAE2UlEQVR42u3csW4UVxTGcd4iErxLxFvAO4QiiNooNWTLJAUUQAUiZZzSyJUp3Zl0ZCqQXLhauVuOONLhMjszO0bGWrO/T59Wd2fHLq4/nf89c+/6xoqIiOj66IYpICIi3CIiIsItIiLCrd77mz/dYmZm3ipv4Nav9x8wz7TAsLTwFSQHt1glYmlh3GKViFlaGLdYJWJpYcnBLVaJWFoYt1glYpYWxi1WiVhaWHJwi1UilhbGLVaJmKWFt41bf/z5V94Wg3j77PmLfHt09NbMqkTrPj8/b9P17t1/ZkxaxhxlpEKy9/C39+//lxm+fG59+PARt+RpI7cODt7E+OzsrMYsLdPcilfQ4svn1j/7/9ZPJbfitUimPKlEPW5lNixxpGUjtx49/r1dH+eKJwpOjCNLMY5W7PXrv2MQAcsrMcib855q9ONO045bX7gVYYpwZKQicNnXx2vl7NnzF6Ybt5JbEYxMRZQbkyYt09w6Pj6OQSx0ikPVe+XDw2BYcSsGuWERAWvBFuPgX/ySLEqMW6vs4iMig4vorFC1/GH7W7X4lQppmeZWKRusxE8iqgZxsbjVJi3X0xbNuDXMrVrd9LilPVeJxp4T1vMckyYt0/1WVpXqt6rNytfoxia4VQOzjVsD3JrYtMiLtVxi3Fo/1MPSMsatikptk7e76fmoeZBb0ZDpt3BrlFu1FCpuRcKKXrilEo31W9mms7RMnyfMtLSrnMxS5aflVlIti1K7v9VuujNufdldL27FR/Gaix3nCVWisf2tWBGbNGnZyK2qLbVEzoeEtTgubmXNafnkPCFuMX97JWK+lLT0TsavPydk3DJNjFu8RWnJp3/tSQ3cwi3cYtxiaWHcYpWIWVoYt1glYmlh3MItVolYWhi3WCVilhbGLVaJWFoYt77iFjMz81Z5A7dWRLMlMCQtdMXJwS1SiUhaCLdIJSKSFsItUolIWkhycItUIpIWwi1SiYikhXCLVCKSFpIc3CKViKSFcItUIiJpoe3h1quXr+o7zPd+ube/v394eBjj09PTuufunbt7ew9j8OTJ097Xnk9OTvwZdqQSxacRj3ob47q/DUakqOu6yE+bk7gYuTLDu8atLC+DH2V+xv6HAuHWqKKa3P75dhWUCFnwaZpbMTbvuNVyK1IRKcoVTMRmsVhEhJJbGa3lcplga3+cfuy0RB6mgdSuewi35gYr+bTeMOGWPF2IWxWPVi232vvbXNEP329NwAm3JOdbuJXL5DGe4ZY8ze+3YhCv0VdNcCuvaLlwq/2oHiNb0ODWrGAFigYhlNzqeWx/y98At1Zf75ImwNa5tf4baJe5Veq6brBlJ9zSb9F35FbvYuREv4Vbq9kPAyeObxBuDfDJ/hbNDEyscqK+tLVmcN0TUQnb38KtC3FrMEuEWwNynpAu2qB3Xbf6/GwnxnElQVVdVJ4ii7c9bjlPiFsZm3ibq5/81k0vS4Rbs4LV++bNxu9v4dbOVqLlcrlYLCotMc6DGJGZSEVdz2Lk+1s7npb2HHw+Ou713O25jMiS+cStC3CLSGDoatKy+CxTJzm4RbhF1yAt0Z37DzuEW4RbJC2EWyRPRNJCuEUqEUkLEW6RSkTSQrhF8kQkLYRbpBKRtBDN4hYzM/NWeYpbRERE2yzcIiKi66RPgAZfgfXmyWwAAAAASUVORK5CYII=</binary><binary content-type="image/jpeg" id="i_004.jpg">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</binary><binary content-type="image/jpeg" id="i_005.jpg">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</binary><binary content-type="image/png" id="i_006.png">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</binary><binary content-type="image/png" id="i_007.png">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</binary><binary content-type="image/png" id="i_008.png">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</binary><binary content-type="image/png" id="i_009.png">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</binary><binary content-type="image/png" id="i_010.png">iVBORw0KGgoAAAANSUhEUgAAAmUAAAChCAIAAAAJC1/7AAAACXBIWXMAAA7EAAAOxAGVKw4bAAAO/klEQVR42u3dv28b6ZkH8P0vDNj/RO6A5IK1XV6uvpPU3pYicHeblGKTlGKVVBa2SJDA6sWexXbsWbO1XLJl63vgL/JmdvhjZO9mNaI/HxACSQ3J4St7vvO88847X30AAIZ8pQkAQF4CgLwEAHkJAPISAOQlAMhLAJCXAIC8BAB5CQDyEgDkJQDISwCQlwAgLwFAXgIA8hIA5CUAyEsAkJcAIC8BQF4CgLzkCVgul/O7+ex6Nr2adm83b27q+XZbLBbrj+7f3Ws0AHn5heblarVa/1AFZDcvKz6To69evn7+7EXd8rBF6Xa71ZgA8pIfqHSsjGy16eRyUgl6fnZR9+uZ+pUmApCX7Hf/7r4S9PbtbeKzfspOAHnJQAG6Wq0qO6vofPXy9c2bm3qoWQB5CQdtNpvFYlHlZoLTiCFAXsIxlZRVcVZqVnYul0sNAshLOKbC8vzsom5SE5CXMGC9XlehKTUBeQkPrTWnV9PNZqM1AHkJB2232/nd/NXL14vFQmsA8hKOuX93nxkPTBUEyEsYKDQzW5BzTgB5CQNyzonIBOQlDFgulyITkJfw0Mg0aBaQlzAgU7cb/gPISxiQK1drB0BewjFVXL56+dq1TQB5CQMqLM/PLvTKAvISBkyvpvO7uXYA5CUcs16vX718rcQE5CUMl5hmlwXkJQxYrVaTy4l2AOQlDDDjDyAvYdjNmxtdsoC8hAGr1Wp6NdUOgLyEY7bb7fNnL7QDIC9hwPnZhUOYgLyEAdOr6Xq91g6AvIRjbt/emugHkJewx2q1WiwWuRBmhWXycrvdLpdLw2UBeQn/MLmcPH/2Yno1nV3P/vTHP9XPemgSdkBewg/cv7uvgOzdHMgE5CX0ze/m3bB0EWlAXsIeuXB0wtK1SgB5CcMlpiGygLyE4RIzY2UB5CXsd/v21pFLQF7CgKosDYsF5CUAyEu+bOuPzJYOyEvYY7vdZjqedptcTqQmIC/hB2GZqexu3twsl8vVamUqO0BeQl/F5O7pktOraT1Z8VlV5nrHh489t5vNpgI1d3rvmSE/ZTdx86vd5+uDVLSAvGS8UkruploVmvUzwdm75VWpSlv/bYvA27e37flXL19X6PYK2d5sebVAmxWo1qQ+1x8FkJeMS5V6uajIoQVafZmEa/Vl4m12PasFMqdPxWTCL29Yi9X9yr82d0GFZeViLVwvSVGb2rSerF+llq3l9QMD8pKR5mWibrAM7fbZpqZsD5N/dSfHPlsPbRWLeWFFYPeD6mEOlyZru8vXM+YGAuQl41LJdLy+PJKX3YeJvSoQ9/bfptzce3mvFrSHVMTWy7u3iuRckjq3ith2YFVhCshL/llevXxdt8G6czcvu79tZWLysptndas68lBeZvkjq7c74GixWHTfvOVo9+Do+dlFnqw8zmJ5rcoVkJd8pgzP6c34muOObajOh6H+2EqmhG76Y1supuKshMvVpLv9sbV8LZxPbyNjc/iz+7mfp4VrwrIVqW1gUR7W861CVZsC8pIBKfISbBUhCctuHO7Ny7ykwqZ7RkoOWNY75FTOjPFp430SzO0Uz4rJdAjX8vXRGR+0O1j3J5fTYFqaJjvbQN+6X0/W+qhHQV5CPz96xx0r1Xr11m5eVrC1cq3bN9s9PyQDX3c/JQG5u3wG3D5iU1RGZsxRtUCrR+tb5KBp/cpJoiAvkZrbh4+aaaOEDuXHoeKsntz7ktEWc2mWDOWtr9yK7xwZ/Wk7cnOwVlEL8pLT8cBRtacqw45yWDTlcgrQz4vPCsj0aWeYUu7kJBz/0kBeIi9PR9WFVYD24jOjnAZfmyFOvbNOK3dTy+r+BXkJpxyfFZZVMqbzNgOI9l5DO8duD4Vivap+q8oEeQmnLzPxVumZ4cHd7MxJNXtztMmwI80I8hK+IBWQyc4MLf7mv7/59tvfHh/dk0zVKwvyktPUzhXhSN1Zefm73/6u4rDis0L0UKGZgbhaDOQlpybH5Bx1G/T82Yu0UiVlKzozn0Nv56M3+xIgLzkF7VrTmmIwL3vPZKBQJkVqwVktObueaS6Ql5yUzKu+9xrU9Bw5XWSz2bTgrJ9/+fNfNBfIS06wuMxNiXncQw5MVqB+/euvf/Pv/5EZDEz9A/KSU5DJ1rsX1XIU83gtPnigN3PQp20zB9DsetY7wAnIS56S2u7n9PzurTsPO3tLzMnl5FBkVnFZgdpNx1pysVjkKi51x+4IyEue5KY/1c/3339fd3L4be81ounmX7VS3XYPZFYDVlge6tOuEM3lU2qPRCctyEuejIxPaeVOG/lZMeDcwUGZ965Ss13dOhXk4K5Gm6i9fkpNkJc8PbtnSjBYaOaSYbl90oQ+lZQVsTkFRWqCvOQpqVJJN+zPn7ipU6UmyEuejNn1zMkkj6L10FbFaTQQyEvGLgfhtMMjpmZGA5nIF+Qlo7ZeryeXE+3w6H+F87OLvYNvAXnJWFRx4yjaSGp93bMgLxkvhzDHI92zR6arBeQlj6bCsrbR2mE8FotFFZpOhwV5yejokh2bqi8nl5Paj9E3C/KSEbl9e+tCx2NTSVl/lNqV0TcL8pKxqOLy+bMXSswRWi6XLrgG8pIRqVJGiTlOuZqYw5kgLxlLianrb7Tq73J+dmGHBuQlo1AVjIGyo5ULiolMkJeMQm2RTcwmMkFewoD7d/d6ZUUmyEsYNr+b1xbZaX9jjkzzs4O8ZBRm1zMVzPi7AVarlaZAXsIjVzBVYjqBYcwqLPWcIy/h8eX0EqfJj1l6zrUD8hIeWTr9ROaY6QZAXoLI5KHdAHplkZcgMhmgVxZ5CeOKTCNmR+v87MIODfISRmGz2VQRM7ueOS9zhNbrdUWmPw3yEkahNseVl5WajpaN0PRqagYD5CWMyPxu7nDmaEtM7YC8hHFtmnM4UwfgqFTpbz8GeQnjUkk5vZpWQVPZqTVGosLS5diQlzBGi8WiCs3bt7cKzZHsxDx/9mKz2WgK5CWMTm2dU2ia+3sMbt7cGPWDvITxqrCsyKzgVNw8Ll2yyEsYu+12O7+bP3/2Qvfs4/4V6k+gHZCXMHZVX86uZ69evq7slJqPYnI5MQgLeQlPQ22vp1dTqfkoqr53xRLkJUhNBiyXyyrxtQPyEr6s1Lx/d1/vYBjRpza4dkBewlPdiOe45s2bm4eEXy1TS9bydUvcOtHzgQz5QV7Ck9dSsCLwyPmay+VyN1mr0Ezimu19kLxEXsKJFECLxeL87KJu87t5r9ysHK1QPDTCM1EqMndVS7ZdkGqiFOLVtlWU681GXsLTVtv3KhmrGKqf2dbXVn7w4ifJWq3XU/sQ1ZLptZ5cTv7217/Vz3rGVb6Rl3AiqvpJBNa2/g+//8P//s//Db6kFnYhjr0lZgVk9+Yi0shLOM0K6b/+8+xffvGvtZWvBD3Si1i/VTYd2pPo5qW9CuQlnKbp1XS9Xq9WqwwLmlxO9ganUyYOqZZpYamJkJdw4nmZ+9vtNqfeJzjnd/M2zEdeHm/D5KVZ8ZCXcMrb+r3nmbSK8/zs4vbt7XfffWcKm0NqJ0NxibyEEzd4YLJqpsrLX/3y3zKq9vhhzi+W8VDISzhxOZ/k+OmVFZm1zPv371tvbcVDpWzVoMaCthJTIyAv4fRLzCNnQVSU7p6gWQk6v5vnuN3kclIFqOwEeQmnL4cqd4ukitLjsxlURlZS5oT9bnbqswV5CaepQi4T5s2uZ1U7tlGynzTms1t35q0qccc5arR2Amo9uzeTy4O8hIe6f3dfCVeZV3HyI+eMzVtV5Zoz+hNIP/5tfyqZmqd2CBKWqY/NzgPyEh5ThVBKz6o4e/H5WNVn8rL76XnGyB2QlzDe+KzyLv3AP9ulqnfzcrVatbxMb+1uKZyY/7CvO7edf5npeVvB2k5vrXfbfUk+ou50c7r7sO60KfeqWE/5m7fa+5JavaxhVKt2Vyyz7fdWrNslsLuGedt01/dWI3/KdCHkenDVnsffJEfKd7/LbpsgL4E9ajtbm9Ta0OdS1SlAa5Oaa2b9MzagycscXs2nZ6OftN5N02jzEmSBrGE7ZPvh7+fn5FzV+jq5n2TKzHm9l+Qj6k490/2UPEyEZ8qILJ9Pz1vtfUk3udt08FmxBF6tQFux3hes795dt9zPdIm91ai9gZbTWataMicavX//Pi/Mx7U3ycrkci7dN8l3yTvkqHnd/I+Ql8AnFKA5klpb0mx562fKu2x/f2SI7l5apJtAD8zLtkAefvg4orjbqZtrfnWDofeS43mZL94K7oq6eljv+ZC8rFcle7JimYSolZ7124T6kcZpD1Mrt9WoN8ma91ajHnbL1rYPEUnTbuGbPYnem7Q3979AXgKfKTlRG9YUKNmI11a47qcvNzlaHjJmp1df1p1WVH3YGQ3ULgE9mJeJge4HJfMG8zIFVm5tNdoXzK1VbN2arPeSlpep1BM/LYfaN8qXPVTJ9fKytxpp+VomOweHdly6eZl47gZ88rv3XVL4qi/lJfDTqw1xelNbjrbZz4/PW7S3gmw1UOturVviISE0mJe9oqr7zPG8TPXc1n9vXrZjgXmrvS/Jw/Sg1s9ekHfzsttz+0l52VYjix3aO+k2xW5BnMq75WW+S6rhWknn78pL4GeN0iOF5t68zCHM3d+mOMsm/nheZsnu5r62/nnPz+iPTZB0Mybz9x7vj61PTPx0V2x39O+RU2P35uXuaqS+bB2w9Ux3FFJv1yH7H+1hEj3r0OvU7X015CXwmHr9sSUVWA7pdcMs1zJLCg7mZetdTLdwns9Rw96RuYfkZVYpEynUp7cRScfzMuV1d+BSW7E2AUW3C3cwL3PcNKtRsgew+ai9ZwbKdvcVenmZh9XgOTjd3qT7XTLgyFk98hIYXV72brVNT0m6+9tk3mBetnRptxRV7XhhK3kfkpfJyO67JUgG87I3cKlbJbdbG+M6mJfJyN3V+PD3w5C7A6Z28zITEbclW29594LbgyuGvAR+bqlsuroHO3u/7V43O/ezQAu/POxmQ4bDtBfWnYqWbj9t9x16Z512H+Yi3plxqXvW46GXZFRU71OOrNiRxuk9ubsavffsHXTsrUn3u3Rn5893aRy5lJcAIC8BQF4CAPISAOQlAMhLAJCXACAvAeBJ+X87vqkHV/7JGQAAAABJRU5ErkJggg==</binary><binary content-type="image/png" id="i_011.png">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</binary><binary content-type="image/png" id="i_012.png">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</binary><binary content-type="image/png" id="i_013.png">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</binary><binary content-type="image/png" id="i_014.png">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</binary><binary content-type="image/png" id="i_015.png">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</binary><binary content-type="image/png" id="i_016.png">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</binary><binary content-type="image/png" id="i_017.png">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</binary><binary content-type="image/png" id="i_018.png">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</binary><binary content-type="image/jpeg" id="cover.jpg">/9j/4AAQSkZJRgABAQEASABIAAD/4QwMaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wLwA8P3hwYWNrZXQgYmVnaW49J++7vycgaWQ9J1c1TTBNcENlaGlIenJlU3pOVGN6a2M5ZCc/Pgo8eDp4bXBtZXRhIHhtbG5zOng9J2Fkb2JlOm5zOm1ldGEvJyB4OnhtcHRrPSdJbWFnZTo6RXhpZlRvb2wgMTAuNDAnPgo8cmRmOlJERiB4bWxuczpyZGY9J2h0dHA6Ly93d3cudzMub3JnLzE5OTkvMDIvMjItcmRmLXN5bnRheC1ucyMnPgoKIDxyZGY6RGVzY3JpcHRpb24gcmRmOmFib3V0PScnCiAgeG1sbnM6RkIyPSdodHRwOi8vd3d3LmZpY3Rpb25ib29rLm9yZy8nPgogIDxGQjI6U3lzdGVtVGh1bWJuYWlsPjUzNjE2Yzc0NjU2NDVmNWY0OWRlMjgyMzVkZTI1Mzg4ZTYyZDNjMjVjZjQ3N2IyMzdkZDJiYzk0Y2ViYTg5MzViZDAyZDU5NmE0ZjUwMDIxOTAzZjFiNTFjYmRjNmVjNmEzZGJjZTNmNTczNWRhNDk1NjhlOGE2MWFhMjdkMDdlNDZlMGE2Nzk5ZjBmMjdmYTU4ZWVkYmZmZDM0MzM3NDc1NThkYzc0MTU3YTU4NjUyY2E4NzI0OTdmNzk3MzkwNmI5ZDUzMjczOTlkOTNmZDAwYzljZDViYmIzYjc1YWRiZTM5YmRiNmRhM2Y2OTk0ZTRhYjVmYWRjMDI5NDYyNDQ8L0ZCMjpTeXN0ZW1UaHVtYm5haWw+CiA8L3JkZjpEZXNjcmlwdGlvbj4KPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgCiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAKPD94cGFja2V0IGVuZD0ndyc/Pv/bAEMAAgEBAgEBAgICAgICAgIDBQMDAwMDBgQEAwUHBgcHBwYHBwgJCwkICAoIBwcKDQoKCwwMDAwHCQ4PDQwOCwwMDP/bAEMBAgICAwMDBgMDBgwIBwgMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDP/AABEIAyICOgMBEQACEQEDEQH/xAAeAAEAAQQDAQEAAAAAAAAAAAAACQEGBwgEBQoDAv/EAHwQAAECBQEFAgYIChAPCwgIBwECAwAEBQYRBwgJEiExE0EKFCJRYXEVFjJ2gZG00SM4OUJSU3WTsbMXGDM3VFVicnOCkpSVobLSGRokJjQ1NkNHdHeDlrXTJScpRVZXoqPCxNQoOkRjhYeXwUZlZoSkw8bwWGRnhqXh8f/EAB0BAQAABwEBAAAAAAAAAAAAAAABAgMEBQYIBwn/xABXEQACAQIDAwYHCwcICAcBAQEAAQIDEQQFEgYhMQcTQVFxkQgiMmGBscEUFTM0NTZScnOhshZCVIKT0dIXIzdTg5LC4RhFYnSEs8PwJCVDVWOi8SZko//aAAwDAQACEQMRAD8Aw/Hm59WBACAEAIAQAgBACAAgBACAEAIAQAgBACAEAIAQAgBACAEABACAEAIA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CAHSAEAIAQAgBACAEAIAQA7oAQAgBACAEAIAQAgBACAEAIAQAgBACAEAIAQAgBACAEAIAQAgBACAEAIAQAgBACAEAIAQAgBACAEAIAQAgBACAEAIAQAgBACAEAOsAIAQAgBACAEAIAQAgBACAEAIAQAgBACAEAIAQAgBACAEAIAQBTiHnHxwsS649a70VyPOPjhYa49a70UyPOn44WGuPWu9Fcjzj44WGuPWu9DI84+OFhrj1rvKcQ84+OFhrj1rvK5HnHxwsNcetd4yPOPjhYa49a7ymR50/HCw1x613lcjzj44WGuPWu8cQ86fjhYa49a7xkecfHCw1x613lOIDvHxwGuPWu8qVAd4+OA1x613lAoecfHCw1x613jiA7x8cBrj1rvK5HnHxwsNcetd6HEPOn44WGuPWu8cQ84+OFhrj1rvHEPOPjgNcetd4yPOPjgNcetd4yB3j44WGuPWu9DI84+OA1x613lOIecfHCw1x613jIPePjgNcetd5XiHnHxwsNcetd5TiHnHxwsNcetd5XI84+OFhrj1rvKcQ84+OA1x613orxDzj44WGuPWu8ZHnHxwsNcetd5TiHnHxwGuPWu8rkecfHCw1x613opxDzj44WGuPWu8cQ84+OFhrj1rvK8Q86fjhYa49a7ynEPOPjhYa49a7yvEPOPjhYa49a7ymQO8fHCw1x613jiHnHxwsNcetd44h5x8cLDXHrXeMjzj44WGuPWu8cQ84+OA1x613lcjHUfHCw1x613opxDzj44WGuPWu8rxDzp+OFhrj1rvKcQ84+OFhrj1rvGQR1HxwsNcetd6GQO8fHCw1x613jiHnHxwsNcetd6HEPOPjgNcetd4KgO8fHCw1x613leIedPxwsNcetd5TiHnHxwsNcetd44h50/HCw1x613jiHnHxwsNcetd44h5x8cLDXHrXeV4h50/HCw1x613jI84+OFhrj1rvKcQ84+OFhrj1rvKgg94+OFhrj1rvGRjqPjhYa49a7ygI84+OA1x613oZA7x8cLDXHrXegSPOPjhYa49a7xxDHVPxwsNcetd6HEPOPjhYa49a7yvEPOPjhYa49a7ynEPOPjgNcetd44h5x8cLDXHrXeOIecfHCw1x613lcjzwsOch1rvRHP4499ue++K+ePSLHyz1S633jxx77c998V88Qshql1vvHjbv25774r54WRDVLrfePG3ftr33xXzwsiOqXW+8eOOn+/PffFfPCyGqXW+8eNvfbnvvivnhZDVLrfePG3vtz33xXzwshql1vvHjb321774r54WQ1S633jxt37c998V88LDVLrfePHHftz33xXzwshql1vvHjbp/vr33xXzxGw1S633jxx4H81e++K+eIWQ1S633jxx77c998V88LIapdb7x4479ue++K+eFkNUut948be+3PffFfPCyGqXW+8eNvfbnvvivnhYhql1vvHjj321774r54WQ1S633jxt77c998V88RsR1S633jxx7H5s998V88Qshql1vvHjj321774r54WQ1S633gTb321774r54WRDVLrfePHHvtz33xXzwshql1vvHjj325774r54WRHVLrfePHXsfmz33xXzwshql1vvHjb321774r54WQ1S633jxx0f35774r54WQ1S633jxx77c998V88LIapdb7x4499ue++K+eFkNUut94E48B+bPffFfPCyGqXW+8eNvfbnvvivnhZDVLrfePHHvtr33xXzwshql1vvHjb321774r54WQ1S633jxt77c998V88LIapdb7x4499ue++K+eFhql1vvHjj325774r54WQ1S633jxx7H5s998V88LIapdb7x4299ue++K+eFkNUut948cd+3PffFfPCyGqXW+8eOPZ/NnvvivnhZDVLrfePHHj/AH5774r54WQ1S633jxx77c998V88LIhql1vvHjjwH5s998V88LIjql1vvHjj325774r54WQ1S633jxt7P5s998V88LIapdb7x4479ue++K+eFhql1vvHjb325774r54WQ1S633jxt37c998V88LIhql1vvHjjp/vz33xXzwsiOqXW+8eOPfbXvvivnhZENUut948be+3PffFfPCyI6pdb7x4479ue++K+eFkNUut948ce+3PffFfPCyGqXW+8eOPfbnvvivnhYapdb7x4499ue++K+eFkNUut94E499ue++K+eFkNUut948beJ5uvffFfPCyGqXW+8eOvfbnvvivnhZDVLrfePG3ftz33xXzxGw1S633jxx77c998V88Qshql1vvAm3h/fXvvivnhYapdb7wJx77a998V88LDVLrfePG3ftz33xXzwsNUut948ce+3PffFfPCyIapdb7x449j81e++K+eFkR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</binary></FictionBook>